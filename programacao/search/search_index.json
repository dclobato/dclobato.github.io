{"config":{"lang":["pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Apresenta\u00e7\u00e3o","text":"<p>Este site \u00e9 composto por um conjunto de documentos que vai lhe auxiliar durante o aprendizado de algoritmos e de programa\u00e7\u00e3o (inicalmente) em linguagem C.  Ele \u00e9 um material de apoio para as aulas presenciais, e n\u00e3o deve ser tomado como \u00fanica refer\u00eancia bibliogr\u00e1fica para a disciplina.</p> <p>Ao longo do texto, as \"caixinhas\" abaixo podem aparecer. Veja o que cada uma delas significa</p> <p> </p> <p>Aqui voc\u00ea vai encontrar alguns coment\u00e1rios adicionais sobre o texto</p> <p> </p> <p>Aqui voc\u00ea indica\u00e7\u00f5es de documentos e v\u00eddeos recomendados sobre o assunto que est\u00e1 sendo apresentado</p> <p>Veja bem, preste aten\u00e7\u00e3o!</p> <p>Cont\u00e9m alguma observa\u00e7\u00e3o importante e que deve ser considerada</p> <p>Faz isso n\u00e3o...</p> <p>Normalmente usado para indicar alguma coisa que n\u00e3o deve ser feita</p> <p>Yessss!</p> <p>Indica a forma correta de fazer alguma coisa</p> <p>O site est\u00e1 em constante mudan\u00e7a: algumas partes n\u00e3o foram inclu\u00eddas, outras podem ser removidas no futuro.</p> <p>Navegue pelo menu da esquerda, e bons estudos!</p>"},{"location":"algoritmos/","title":"O que s\u00e3o algoritmos?","text":"<p>Como j\u00e1 comentamos anteriormente, um algoritmo \u00e9, fundamentalmente, uma sequ\u00eancia de passos ou regras bem definida que resolve um problema ou executa uma tarefa espec\u00edfica. Ele serve como uma \"receita\", fornecendo um conjunto preciso de instru\u00e7\u00f5es que um computador pode executar para produzir determinado resultado.</p> <p>Crivo de Erat\u00f3stenes</p> <p>O matem\u00e1tico grego Erat\u00f3stenes de Cirene, que viveu entre 276 e 194 AEC, construiu um m\u00e9todo simples e pr\u00e1tico para encontrar n\u00fameros primos at\u00e9 um certo valor limite. Procure por esse m\u00e9todo e, utilizando ele, encontre os n\u00fameros primos menores que 50.</p> <p>O termo \"algoritmo\" n\u00e3o \u00e9 novo, e foi criado em homenagem ao matem\u00e1tico Abu Ja'far Mu\u1e25ammad ibn M\u016bs\u0101 al-Khw\u0101rizm\u012b, que viveu durante o s\u00e9culo IX da Era Comum. Na matem\u00e1tica, \u00e9 comum possuir algoritmos para resolver diversas tarefas, como fatorar n\u00fameros, ou calcular o maior divisor comum entre dois n\u00fameros.</p> <p>As caracter\u00edsticas chave de um algoritmo incluem:</p> <ul> <li>Simplicidade e precis\u00e3o: as a\u00e7\u00f5es devem ser simples e de f\u00e1cil entendimento. A\u00e7\u00f5es complexas devem ser divididas em passos menores que possam ser adequadamente executados. N\u00e3o pode haver espa\u00e7o para ambiguidade ou compreens\u00e3o equivocada em qualquer a\u00e7\u00e3o ou opera\u00e7\u00e3o;</li> <li>Finitude: um algoritmo deve ter uma sequ\u00eancia finita de a\u00e7\u00f5es, garantindo que ele em algum momento acaba e produz um resultado. Isso \u00e9 crucial para impedir repeti\u00e7\u00f5es infinitas ou processos que nunca acabam;</li> <li>Entrada, processamento e sa\u00edda: todos os algoritmos possuem um conjunto de entrada (dados iniciais), processamento (instru\u00e7\u00f5es que transformam a entrada) e sa\u00eddas (resultado do processamento). Essa estrutura permite que algoritmos manipulem dados e produzam resultados espec\u00edficos ao seguir uma l\u00f3gica pr\u00e9-determinada que garante consist\u00eancia e previsibilidade;</li> </ul> <p>Cola no pai que \u00e9 sucesso!</p> <p>Procure, depois, por v\u00eddeos de \"Exact Instruction Challenge\", ou \"Desafio das Instru\u00e7\u00f5es Exatas\" no YouTube e veja a import\u00e2ncia de um algoritmo bem escrito. Aqui tem um exemplo interessante.</p> <p>Al\u00e9m disso, os algoritmos podem ser expressos de diferentes formas, com diferentes graus de facilidade de compreens\u00e3o e execu\u00e7\u00e3o. As formas mais comuns s\u00e3o:</p> <ul> <li>Linguagem natural: os passos s\u00e3o descritos utilizando senten\u00e7as normais do idioma do usu\u00e1rio;</li> <li>Pseudc\u00f3digo: os s\u00e3o passos s\u00e3o descritos utilizando um vocabul\u00e1rio controlado e uma gram\u00e1tica mais simples que a linguagem natural, mas que mesmo assim ainda n\u00e3o pode ser executado pela m\u00e1quina, e;</li> <li>Fluxogramas: Um conjunto padronizado de formas geom\u00e9tricas \u00e9 utilizado para indicar as opera\u00e7\u00f5es que devem ser executadas e o que flui entre elas (dados intermedi\u00e1rios).</li> </ul> <p>A incapacidade do computador de tratar ambiguidades nos obriga a ter a rigidez sem\u00e2ntica: os passos devem estar claros e exatos, e isso acaba \"jogando contra\" adotarmos linguagem natural como forma de representar algoritmos.</p> <p>Veja, por exemplo, a senten\u00e7a \"fui ouvir a banda tocar na janela\". H\u00e1, pelo menos, duas interpreta\u00e7\u00f5es poss\u00edveis para essa senten\u00e7a:</p> Fui at\u00e9 a janela e, de l\u00e1, ouvi a banda que estava tocando em algum lugar A banda estava tocando em alguma janela e eu pude ouv\u00ed-la tocar <p>Mesmo que haja algum contexto, uma m\u00e1quina (e at\u00e9 um ser humano) teria alguma dificuldade em decidir qual dos dois cen\u00e1rios \u00e9 o correto e, mesmo que decidisse por um deles, seria imposs\u00edvel saber se era o correto ou n\u00e3o. Por isso a rigidez sem\u00e2ntica e n\u00e3o ambiguidade \u00e9 t\u00e3o importante.</p> <p>Ao adotar pseudoc\u00f3digo, n\u00f3s conseguimos deixar de lado a ambiguidade, pois utilizamos uma linguagem intermedi\u00e1ria que combina elementos da linguagem natural com estruturas mais formais e padronizadas. O pseudoc\u00f3digo emprega um conjunto limitado de palavras-chave e estruturas predefinidas que possuem significados espec\u00edficos e n\u00e3o d\u00e3o margem a interpreta\u00e7\u00f5es diversas. Por exemplo, ao inv\u00e9s de dizer \"enquanto houver itens na lista, fa\u00e7a algo com eles\", usamos uma estrutura como \"ENQUANTO (condi\u00e7\u00e3o) FA\u00c7A (a\u00e7\u00e3o)\", onde tanto a condi\u00e7\u00e3o quanto a a\u00e7\u00e3o s\u00e3o claramente delimitadas.</p> <p>Esta abordagem elimina as nuances e sutilezas da linguagem cotidiana, criando instru\u00e7\u00f5es diretas e inequ\u00edvocas. Cada comando tem uma \u00fanica interpreta\u00e7\u00e3o poss\u00edvel, o que torna o pseudoc\u00f3digo muito mais preciso que a linguagem natural, embora ainda seja compreens\u00edvel para pessoas sem conhecimento t\u00e9cnico profundo. Al\u00e9m disso, o pseudoc\u00f3digo mant\u00e9m uma estrutura l\u00f3gica que facilita a posterior convers\u00e3o para uma linguagem de programa\u00e7\u00e3o real.</p> <p>Por exemplo, em vez de escrever \"fui ouvir a banda tocar na janela\", poder\u00edamos escrever algo como:</p> Exemplo de pseudoc\u00f3digo<pre><code>SE (banda ESTIVER_NA janela) ENT\u00c3O\n    ouvir banda\nSEN\u00c3O\n    ir at\u00e9 janela\n    ouvir banda\nFIM_SE\n</code></pre> <p>Neste caso, a estrutura <code>SE... ENT\u00c3O... SEN\u00c3O... FIM_SE</code> deixa claro que h\u00e1 duas situa\u00e7\u00f5es poss\u00edveis e quais a\u00e7\u00f5es devem ser tomadas em cada uma delas. Al\u00e9m disso, o uso de palavras como <code>ESTIVER_NA</code> e <code>ir at\u00e9</code> ajuda a evitar interpreta\u00e7\u00f5es amb\u00edguas.</p> <p>Durante o curso, iremos adotar o fluxograma como forma de representa\u00e7\u00e3o dos algoritmos. Isso nos permite uma representa\u00e7\u00e3o visual do que precisa ser feito, ao mesmo tempo que mant\u00e9m a simplicidade e precis\u00e3o da solu\u00e7\u00e3o e permite acompanhar os passos que devem ser executados.</p> <p>Os fluxogramas oferecem vantagens significativas sobre a linguagem natural e o pseudoc\u00f3digo. Primeiramente, sua natureza visual facilita a compreens\u00e3o imediata do fluxo l\u00f3gico de um algoritmo. Ao utilizar s\u00edmbolos padronizados conectados por setas, os fluxogramas criam um mapa visual do processo que permite identificar rapidamente a sequ\u00eancia de opera\u00e7\u00f5es, pontos de decis\u00e3o e trechos que se repetem.</p> <p>Esta representa\u00e7\u00e3o gr\u00e1fica \u00e9 particularmente valiosa para pessoas com estilo de aprendizagem visual, que constituem grande parte da popula\u00e7\u00e3o. Um fluxograma bem constru\u00eddo permite que mesmo pessoas sem conhecimento t\u00e9cnico profundo possam compreender a l\u00f3gica de um algoritmo, pois os s\u00edmbolos intuitivos (como losangos para decis\u00f5es e ret\u00e2ngulos para processos) comunicam claramente a fun\u00e7\u00e3o de cada etapa.</p> <p>Al\u00e9m disso, os fluxogramas facilitam a identifica\u00e7\u00e3o de problemas l\u00f3gicos. Inconsist\u00eancias como caminhos sem sa\u00edda, repeti\u00e7\u00f5es infinitas ou condi\u00e7\u00f5es contradit\u00f3rias tornam-se visualmente evidentes, permitindo corre\u00e7\u00f5es antes mesmo da implementa\u00e7\u00e3o. Esta caracter\u00edstica \u00e9 especialmente \u00fatil durante a fase de planejamento e projeto de algoritmos complexos.</p> <p>Outra vantagem importante dos fluxogramas \u00e9 sua universalidade. Enquanto o pseudoc\u00f3digo pode variar significativamente entre diferentes contextos e institui\u00e7\u00f5es, os s\u00edmbolos de fluxograma s\u00e3o amplamente padronizados e reconhecidos internacionalmente. Isso significa que um fluxograma criado por uma pessoa pode ser facilmente compreendido por outra, independentemente de seu idioma nativo ou forma\u00e7\u00e3o t\u00e9cnica.</p> <p>Em resumo, os fluxogramas oferecem uma combina\u00e7\u00e3o \u00fanica de clareza visual, precis\u00e3o e facilidade de comunica\u00e7\u00e3o, tornando-os uma escolha ideal para representar algoritmos de forma eficaz e compreens\u00edvel.</p>"},{"location":"algoritmos/#como-projetar-um-algoritmo","title":"Como projetar um algoritmo?","text":"<p>Escrever um algoritmo e resolver um quebra-cabe\u00e7a s\u00e3o atividades parecidas.  Cada pe\u00e7a do quebra-cabe\u00e7a \u00e9 uma atividade que precisa ser executada para resolver o problema, que s\u00f3 vai ser resolvido quando as pe\u00e7as corretas estiverem nos lugares corretos. Em geral, as atividades que podem ser feitas s\u00e3o conhecidas a priori, e o desafio repousa na escolha das pe\u00e7as necess\u00e1rias, e na ordem em que elas devem ser usadas.</p> <p>O matem\u00e1tico (olha l\u00e1 ela de novo, a matem\u00e1tica!) h\u00fangaro George P\u00f3lya (1887-1985) possui um livro chamado \"A Arte de Resolver Problemas\" onde ele revela como o m\u00e9todo matem\u00e1tico de demonstrar uma prova ou encontrar uma inc\u00f3gnita pode ajudar voc\u00ea a atacar qualquer problema que possa ser resolvido racionalmente. \u00c9 exatamente isso que precisamos para projetar um algoritmo: encontrar uma forma de resolver problemas.</p> <p>A estrat\u00e9gia do P\u00f3lya pode ser resumida no gr\u00e1fico abaixo<sup>3</sup>. Trata-se de uma estrat\u00e9gia iterativa, em que a solu\u00e7\u00e3o vai sendo constru\u00edda aos pouquinhos. A ideia \u00e9 que, a cada ciclo, melhoremos nosso entendimento sobre o problema e nos aproximemos da solu\u00e7\u00e3o desejada.  \u00c9 importante entender isso agora, no in\u00edcio: os algoritmois raramente ficam prontos na primeira itera\u00e7\u00e3o.  \u00c9 comum fazer duas, tr\u00eas, cinco, dez vers\u00f5es da solu\u00e7\u00e3o at\u00e9 chegar a um algoritmo correto.</p> <pre><code>flowchart TD\n    0([In\u00edcio])\n    9([Final]) \n\n    0 --&gt; A --&gt; F\n    F -- Sim --&gt; B --&gt; C --&gt; D --&gt; E\n    F -- N\u00e3o --&gt; A\n    E -- Sim --&gt; 9\n    E -- N\u00e3o --&gt; F\n\n    A@{ shape: process, label: \"Entender o problema\" }\n    B@{ shape: process, label: \"Construir uma solu\u00e7\u00e3o\" }\n    C@{ shape: process, label: \"Executar a solu\u00e7\u00e3o constru\u00edda\" }\n    D@{ shape: process, label: \"Avaliar o resultado/situa\u00e7\u00e3o\" }\n    E@{ shape: question, label: \"Problema&lt;br&gt;est\u00e1&lt;br&gt;resolvido?\" }\n    F@{ shape: question, label: \"Problema&lt;br&gt;est\u00e1&lt;br&gt;claro?\" }</code></pre> <p>Algoritmo de P\u00f3lya para construir algoritmos (adaptado)</p>"},{"location":"algoritmos/#entendimento-do-problema","title":"Entendimento do problema","text":"<p>Ler o enunciado completo do problema \u00e9 fundametal! A compreens\u00e3o clara do vocabul\u00e1rio e a identifica\u00e7\u00e3o precisa dos dados fornecidos s\u00e3o passos essenciais para a solu\u00e7\u00e3o. Ao decifrar o problema, \u00e9 crucial esclarecer poss\u00edveis d\u00favidas e destacar as informa\u00e7\u00f5es chave que orientar\u00e3o a resolu\u00e7\u00e3o. Al\u00e9m disso, \u00e9 fundamental identificar o resultado esperado para garantir que o racioc\u00ednio esteja alinhado com o objetivo da quest\u00e3o.</p> <p>Uma vez compreendido o enunciado, o pr\u00f3ximo passo \u00e9 determinar as a\u00e7\u00f5es que podem ser executadas por meio de um algoritmo. P\u00f3lya sugere que o solucionador analise quais opera\u00e7\u00f5es, transforma\u00e7\u00f5es ou estrat\u00e9gias podem ser aplicadas aos dados dispon\u00edveis para alcan\u00e7ar a solu\u00e7\u00e3o. Isso envolve um racioc\u00ednio l\u00f3gico e a constru\u00e7\u00e3o de um plano de a\u00e7\u00e3o que direcione as etapas a serem seguidas.</p> <p>Ao se deparar com um problema, \u00e9 \u00fatil perguntar se j\u00e1 houve alguma experi\u00eancia pr\u00e9via com quest\u00f5es semelhantes. \"J\u00e1 vi esse problema antes?\" ou \"conhe\u00e7o algum problema relacionado?\" pode ser uma estrat\u00e9gia eficaz para recuperar solu\u00e7\u00f5es j\u00e1 conhecidas ou identificar padr\u00f5es que ajudem a resolver a situa\u00e7\u00e3o atual. Essa abordagem pode acelerar o processo de solu\u00e7\u00e3o ao aproveitar conhecimentos e m\u00e9todos previamente adquiridos</p> <p>N\u00e3o adianta tentar economizar tempo nesta fase.</p>"},{"location":"algoritmos/#construcao-do-algoritmo","title":"Constru\u00e7\u00e3o do algoritmo","text":"<p>\u00c9 poss\u00edvel transformar o problema atual em um outro que j\u00e1 foi resolvido anteriormente? Muitas vezes, ao reformatar ou reformular a quest\u00e3o, \u00e9 poss\u00edvel aplicar um m\u00e9todo ou estrat\u00e9gia j\u00e1 conhecida. Isso pode ser feito, por exemplo, identificando semelhan\u00e7as estruturais com problemas passados e adaptando as solu\u00e7\u00f5es previamente usadas.</p> <p>Caso o problema continue parecendo complicado, \u00e9 importante avaliar se ele pode ser simplificado. Tente transformar o problema em um auxiliar, reduzindo a quantidade de vari\u00e1veis ou complexidade envolvida. Nesse processo, pode-se come\u00e7ar a resolu\u00e7\u00e3o pelos casos mais simples, aqueles que possuem menos vari\u00e1veis ou que s\u00e3o mais f\u00e1ceis de lidar. Esse m\u00e9todo ajuda a quebrar a dificuldade em partes menores e mais manej\u00e1veis.</p> <p>Al\u00e9m disso, \u00e9 poss\u00edvel \"brincar\" com a solu\u00e7\u00e3o, isto \u00e9, experimentar diferentes combina\u00e7\u00f5es de a\u00e7\u00f5es para observar os efeitos das mudan\u00e7as. Ao fazer isso, \u00e9 poss\u00edvel entender melhor como as v\u00e1rias partes do problema interagem. Por fim, ao perceber padr\u00f5es recorrentes ou estruturas similares durante a experimenta\u00e7\u00e3o, o solucionador deve tentar descrever o algoritmo que organiza essas a\u00e7\u00f5es, o que pode ajudar a formalizar a solu\u00e7\u00e3o e torn\u00e1-la mais eficiente.</p>"},{"location":"algoritmos/#execucao-do-algoritmo","title":"Execu\u00e7\u00e3o do algoritmo","text":"<p>De posse do algoritmo, aplique-o ao problema e verifique o resultado.  N\u00e3o \"invente\" passos n\u00e3o previstos originalmente, nem t\u00e3o pouco \"assuma\" alguma coisa que n\u00e3o foi explicitamente indicado no algoritmo ou na defini\u00e7\u00e3o do problema. Lembre-se que, a m\u00e1quina que vai executar a solu\u00e7\u00e3o, n\u00e3o \u00e9 capaz de \"pensar\", ou \"achar\": ela apenas executa o que lhe for mandado executar.</p>"},{"location":"algoritmos/#avaliacao-do-resultado","title":"Avalia\u00e7\u00e3o do resultado","text":"<p>A quarta - e talvez \u00faltima - fase da resolu\u00e7\u00e3o de problemas, envolve a avalia\u00e7\u00e3o da solu\u00e7\u00e3o proposta. Cada vez que um passo \u00e9 dado, que uma vers\u00e3o da solu\u00e7\u00e3o \u00e9 produzida, o solucionador aprende mais sobre o problema, ajustando e refinando a abordagem conforme necess\u00e1rio. Esse processo de realimenta\u00e7\u00e3o cont\u00ednua \u00e9 essencial, pois permite identificar falhas ou \u00e1reas que precisam de mais aten\u00e7\u00e3o, al\u00e9m de proporcionar uma compreens\u00e3o mais profunda do problema e das solu\u00e7\u00f5es poss\u00edveis.</p> <p>Quando estiver resolvendo um problema auxiliar, a estrat\u00e9gia \u00e9 aumentar gradualmente a complexidade do problema, refinando a solu\u00e7\u00e3o \u00e0 medida que mais vari\u00e1veis ou aspectos s\u00e3o introduzidos. Esse processo de escalonamento permite aproximar-se da solu\u00e7\u00e3o final de forma mais controlada e estruturada, sem se perder na complexidade do problema original. Cada nova itera\u00e7\u00e3o permite uma melhor compreens\u00e3o das intera\u00e7\u00f5es e rela\u00e7\u00f5es entre as vari\u00e1veis, o que facilita a busca por uma solu\u00e7\u00e3o mais eficaz.</p> <p>Se o resultado da avalia\u00e7\u00e3o n\u00e3o for bom (o problema n\u00e3o foi resolvido, a solu\u00e7\u00e3o resolve s\u00f3 parcialmente o problema...) devemos voltar \u00e0 fase de entendimento do problema e repetir as etapas anteriores, ajustar as estrat\u00e9gias utilizadas ou at\u00e9 mesmo reconsiderar o problema sob uma nova perspectiva. A repeti\u00e7\u00e3o do ciclo de tentativas e ajustes \u00e9 um componente chave da metodologia, permitindo que o solucionador se aproxime da solu\u00e7\u00e3o de forma incremental e ajustada.</p>"},{"location":"algoritmos/#o-tamanho-dos-passos-e-a-estrutura-do-algoritmo","title":"O tamanho dos passos e a estrutura do algoritmo","text":"<p>Um dos grandes desafios na constru\u00e7\u00e3o de algoritmos \u00e9 definir qu\u00e3o detalhados devem ser os passos. N\u00e3o existe uma regra de ouro para isso, mas a abordagem geralmente adotada \u00e9 detalhar o suficiente para que o passo esteja descrito em termos das instru\u00e7\u00f5es que o agente que ir\u00e1 executar o algoritmo conhece. Se estivermos falando de um computador, os passos devem ser mapeados para uma (ou para um conjunto) de instru\u00e7\u00f5es da linguagem de programa\u00e7\u00e3o que vai ser utilizada. Se estivermos definindo um algoritmo para um ser humano executar, os passos devem ser mapeados para tarefas elementares n\u00e3o amb\u00edguas.</p> <p>Se voc\u00ea j\u00e1 utilizou um sistema de navega\u00e7\u00e3o baseado em GPS, como o que provavelmente est\u00e1 dispon\u00edvel no seu celular, voc\u00ea j\u00e1 viu e j\u00e1 seguiu um algoritmo. Ao tra\u00e7ar um caminho do seu local atual (dados de entrada) para o seu destino, o programa de navega\u00e7\u00e3o est\u00e1 criando uma sequencia finita de ordenada de passos que voc\u00ea precisa seguir (processamento) para resolver o seu problema (chegar ao destino). O caminho que o programa vai gerar n\u00e3o \u00e9 o \u00fanico: outras sequ\u00eancias finitas e ordenadas de passos (algoritmos) existem para resolver o problema (lev\u00e1-lo do seu local atual at\u00e9 o seu destino).</p> <p>Aqui fica muito claro que:</p> <ul> <li>Os passos existem e devem ser seguidos, todos, na ordem correta. Trocar a ordem dos passos (virar \u00e0 esquerda e depois \u00e0 direita e n\u00e3o ao contr\u00e1rio) ou deixar de executar algum passo (n\u00e3o ter entrado \u00e0 esquerda quando era a hora) n\u00e3o vai resolver o seu problema (vai te levar para o lugar errado);</li> <li>Os passos n\u00e3o possuem ambiguidade, ou seja, s\u00f3 podem ser interpretados e executados de uma \u00fanica forma;</li> <li>O resultado final da execu\u00e7\u00e3o do algoritmo, se mantivermos os valores de entrada, deve ser sempre ou mesmo, ou seja, ele precisa ser determin\u00edstico<sup>1</sup></li> <li>Os passos s\u00e3o finitos. Voc\u00ea come\u00e7a em algum lugar e depois de um n\u00famero finito de \"siga em frente\", \"vire \u00e0 esquerda\" e \"vire \u00e0 direita\" voc\u00ea chega ao seu destino, e;</li> <li>Os passos est\u00e3o no tamanho certo. Cada passo que voc\u00ea deve executar est\u00e1 definido de forma concisa, completa e n\u00e3o amb\u00edgua com instru\u00e7\u00f5es que voc\u00ea conhece e \u00e9 capaz de executar; via de regra, cada passo possui um, e somente um, verbo (a\u00e7\u00e3o).</li> </ul> <p>Ent\u00e3o, deixando claro, os nosso algoritmos ter\u00e3o grosso modo tr\u00eas partes principais, a saber:</p> <ul> <li>Entrada dos dados: \u00e9 a parte (ou partes) onde o algoritmo recebe os dados do mundo exterior, ou seja, as entradas do usu\u00e1rio, os dados pela placa de rede, os sinais de r\u00e1dio que ser\u00e3o modulados, ...;</li> <li>Processamento dos dados: aqui \u00e9 onde o trabalho pesado acontece, e os dados de entrada s\u00e3o transformados para que possamos atingir o objetivo proposto pelo algoritmo; em ess\u00eancia, ele consome os dados de entrada e produz os dados de sa\u00edda, e;</li> <li>Sa\u00edda dos dados: \u00e9 a parte (ou partes) onde o algoritmo coloca dados no mundo exterior, que seja como conte\u00fado de um arquivo, alguma informa\u00e7\u00e3o apresentada na tela, algum sinal de \u00e1udio produzido, ...</li> </ul>"},{"location":"algoritmos/#observacoes-gerais","title":"Observa\u00e7\u00f5es gerais","text":"<p>Conforme voc\u00ea avan\u00e7ar nestes documentos, n\u00e3o tenha medo ou se sinta incapaz se os conceitos parecerem n\u00e3o se encaixar numa primeira leitura. Quando voc\u00ea estava aprendendo a falar, n\u00e3o era problema nos primeiros anos emitir alguns sons estranhos ou balbuciar as coisas. E foi normal precisar de seis ou mais meses para passar de um vocabul\u00e1rio restrito para senten\u00e7as, e tr\u00eas ou quatro anos para evoluir de senten\u00e7as para par\u00e1grafos e constru\u00e7\u00f5es mais complexas.</p> <p>A id\u00e9ia \u00e9 que voc\u00ea n\u00e3o precisa de tr\u00eas ou quatro anos para aprender a construir algoritmos e programar e, por isso, vamos ensinar um bocado de coisa no in\u00edcio -- coisas que permitir\u00e3o a voc\u00ea construir pequenos programas e, com o tempo e a experi\u00eancia (\"a repeti\u00e7\u00e3o leva \u00e0 fixa\u00e7\u00e3o\"), construir programas maiores e complexos.  \u00c9 igual a aprender um novo idioma: \u00e9 preciso tempo e pr\u00e1tica para absorver e compreender as constru\u00e7\u00f5es antes que elas se tornem naturais.</p> <p>Normalmente quando se est\u00e1 aprendendo a primeira linguagem de programa\u00e7\u00e3o, h\u00e1 alguns momentos maravilhosos de \"Ah h\u00e1!\", quando voc\u00ea percebe que enquanto estava batendo em uma pedra com talhadeira e martelo, voc\u00ea est\u00e1, na verdade, esculpindo uma bela escultura.</p> <p>Se alguma coisa parecer especialmente complicada, n\u00e3o faz sentido fica acordado a noite toda encarando ele. Fa\u00e7a uma pausa, tire um cochilo, coma alguma coisa, converse com algu\u00e9m sobre as suas d\u00favidas<sup>2</sup> e ent\u00e3o volte ao problema com a mente descansada.  Eu tenho certeza que quando voc\u00ea aprender os conceitos de programa\u00e7\u00e3o presentes neste livro, voc\u00ea vai olhar para tr\u00e1s perceber que eles eram simples e elegantes, e voc\u00ea apenas precisou de algum tempo para compreend\u00ea-los.</p> <p>Na pr\u00f3xima se\u00e7\u00e3o temos algums desafios l\u00f3gicos para exercitarmos nossa capacidade de entender e resolver problemas.  Vamos l\u00e1?</p> <ol> <li> <p>H\u00e1 uma classes especial de algoritmos que n\u00e3o s\u00e3o determin\u00edsticos, e sim probabil\u00edsticos, mas est\u00e3o fora do escopo deste texto.\u00a0\u21a9</p> </li> <li> <p>Algumas vezes, s\u00f3 de ter que organizar as id\u00e9ias para falar as d\u00favidas em voz alta pode ser suficiente para voc\u00ea perceber onde est\u00e1 o problema, ou mesmo a solu\u00e7\u00e3o para ele.\u00a0\u21a9</p> </li> <li> <p>Viu como fluxogramas s\u00e3o f\u00e1ceis de entender?  Ainda nem explicamos como constru\u00ed-los, mas j\u00e1 estamos apresentando um e seguindo o algoritmo representado nele .\u00a0\u21a9</p> </li> </ol>"},{"location":"bibliografia/","title":"Bibliografia","text":"<p>A seguir, uma lista de refer\u00eancias \u00fateis sobre algoritmos e programa\u00e7\u00e3o em C e Python. De forma alguma \u00e9 uma lista exaustiva, mas apenas um ponto de partida pra te ajudar a estudar.</p> <p>Alguns deles est\u00e3o dispon\u00edveis na Biblioteca Virtual que voc\u00ea pode acessar pelo SUAP, outros est\u00e3o dispon\u00edveis online.</p> <ul> <li>ALU\u00cdSIO, S.. Manual de Boas Pr\u00e1ticas de Programa\u00e7\u00e3o. S\u00e3o Paulo: Instituto de Ci\u00eancias Matem\u00e1ticas e de Computa\u00e7\u00e3o da Universidade de S\u00e3o Paulo, 2010.</li> <li>ASCENCIO, A. F. G.; VENERUCHI DE CAMPOS, E. A.. Fundamentos da programa\u00e7\u00e3o de computadores: algoritmos, PASCAL, C/C++ (padr\u00e3o ANSI) e JAVA. 3. ed. S\u00e3o Paulo, SP: Pearson Education, 2012. (Acesso via Biblioteca Virtual Pearson)</li> <li>BATISTA, E. J. S.. Pensamento Computacional: teoria e pr\u00e1tica. 1. ed. Campo Grande, MS: Editora da UFMS, 2024. Dispon\u00edvel em https://repositorio.ufms.br/handle/123456789/8876.</li> <li>BEECHER, K.. Bad Programming Practices 101: Become a Better Coder by Learning How (Not) to Program. 1. ed. Nova I\u00f3rque, NY: Apress, 2018.</li> <li>BHARGAVA, A. Y.. Entendendo Algoritmos: Um Guia Ilustrado Para Programadores e Outros Curiosos. 1. ed. S\u00e3o Paulo, SP: Novatec, 2018</li> <li>CRUZ, F.. Python: escreva seus primeiros programas. 1. ed. S\u00e3o Paulo, SP: Casa do C\u00f3digo, 2015. (Acesso via Biblioteca Virtual Pearson)</li> <li>DOWNEY, A.; MEYERS, C.; ELKNER, J.. How to Think Like a Computer Scientist: Learning With Python. 1. ed. Wellesley, MA: Green Tea Press, 2002.</li> <li>D\u00dcRR, C.; VIE, J-J.. Competitive Programming in Python: 128 Algorithms to Develop Your Coding Skills. 1. ed. Cambridge: Cambridge University Press, 2021.</li> <li>FEOFILOFF, P.. Algoritmos em Linguagem C. 1. ed. Rio de Janeiro, RJ: Elsevier, 2009.</li> <li>FORBELLONE, A. L. V.; EBERSP\u00c4CHER, H. F.. L\u00f3gica de programa\u00e7\u00e3o: a constru\u00e7\u00e3o de algoritmos e estruturas de dados com aplica\u00e7\u00f5es em Python. 4. ed. S\u00e3o Paulo, SP: Pearson Education, 2022. (Acesso via Biblioteca Virtual Pearson)</li> <li>FORTES, G.; SOARES E SILVA, L.. Aprenda a programar com Python: Descomplicando o desenvolvimento de software. 1. ed. S\u00e3o Paulo, SP: Casa do C\u00f3digo, 2022. (Acesso via Biblioteca Virtual Pearson)</li> <li>GOODLIFFE, P.. Becoming a Better Programmer: A Handbook for People Who Care About Code. 1. ed. Sebastopol, CA: O'Reilly, 2015.</li> <li>GRIES, P.; CAMPBELL, J.; MONTOJO, J.. Practical Programming: An Introduction to Computer Science Using Python 3.6. 3. ed. Raleigh, NC: Pragmatic Programmers, 2017.</li> <li>KELLEY, A.; POHL, I.. A Book on C. 4. ed. Indianapolis, IN: Addison-Wesley, 2001.</li> <li>KERNIGHAN, B. W.; RITCHIE, D. M.. The C Programming Language. 2. ed. Englewood Cliffs, NJ: Prentice Hall, 2010.</li> <li>KLEMENS, B.. 21st Century C: C Tips From the New School. 1. ed. Sebastopol, CA: O'Reilly, 2013.</li> <li>KULIKOV, A.; PEVZNER, P.. Learning Algorithms Through Programming and Puzzle Solving. San Diego: Active Learning Technologies, 2018.</li> <li>LAAKSONEN, A.. Guide to Competitive Programming: Learning and Improving Algorithms Through Contests. 1. ed. Cham: Springer, 2017.</li> <li>LIMA, J. V. F.. Fundamentos de programa\u00e7\u00e3o na Ci\u00eancia de Dados. 1. ed. Santa Maria, RS: Editora da UFSM, 2023. Dispon\u00edvel em http://repositorio.ufsm.br/handle/1/32354</li> <li>LONG, S.. Learn to code with C. 1. ed. Cambridge: Raspberry Pi (Trading) Ltd, 2016.</li> <li>LOPES, A.; AUGUSTO, C.. Introdu\u00e7\u00e3o \u00e0 programa\u00e7\u00e3o: 500 algoritmos resolvidos. 1. ed. Rio de Janeiro, RJ: Elsevier, 2002.</li> <li>MANZANO, Jose Augusto N. G. e FIGUEIREDO DE OLIVEIRA, Jayr. Algoritmos: l\u00f3gica para desenvolvimento de programa\u00e7\u00e3o de computadores. 28. ed. S\u00e3o Paulo, SP: \u00c9rica, 2016.</li> <li>MEDINA, M.; FERTIG, C.. Algoritmos e programa\u00e7\u00e3o: teoria e pr\u00e1tica. 1. ed. S\u00e3o Paulo, SP: Novatec, 2005.</li> <li>O'REGAN, G.. A Brief History of Computing. 3. ed. Cham, Su\u00ed\u00e7a: Springer, 2021.</li> <li>ORAM, A.; WILSON, G. (ed).. Beautiful Code: Leading Programmers Explain How They Think. Sebastopol, CA: O'Reilly Media, 2007.</li> <li>PARREIRA, F.; SILVEIRA, S.; BERTOLINI, C.; SEVERO, R.. Introdu\u00e7\u00e3o a algoritmos. 1. ed. Santa Maria, RS: Editora UFSM, 2017. Dispon\u00edvel em http://repositorio.ufsm.br/handle/1/15820</li> <li>PASCHOALINI, G. R.. Princ\u00edpios de l\u00f3gica de programa\u00e7\u00e3o. 1. ed. S\u00e3o Paulo, SP: Editora SENAI-SP.</li> <li>PETERS, T.. The Zen of Python. 2004. Dispon\u00edvel em https://www.python.org/dev/peps/pep-0020/.</li> <li>RAJAN, R. S.. Excellent Code = Clean and Beautiful Code. Dispon\u00edvel em https://medium.com/swlh/excellent-code-clean-and-beautiful-code-b541ca4b5a39.</li> <li>ROBERTS, E. S.; The Art and Science of C: A Library Based Introduction to Computer Science. 1. ed. [S. l.]: Addison-Wesley, 1995.</li> <li>ROMANO, F.. Learn Python Programming: A Beginner's Guide to Learning the Fundamentals of Python Language to Write Efficient, High-Quality Code. 2. ed. Birmingham: Packt Publishing, 2018.</li> <li>SALVETTI, D. D.; BARBOSA, L. M.. Algoritmos. 1. ed. S\u00e3o Paulo, SP: Pearson Education, 1999.</li> <li>SANTOS, A. C.. Algoritmos e estruturas de dados I. 1. ed. [S. l], AL: Editora da UFAL, 2014. Dispon\u00edvel em https://educapes.capes.gov.br/handle/capes/176522</li> <li>SMITH, G.. Everything You Need to Ace Computer Science and Coding in One Big Fat Notebook: The Complete Middle School Study Guide. 1. ed. Nova I\u00f3rque, NY: Workman Publishing, 2020.</li> <li>SOUZA, B. J.; DIAS JR, J. J. L.; FORMIGA, A. A.. Introdu\u00e7\u00e3o \u00e0 programa\u00e7\u00e3o. 1.0.2. ed. Jo\u00e3o Pessoa, PB: Editora da UFPB, 2014. Dispon\u00edvel em https://github.com/ufpb-computacao/introducao-a-programacao-livro</li> <li>SOUZA, J. N.. L\u00f3gica para ci\u00eancia da computa\u00e7\u00e3o: fundamentos de linguagem, sem\u00e2ntica e sistemas de dedu\u00e7\u00e3o. 1. ed. Rio de Janeiro, RJ: Campus, 2002.</li> <li>TEIXEIRA, R. F. S.. Introdu\u00e7\u00e3o a Algoritmos. 1. ed. Campo Grande, MS: Editora da UFMS, 2019. (Universidade Aberta do Brasil)</li> <li>UEHARA, R.. First Course in Algorithms Through Puzzles. 1. ed. Cingapura: Springer, 2019.</li> <li>Van ROSSUM, G.; WARSAW, B.; COGHLAN, N.. Style Guide for Python Code. 2001. Dispon\u00edvel em https://www.python.org/dev/peps/pep-0008/.</li> <li>WAZLAWICK, R. S.. Hist\u00f3ria da computa\u00e7\u00e3o. 1. ed. Rio de Janeiro, RJ: Elsevier, 2016.</li> <li>WAZLAWICK, R. S.. Introdu\u00e7\u00e3o a Algoritmos e Programa\u00e7\u00e3o com Python: Uma abordagem dirigida por testes. 1. ed. Rio de Janeiro, RJ: Elsevier, 2018.</li> </ul>"},{"location":"boas_praticas/","title":"Boas pr\u00e1ticas de programa\u00e7\u00e3o","text":"<p>\"Uncle Bob\", um dos autores do Manifesto \u00c1gil, usou a figura abaixo no livro \"Clean Code: A Handbook of Agile Software Craftsmanship\". A figura mostra uma m\u00e9trica interessante para medir a qualidade de um software: o n\u00famero de \"mas-que-po**a-\u00e9-essa/minuto\" . </p> <p> </p> <p>Ao analisar um c\u00f3digo escrito por um programador, podemos ter alguns sentimentos sobre o c\u00f3digo, entre eles:</p> <ul> <li>Indigna\u00e7\u00e3o, por um c\u00f3digo que n\u00e3o \u00e9 necess\u00e1rio (\"mas que po**a \u00e9 essa!?\")</li> <li>Admira\u00e7\u00e3o, quando achamos uma solu\u00e7\u00e3o engenhosa (\"po**a!\")</li> <li>Irrita\u00e7\u00e3o, quando n\u00e3o conseguimos entender o que determinado c\u00f3digo faz (\"mas que po**a \u00e9 essa?\")</li> </ul> <p>Qual \u00e9 a primeira coisa que nos impressiona ao ver um c\u00f3digo? Escrever um c\u00f3digo limpo e bonito \u00e9 a marca de um bom programador, ou \"artes\u00e3o de software\".</p> <p>H\u00e1 dois aspectos que fazem um bom artes\u00e3o: conhecimento e trabalho.  O conhecimento ensina os padr\u00f5es, princ\u00edpios, pr\u00e1ticas e heur\u00edsticas necess\u00e1rias para melhorar na profiss\u00e3o, mas esse conhecimento precisa entranhar nos seus dedos, olhos e tripa pela pr\u00e1tica constante e pelo trabalho duro.</p> <p>Aprender a escrever c\u00f3digo limpo \u00e9 um trabalho duro que precisa de pr\u00e1tica, erros, trope\u00e7os e repeti\u00e7\u00e3o das etapas at\u00e9 acertar. N\u00e3o existe atalho para isso: ningu\u00e9m vai se tornar um bom programador vendo outros programarem.</p> <p>O objetivo deste texto \u00e9 apresentar um conjunto de recomenda\u00e7\u00f5es coletadas em diversas fontes que podem ajud\u00e1-lo a dominar a t\u00e9cnica de escrever c\u00f3digos limpos e bonitos. N\u00e3o \u00e9, de forma alguma, uma lista exaustiva, e n\u00e3o s\u00e3o verdades absolutas: s\u00e3o apenas recomenda\u00e7\u00f5es.</p>"},{"location":"boas_praticas/#padronizacao-do-idioma","title":"Padroniza\u00e7\u00e3o do idioma","text":"<p>Apesar da \u00e1rea de computa\u00e7\u00e3o ter muitos documentos t\u00e9cnicos em ingl\u00eas, nada impede que o seu programa seja documentado e implementado em portugu\u00eas.  A \u00fanica coisa que voc\u00ea deve se preocupar \u00e9 em padronizar o idioma: se uma parte das vari\u00e1veis ou nome de Tipos Abstratos de Dados (TAD) est\u00e1 em portugu\u00eas, o resto das vari\u00e1veis e TAD devem seguir em portugu\u00eas.</p> <p>Se voc\u00ea pretende compartilhar seu c\u00f3digo em reposit\u00f3rios p\u00fablicos para que possa ser usado por outros, adotar o ingl\u00eas para documenta\u00e7\u00e3o, nomes de vari\u00e1veis e TAD parece ser uma boa op\u00e7\u00e3o.</p>"},{"location":"boas_praticas/#formatacao-do-codigo","title":"Formata\u00e7\u00e3o do c\u00f3digo","text":"<p>Legibilidade \u00e9 fundamental!</p> <p>Ao digitar o c\u00f3digo do seu programa, faz\u00ea-lo de uma forma padronizada e cuidadosa \u00e9 fundamental para que ele seja leg\u00edvel: para o compilador, pouco importa como o c\u00f3digo \u00e9 digitado, mas para um humano que esteja querendo entender o seu c\u00f3digo n\u00e3o \u00e9 bem assim.</p> <p>Como recomenda\u00e7\u00f5es gerais, temos:</p> <ul> <li>Coloque um comando (statement) por linha. Em C, os statements s\u00e3o finalizados por um ponto-e-v\u00edrgula (<code>;</code>);</li> <li>O c\u00f3digo deve ser expl\u00edcito, sem obfusca\u00e7\u00e3o . Escrever os comandos da forma mais clara poss\u00edvel, evitando otimiza\u00e7\u00f5es que o compilador pode aplicar;</li> <li>Utilize sempre espa\u00e7os para fazer a endenta\u00e7\u00e3o do c\u00f3digo. Algumas linguagens onde a endenta\u00e7\u00e3o importa (Python e COBOL, por exemplo), h\u00e1 diferen\u00e7a entre faz\u00ea-la com TAB ou com espa\u00e7os;</li> <li>Lembre-se de que nem todo mundo possui um monitor de 25\" ultra wide, ent\u00e3o mantenha o seu c\u00f3digo limitado a 72 (estourando 80) colunas. Se o statement n\u00e3o couber nessa largura, quebre-o utilizando o m\u00e9todo da linguagem (no caso de C, uma barra invertida no final da linha);</li> <li>Nos comandos que trabalham com blocos de comandos (<code>for</code>, <code>while</code>, <code>do while</code>, <code>if else</code>) fa\u00e7a a endenta\u00e7\u00e3o do c\u00f3digo para que seja f\u00e1cil identificar o que faz parte de cada bloco;</li> <li>Uso sempre o delimitador de bloco, mesmo que haja apenas um comando no bloco;</li> <li>Um pequeno conjunto de comandos que implemente determinada tarefa pode ficar agrupados, com uma linha em branco que o separe o grupo de outros comandos, e com um coment\u00e1rio sobre o que o aquele grupo de comandos faz.</li> </ul> <p>\u00c9 poss\u00edvel fazer a formata\u00e7\u00e3o autom\u00e1tica de c\u00f3digo fonte utilizando alguns aplicativos (<code>astyle</code><sup>1</sup>, por exemplo) ou dentro da pr\u00f3pria IDE (CLion ou PyCharm, por exemplo).</p> <p>Para o <code>astyle</code>, o seguinte conjunto de par\u00e2metros faz uma formata\u00e7\u00e3o de acordo com as recomenda\u00e7\u00f5es acima:</p> Op\u00e7\u00e3o O que faz -A1 Delimitador de bloco no estilo Allman -s2 Utiliza 2 espa\u00e7os para endenta\u00e7\u00e3o -S Endenta o case do bloco switch -Y Endenta os coment\u00e1rios em linha para o n\u00edvel do bloco -f Acrescenta uma linha em branco ao final dos blocos -H Espa\u00e7a a abertura de par\u00eanteses dos comandos <code>if</code>, <code>for</code>, <code>while</code> -U Remove espa\u00e7os adicionais entre os par\u00eanteses -k3 Alinha o operador de ponteiro e refer\u00eancia com o nome da vari\u00e1vel -j Adiciona chaves aos blocos com apenas um comando -xC76 Linhas com no m\u00e1ximo 76 caracteres -xW Endenta blocos do pr\u00e9-processador -xV Coloca o <code>while</code> final de um bloco <code>do while</code> na mesma linha do fechamento do bloco -w Endenta defini\u00e7\u00f5es do pr\u00e9-processador que terminem com barra invertida (<code>\\</code>) -p Insere espa\u00e7os em volta de operadores e v\u00edrgulas -xe Apaga linhas em branco dentro de uma fun\u00e7\u00e3o -xb Cria bloco para comandos de uma linha -c Converte TAB em espa\u00e7os <p>Para o c\u00f3digo fonte em Python, existe a PEP 8 (guia de estilo para c\u00f3digo Python<sup>2</sup>), e devem ser seguidas, especialmente se o c\u00f3digo ser\u00e1 desenvolvido de forma colaborativa. Uma mudan\u00e7a aceit\u00e1vel em alguns contextos \u00e9 utilizar 2 espa\u00e7os ao inv\u00e9s de 4 espa\u00e7os para indenta\u00e7\u00e3o do bloco. Se for esse o caso, \u00e9 poss\u00edvel configurar o PyCharm para ignorar essa viola\u00e7\u00e3o adicionando E111 e E114 aos erros que devem ser ignorados em <code>Settings &gt; Editor &gt; Inspections &gt; PEP 8 Coding Style Violations</code>.</p> <p>Aqui um belo contra exemplo de o que fazer com o seu c\u00f3digo<sup>3</sup>:</p> C\u00f3digoResultado <pre><code>#include &lt;stdio.h&gt;  \n#define _(main,O) (1+1.)*(argc main(1&lt;&lt;(1&lt;&lt;1&lt;&lt;1|1&lt;&lt;1)))/\\  \n(float)(1&lt;&lt;((1&lt;&lt;1&lt;&lt;1|1&lt;&lt;1)-k)) - ((1&lt;&lt;1|1)-k) / (1+1.);\\  \nO k  \n#define l (k&amp;1)*(1&lt;&lt;1)  \n#define I O[l  \nfloat O[(1&lt;&lt;1&lt;&lt;1&lt;&lt;1)-(1&lt;&lt;1)];  \nint k;  \nint main ( int argc, char **argv )  \n{  \n    float o=k^=k;  \n    O[1&lt;&lt;1] = O[1&lt;&lt;1&lt;&lt;1]=_(%,++);  \n    O[1&lt;&lt;1|1]=O[1&lt;&lt;1&lt;&lt;1|1]=_(/,--);  \n    argc = argv ? (int)(argv = 0) : argc;  \n    while ( ++k &lt; 1 &lt;&lt; ( 1 &lt;&lt; (1 | 1 &lt;&lt; 1) ) &amp;&amp; o &lt; 1 &lt;&lt; ( 1 &lt;&lt; ( 1 &lt;&lt; 1 ) ) )  \n    {  \n        O[ ( 1 &lt;&lt; 1 ) - l ] = 4[O] + (I] + I + 1]) * (I] - I + 1]) ,  \n        O[ ( 1 &lt;&lt; 1 | 1 ) - l ] = 5[O] + ( 1 &lt;&lt; 1 ) * I] * I + 1]  ;  \n        o = (I] - O[(1&lt;&lt;1)-l] ) * (I]-O[(1&lt;&lt;1)-l] ) +  \n            (I+1] - O[(1&lt;&lt;1|1)-l] ) * (I+1] - O[(1&lt;&lt;1|1)-l] ) ;  \n    }  \n    if ( putchar ( k&amp;1&lt;&lt;(1&lt;&lt;(1&lt;&lt;1|1))?k&gt;&gt;(1&lt;&lt;1):1&lt;&lt;(1&lt;&lt;(1&lt;&lt;1)|1) ) &amp;&amp;  \n         !(++argc%(1&lt;&lt;((1&lt;&lt;1&lt;&lt;1&lt;&lt;1)-(1&lt;&lt;1)))) &amp;&amp;  \n         putchar ( (1&lt;&lt;1&lt;&lt;1&lt;&lt;1)+(1&lt;&lt;1) ) ) ;  \n    return ( argc &lt;1 &lt;&lt;11 ) ? main ( argc, argv ) : 0;  \n}\n</code></pre> <pre><code>                                            @\n                                          @@@@@\n                                         @@@@@@@\n                                          @@@@@\n                                     @@@@@@@@@@@@@  @\n                               @@@ @@@@@@@@@@@@@@@@@@@  @@\n                                @@@@@@@@@@@@@@@@@@@@@@@@@@@\n                            @ @@@@@@@@@@@@@@@@@@@@@@@@@@@@\n                            @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n           @@ @@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n           @@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n         @@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n      @  @@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n      @  @@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n         @@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n           @@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n           @@ @@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n                            @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n                            @ @@@@@@@@@@@@@@@@@@@@@@@@@@@@\n                                @@@@@@@@@@@@@@@@@@@@@@@@@@@\n                               @@@ @@@@@@@@@@@@@@@@@@@  @@\n                                     @@@@@@@@@@@@@  @\n                                          @@@@@\n                                         @@@@@@@\n                                          @@@@@\n                                            @    \n</code></pre> <p>Ou ent\u00e3o o c\u00f3digo abaixo<sup>4</sup>:</p> C\u00f3digoResultado <pre><code>#include&lt;stdio.h&gt;\nmain() \n{\nint i,l,u;  \n\nchar *ilu=\"STILL THINKING HOW I DID IT?\\\n!r/g.g#i.g/g!j/g.g#i.g/g+g!q0g!mag/h(g!m]g+g!p&lt;g!h`i!l`g!k`g!h\\\n&lt;g+g!p}g!i}g!i}g!h0g!g]g}g!g}h`g!h}g+g!p&lt;g!h`g}g`g!h}g`h]g`g0g}\\\ng0g!g}g`g!h&lt;g+g!q]g!n`g!o0g+g!r]g`h!g]g`g0h!g]g}g!g}g!j0g+g!n`g!\\\ni0g!h}g!g}g!g]g`g0g]g`g0g!h0g(g+g!m}g!g]g!h]g0g`g0g]g!n0g(g+g!m]g\\\n`g]g}g!g0g!g`h!gag]g!j0g(g+g!p]g0g`g0g`h]g!hag]g0g(g!k/g.h&gt;g(g0g\\\n g]g+g!i`j-g`h0g`h-g`k-g`l*g0g!i0g|g g~i+g!i.g-g.k-g.h]g.h-g.k-\\\ng.i-g]g(g.g(g!g|h g~h+g!q`h0g]g`g!r(g.h&gt;g/g]g~g0g+g!p0g`g0g!g\\\n}g]h+g!u]g0g\";\n\n    for(i=28;l=ilu[i++];)\n        for(u=(*(ilu+++i)-((1&lt;&lt;6)+(1&lt;&lt;5)+(1&lt;&lt;2)+(1&lt;&lt;1)));u--;)\n            putchar(!((l-11)^(1&lt;&lt;5))?l-1-(1&lt;&lt;5):l-1);\n\n}\n</code></pre> <pre><code>            .-\"\"\"-.    .-\"\"\"-.\n           /       `..'       \\\n          ;  ___      _     _  ;\n          |   |   |  / \\| ||_  |\n          ;  _|_  |__\\_/|/ |_  ;\n           \\        _         /\n            \\__ \\_// \\| |    /\n        _   /  | | \\_/\\_/  /'\n       | \\  \\/_/\\        /'\n       \\_\\| / __ `\\    /'\n          \\/_/__\\  `\\/'     .--='/~\\\n   ____,__/__,_____,______)/   /{~}}}\n   -,-----,--\\--,-----,---,\\'-' {{~}}\n           __/\\_            '--=.\\}/\n          /_/ |\\\\\n               \\/\n</code></pre>"},{"location":"boas_praticas/#nomenclatura-de-variaveis","title":"Nomenclatura de vari\u00e1veis","text":"<p>Toda a vari\u00e1vel, fun\u00e7\u00e3o, classe ou constante deve ter um nome que responda tr\u00eas perguntas b\u00e1sicas:</p> <ul> <li>Por que ela existe?</li> <li>O que ela faz?</li> <li>O que \u00e9 usado?</li> </ul> <p>As vari\u00e1veis devem possuir um padr\u00e3o de nome. Muitos programadores utilizam Pascal Case<sup>5</sup> com o padr\u00e3o <code>&lt;modificador&gt;&lt;tipo&gt;&lt;nome&gt;</code>. Essa padroniza\u00e7\u00e3o \u00e9 muito parecida com a nota\u00e7\u00e3o H\u00fangara<sup>6</sup>. Para linguagens com tipagem est\u00e1tica (C, C++, Java...) a nota\u00e7\u00e3o H\u00fangara \u00e9 redundante, pois o compilador \u00e9 capaz e identificar os tipos e verific\u00e1-los. Por outro lado, nas linguagens com tipagem din\u00e2mica (Python, Perl, PHP...) a nota\u00e7\u00e3o H\u00fangara pode ajudar a padronizar os nomes de vari\u00e1veis de uma forma concisa e precisa para os programadores.</p> <p>O <code>&lt;tipo&gt;</code> indica o tipo base da vari\u00e1vel, de acordo com o quadro abaixo</p> Tipo Letra <code>int</code> <code>i</code> <code>float</code> <code>f</code> <code>double</code> <code>d</code> <code>char</code> <code>c</code> <p>Quando o tipo da vari\u00e1vel possuir modificadores, eles devem seguir o quadro abaixo</p> Modificador Letra <code>unsigned</code> <code>u</code> <code>short</code> <code>s</code> <code>long</code> <code>l</code> <p>Vari\u00e1veis do tipo ponteiro devem ter a letra <code>p</code> precedendo o modificador.</p> <p>Alguns exemplos de nomes de vari\u00e1veis que seguem estas recomenda\u00e7\u00f5es s\u00e3o:</p> <ul> <li><code>iContador</code></li> <li><code>puiResultado</code></li> <li><code>cNomeDoUsuario</code></li> <li><code>ldRaiz</code></li> </ul>"},{"location":"boas_praticas/#nomenclatura-de-funcoes","title":"Nomenclatura de fun\u00e7\u00f5es","text":"<p>Tal como as vari\u00e1veis, as fun\u00e7\u00f5es precisam ter nomes que indiquem o que elas fazem.  Se forem fun\u00e7\u00f5es dentro do mesmo arquivo do programa principal, basta escrever o nome usando Pascal Case.  Se a fun\u00e7\u00e3o fizer parte de uma biblioteca ou m\u00f3dulo separado, o nome da fun\u00e7\u00e3o deve ser precedido do nome da biblioteca (do arquivo <code>.h</code>) e de um underline.</p> <p>Por exemplo, uma fun\u00e7\u00e3o que fa\u00e7a parte do m\u00f3dulo de utilit\u00e1rios e que fa\u00e7a a valida\u00e7\u00e3o de um n\u00famero de CPF pode ter o nome <code>Utilitarios_ValidaCPF</code>.</p> <p>Essa estrat\u00e9gia \u00e9 especialmente \u00fatil por duas raz\u00f5es:</p> <ul> <li>O programador sabe rapidamente onde encontrar a fun\u00e7\u00e3o ou documenta\u00e7\u00e3o dela, e;</li> <li>Alguns ambientes de desenvolvimento \u2013 como o CLion e o Code-Blocks \u2013 possuem mecanismos de \"auto-completar\" nome de vari\u00e1veis e fun\u00e7\u00f5es.</li> </ul>"},{"location":"boas_praticas/#nomenclatura-de-constantes","title":"Nomenclatura de constantes","text":"<p>As constantes definidas por meio de macro substitui\u00e7\u00e3o (<code>#define</code>) devem possuir nomes que fa\u00e7am sentido e devem ser escritas em Snake Case all caps (<code>#define MAX_ITENS 20</code>).</p> <p>Quando a constante for definida com o modificador <code>const</code>, deve ser precedida das letras que identificam o tipo e o modificador, mas tamb\u00e9m escritas em Snake Case all caps (<code>static const int iMAX_ITENS = 20;</code>)</p>"},{"location":"boas_praticas/#comentarios","title":"Coment\u00e1rios","text":"<p>\u00c9 verdade que um c\u00f3digo bem escrito geralmente \u00e9 auto-documentado, mas isso n\u00e3o exime o programador de documentar bem o seu c\u00f3digo. Se o c\u00f3digo est\u00e1 mal escrito, n\u00e3o adianta document\u00e1-lo: \u00e9 melhor reescrev\u00ea-lo.</p> <p>Um bom coment\u00e1rio n\u00e3o repete o c\u00f3digo ou o explica. Ele deixa claro o seu prop\u00f3sito. Os coment\u00e1rios devem explicar, em um n\u00edvel de abstra\u00e7\u00e3o maior que o c\u00f3digo fonte, o que voc\u00ea est\u00e1 tentando fazer.</p> <p>Os coment\u00e1rios podem ser usados, tamb\u00e9m, para justificar determinadas tomadas de decis\u00e3o do programador (por que usar um algoritmo de ordena\u00e7\u00e3o e n\u00e3o outro, por exemplo).</p> <p>Metadados do programa (autor, data de modifica\u00e7\u00e3o, licen\u00e7a de uso...) tamb\u00e9m podem ser armazenadas, no pr\u00f3prio programa, por meio de coment\u00e1rios. Esses metadados s\u00e3o referenciados, geralmente, como anota\u00e7\u00f5es. As anota\u00e7\u00f5es podem incluir outras informa\u00e7\u00f5es, como tipos de dados para argumentos de fun\u00e7\u00f5es. Essas anota\u00e7\u00f5es podem ser lidas por programas especiais que geram documenta\u00e7\u00e3o autom\u00e1tica de c\u00f3digo, como \u00e9 o caso do Doxygen e do Sphinx.</p> <p>Alguns programadores (e ambientes de desenvolvimento) podem usar coment\u00e1rios como marcadores informais para ajudar a indexar problemas comuns, por exemplo:</p> <ul> <li><code>BUG</code> ou <code>FIXME</code>: para indicar um c\u00f3digo problem\u00e1tico que precisa ser corrigido</li> <li><code>HACK</code>: uma corre\u00e7\u00e3o tempor\u00e1ria que precisa ser melhorada</li> <li><code>TODO</code>: alguma coisa que precisa ser feita</li> <li><code>UNDONE</code>: para indicar que determinada altera\u00e7\u00e3o foi desfeita</li> <li><code>XXX</code>: avisar outros programadores de um c\u00f3digo problem\u00e1tico ou equivocado </li> </ul> <p>Os coment\u00e1rios podem ser inline (em linha) ou stream (de bloco ou pr\u00f3logo).</p> <p>Os coment\u00e1rios em linha come\u00e7am com um delimitador de coment\u00e1rio e continuam at\u00e9 o final da linha ou, em alguns casos, iniciam em uma coluna espec\u00edfica (deslocamento da linha de caracteres) no c\u00f3digo-fonte e continuam at\u00e9 o final da linha.</p> <p>Os coment\u00e1rios do bloco delimitam uma regi\u00e3o do c\u00f3digo-fonte que pode abranger v\u00e1rias linhas ou parte de uma \u00fanica linha. Essa regi\u00e3o \u00e9 especificada com um delimitador inicial e um delimitador final.</p>"},{"location":"boas_praticas/#cabecalhos-de-funcoes","title":"Cabe\u00e7alhos de fun\u00e7\u00f5es","text":"<p>Para cada fun\u00e7\u00e3o que vai ser criada, \u00e9 importante descrev\u00ea-la corretamente para facilitar a manuten\u00e7\u00e3o do c\u00f3digo. Por isso, recomenda-se que cada prot\u00f3tipo de fun\u00e7\u00e3o (e idealmente a implementa\u00e7\u00e3o) seja precedido de um bloco de coment\u00e1rio contendo, no m\u00ednimo, o nome da fun\u00e7\u00e3o, o que ela faz, quais par\u00e2metros recebe, o que ela retorna, e quais erros podem ser retornados.</p> <p>Note</p> <p>A maior parte das IDEs \u00e9 capaz de gerar automaticamente esse cabe\u00e7alho, portanto n\u00e3o existe raz\u00e3o para n\u00e3o documentar corretamente todas as fun\u00e7\u00f5es!</p> <p>O padr\u00e3o a ser adotado depende de como a documenta\u00e7\u00e3o vai ser gerada. Para as IDEs, o formato \u00e9 indiferente, pois elas geralmente suportam v\u00e1rios formatos de docstring. Abaixo, exemplo de documenta\u00e7\u00e3o de uma fun\u00e7\u00e3o tanto no padr\u00e3o do Doxygen quanto do Sphinx.</p> DoxygenSphinx <pre><code>/**\n * @brief Cria um novo usu\u00e1rio na base de dados.\n * \n * @details \n * - O email \u00e9 armazenado em letras min\u00fasculas para garantir consist\u00eancia.\n * - A senha \u00e9 armazenada como um hash usando `generate_password_hash()`.\n * - Gera um segredo OTP usando `pyotp.random_base32()`.\n * - Gera 5 c\u00f3digos de backup de 6 caracteres cada, armazenando-os na tabela `backupkeys` em formato hash.\n * - Retorna o segredo OTP e os c\u00f3digos de backup em texto plano para o usu\u00e1rio.\n * \n * @param conn Conex\u00e3o com o banco de dados SQLite. (sqlite3.Connection)\n * @param email Email do usu\u00e1rio. (str)\n * @param senha Senha em texto plano. (str)\n * @param use_otp Indica se o usu\u00e1rio vai utilizar 2FA. (bool) Padr\u00e3o: False\n * \n * @return \n * - `None`: Se o usu\u00e1rio j\u00e1 existir.\n * - `Tuple[str, str, List[str]]`: Contendo:\n *     - Segredo OTP,\n *     - URI para configura\u00e7\u00e3o do autenticador,\n *     - Lista de c\u00f3digos de backup em texto plano, se o usu\u00e1rio tiver configurado 2FA.\n */\n</code></pre> <pre><code>\"\"\"\n    Cria um novo usu\u00e1rio na base de dados.\n\n    - O email \u00e9 armazenado em letras min\u00fasculas para garantir consist\u00eancia.\n    - A senha \u00e9 armazenada como um hash usando generate_password_hash().\n    - Gera um segredo OTP usando pyotp.random_base32().\n    - Gera 5 c\u00f3digos de backup de 6 caracteres cada, armazenando-os na tabela backupkeys\n      em formato hash.\n    - Retorna o segredo OTP e os c\u00f3digos de backup em texto plano para o usu\u00e1rio.\n\n    Arguments:\n        conn (sqlite3.Connection): Conex\u00e3o com o banco de dados SQLite.\n        email (str): Email do usu\u00e1rio.\n        senha (str): Senha em texto plano.\n        use_otp (bool): O usu\u00e1rio vai utilizar 2FA (default: False)\n\n    Returns:\n        None se o usu\u00e1rio j\u00e1 existir; Tuple[str, str, List[str]] contendo segredo OTP, URI\n        para configura\u00e7\u00e3o do autenticador e lista de c\u00f3digos de backup em texto plano se\n        usu\u00e1rio tiver configurado 2FA.\n\"\"\"\n</code></pre>"},{"location":"boas_praticas/#qual-padrao-usar","title":"Qual padr\u00e3o usar?","text":"<p>Use Sphinx (PEP 257) se:</p> <ul> <li>Seu projeto \u00e9 majoritariamente ou inteiramente Python.</li> <li>Voc\u00ea prefere docstrings simples e leg\u00edveis que seguem as conven\u00e7\u00f5es padr\u00e3o do Python.</li> <li>Voc\u00ea deseja usar ferramentas como Sphinx, pdoc ou pydoc, que se integram muito bem com docstrings no estilo Python.</li> <li>Voc\u00ea precisa gerar documenta\u00e7\u00e3o em HTML altamente estilizada, especialmente se usar o Sphinx com extens\u00f5es.</li> <li>Voc\u00ea prefere manter a documenta\u00e7\u00e3o dentro dos arquivos Python e aproveitar ferramentas para gera\u00e7\u00e3o autom\u00e1tica de APIs.</li> </ul> <p>Use Coment\u00e1rios no Estilo Doxygen se:</p> <ul> <li>Voc\u00ea possui um projeto que mistura v\u00e1rias linguagens (Python, C, C++, C#, etc.) e deseja um estilo consistente de documenta\u00e7\u00e3o em todas as linguagens.</li> <li>Voc\u00ea quer produzir documenta\u00e7\u00e3o em m\u00faltiplos formatos (HTML, LaTeX, PDF, etc.) com uma \u00fanica ferramenta.</li> <li>Sua equipe j\u00e1 utiliza Doxygen para outras partes do projeto (por exemplo, c\u00f3digo em C/C++) e deseja uma abordagem unificada.</li> <li>Voc\u00ea prefere coment\u00e1rios altamente estruturados e deseja controle detalhado sobre a formata\u00e7\u00e3o.</li> <li>Voc\u00ea precisa de documenta\u00e7\u00e3o para c\u00f3digo que ser\u00e1 cross-compilado ou integrado com linguagens n\u00e3o Python.</li> </ul> <p>Se o seu projeto \u00e9 principalmente Python, mas cont\u00e9m componentes em C/C++ (ou voc\u00ea prev\u00ea a integra\u00e7\u00e3o com outras linguagens), voc\u00ea pode:</p> <ul> <li>Usar docstrings no estilo PEP 257 para o c\u00f3digo Python.</li> <li>Usar coment\u00e1rios no estilo Doxygen para o c\u00f3digo n\u00e3o-Python.</li> <li>Combinar a documenta\u00e7\u00e3o gerada utilizando ferramentas como Doxysphinx, que permite ao Sphinx integrar a documenta\u00e7\u00e3o gerada pelo Doxygen.</li> </ul>"},{"location":"boas_praticas/#construtores-e-destrutores","title":"Construtores e destrutores","text":"<p>Todo o tipo abstrato de dados deve ter fun\u00e7\u00f5es construtoras e destrutoras</p> <p>No construtor, deve ser concentrada toda inicializa\u00e7\u00e3o de vari\u00e1vel da biblioteca (aloca\u00e7\u00e3o de mem\u00f3ria). Esse procedimento facilita a destrui\u00e7\u00e3o (desaloca\u00e7\u00e3o) de vari\u00e1veis, que deve ser realizada na fun\u00e7\u00e3o destrutor. Para cada chamada do Construtor, necessariamente ao final do uso da vari\u00e1vel ou final do programa dever\u00e1 ter uma chamada do Destrutor.</p> <p>Os nomes das fun\u00e7\u00f5es construtora e destrutora devem ser adaptadas ao contexto do programa. O cabe\u00e7alho da fun\u00e7\u00e3o deve indicar se ela \u00e9 uma construtora ou destrutora no campo de descri\u00e7\u00e3o.</p>"},{"location":"boas_praticas/#ponteiros","title":"Ponteiros","text":"<p>Toda a vari\u00e1vel do tipo ponteiro para <code>T</code> deve ser verificada antes de ser acessada, exceto nos construtores, que ir\u00e3o alocar a mem\u00f3ria com chamadas como <code>malloc</code> ou <code>calloc</code>.</p> <p>Nos construtores, depois de alocar a mem\u00f3ria, \u00e9 fundamental verificar se ela foi alocada corretamente. Se houver algum problema na aloca\u00e7\u00e3o, o ponteiro apontar\u00e1 para <code>NULL</code>.</p> <p>Toda vez que uma fun\u00e7\u00e3o receber um ponteiro como argumento, ele deve ser verificado se \u00e9 nulo ou n\u00e3o antes de ser utilizado.</p> <p>\u00c9 importante verificar se para cada <code>malloc</code> no c\u00f3digo, h\u00e1 um <code>free</code> em algum outro ponto do c\u00f3digo. Por exemplo, um <code>malloc</code> em uma fun\u00e7\u00e3o construtora precisa de um <code>free</code> em uma fun\u00e7\u00e3o destrutora.</p>"},{"location":"boas_praticas/#biblioteca-de-erros","title":"Biblioteca de erros","text":"<p>Conforme os seus programas crescem, manter uma biblioteca que indique quais erros suas fun\u00e7\u00f5es retornam come\u00e7a a se tornar fundamental. A ideia \u00e9 que voc\u00ea crie uma biblioteca onde os erros (ou estados) comuns estejam listados. Assim, um programador consegue entender o que significa determinado retorno de uma fun\u00e7\u00e3o sem precisar inspecionar o c\u00f3digo.</p> <p>Um exemplo de biblioteca est\u00e1 indicado a seguir.</p> bib_erro.h<pre><code>#ifndef BIBLIOERRO_H_INCLUDED   \n#define BIBLIOERRO_H_INCLUDED  \n\n/*Biblioteca que define os tipos de erros poss\u00edveis*/   \n/*Dispon\u00edvel ao usu\u00e1rio e parte da documenta\u00e7\u00e3o*/  \n\n#define ERRO_SUCESSO 0   \n#define ERRO_PONTEIRO_NULO 1   \n#define ERRO_ENDERECO_INVALIDO 2   \n#define ERRO_MEMORIA_INSUFICIENTE 3   \n#endif\n</code></pre> <p>Outra op\u00e7\u00e3o \u00e9 definir os c\u00f3digos de erro utilizando um enumerador, como no exemplo a seguir.</p> bib_erro.h<pre><code>#ifndef BIBLIOERRO_H_INCLUDED   \n#define BIBLIOERRO_H_INCLUDED  \ntypedef enum  \n{ \n  ERRO_SUCESSO,\n  ERRO_PONTEIRO_NULO,\n  ERRO_ENDERECO_INVALIDO,\n  ERRO_MEMORIA_INSUFICIENTE\n} ERRO_CODIGO\n#endif\n</code></pre> <ol> <li> <p>https://astyle.sourceforge.net/ \u21a9</p> </li> <li> <p>https://peps.python.org/pep-0008/ \u21a9</p> </li> <li> <p>https://www.quora.com/What-is-are-the-best-obfuscated-C-code-you-have-ever-written \u21a9</p> </li> <li> <p>https://ideone.com/I0HTec \u21a9</p> </li> <li> <p>Pascal Case \u00e9 quando as diversas palavras que comp\u00f5em um nome s\u00e3o escritas com os espa\u00e7os removidos e utilizando caixa alta para todas as primeiras letras das palavras (<code>AquiUmExemploDePascalCase</code>). H\u00e1 outras op\u00e7\u00f5es como Camel Case (<code>aquiUmExemploDeCamelCase</code>) e Snake Case (<code>aqui_um_exemplo_de_snake_case</code>).\u00a0\u21a9</p> </li> <li> <p>https://en.wikipedia.org/wiki/Hungarian_notation \u21a9</p> </li> </ol>"},{"location":"desafios/","title":"Desafios de l\u00f3gica","text":"<p>Em cada uma das se\u00e7\u00f5es seguintes temos um desafio de l\u00f3gica, para dar uma aquecida no c\u00e9rebro. Tente resolv\u00ea-lo utilizando a estrat\u00e9gia proposta por P\u00f3lya, e que vimos anteriormente.</p>"},{"location":"desafios/#as-tres-amigas","title":"As tr\u00eas amigas","text":"<p>Dica</p> <p>Comece eliminando possibilidades com base nas regras e tente atribuir cores ou op\u00e7\u00f5es uma por uma at\u00e9 encontrar uma combina\u00e7\u00e3o que funcione</p> <p>Tr\u00eas amigas estavam andando. Seus nomes s\u00e3o Rosa, Violeta e Branca.</p> <p>Rosa disse:</p> <p>Olha s\u00f3!  Estamos vestindo camisas de cores rosa, violeta e branca, mas nenhuma de n\u00f3s est\u00e1 vestindo camisa com a cor do nosso nome.</p> <p>Ao que a amiga com camisa violeta respondeu:</p> <p>Isso \u00e9 apenas uma coincid\u00eancia, minha cara</p> <p>Qual a cor de camisa de cada amiga?</p> Resposta <p>Rosa afirma que nenhuma delas est\u00e1 vestindo a cor que corresponde ao pr\u00f3prio nome. Isso significa que Rosa n\u00e3o est\u00e1 vestindo rosa, Violeta n\u00e3o est\u00e1 vestindo violeta e Branca n\u00e3o est\u00e1 vestindo branco.</p> <p>A mulher vestindo a camisa violeta responde: \"Isso \u00e9 uma coincid\u00eancia\". Isso significa que a pessoa que falou essa frase concorda com a afirma\u00e7\u00e3o inicial; logo, n\u00e3o pode ser a Violeta, pois ela est\u00e1 vestindo a camisa violeta.</p> <p>Agora, vamos deduzir a cor da camisa de cada amiga:</p> <p>A Violeta n\u00e3o est\u00e1 usando a camisa violeta, ent\u00e3o ela s\u00f3 pode estar usando a camisa rosa ou a branca. Se a Violeta estivesse usando a camisa rosa, ent\u00e3o a Rosa teria que estar usando a camisa violeta (pois a Branca n\u00e3o pode usar a camisa branca). Mas sabemos que a amiga com a camisa violeta n\u00e3o \u00e9 a Violeta. Portanto, a Violeta deve estar usando a camisa branca.</p> <p>Agora que sabemos que a Violeta est\u00e1 usando a camisa branca, podemos deduzir as cores das camisas das outras amigas:</p> <p>A Rosa n\u00e3o pode estar usando a camisa rosa, e como a camisa branca j\u00e1 est\u00e1 sendo usada pela Violeta, a Rosa deve estar usando a camisa violeta. Por fim, a Branca deve estar usando a camisa rosa, pois \u00e9 a \u00fanica cor restante.</p> <p>Assim, a distribui\u00e7\u00e3o das cores seria:</p> <ul> <li>Rosa: violeta</li> <li>Branca: rosa</li> <li>Violeta: branco</li> </ul>"},{"location":"desafios/#o-lobo-a-cabra-e-o-repolho","title":"O lobo, a cabra e o repolho","text":"<p>Dica</p> <p>Pense em desfazer temporariamente um movimento anterior para manter os pares problem\u00e1ticos separados.</p> <p>Imagine que um fazendeiro vive em uma pequena vila e precisa transportar, de sua fazenda, tr\u00eas itens: um lobo, uma cabra e um repolho gigante. Em um determinado dia, ele decide atravessar o rio que separa suas terras, pois do outro lado ele pretende aumentar a \u00e1rea plantada de repolho. Contudo, o \u00fanico meio de travessia dispon\u00edvel \u00e9 um barco velho e pequeno, que s\u00f3 tem capacidade para o pr\u00f3prio fazendeiro e mais um dos seus companheiros \u2013 seja o lobo, a cabra ou o repolho.</p> <p>O desafio, por\u00e9m, n\u00e3o se limita \u00e0 limita\u00e7\u00e3o de espa\u00e7o do barco. Existem regras cruciais que o fazendeiro deve seguir para evitar desastres durante as travessias:</p> <p>Se o lobo ficar sozinho com a cabra, sem a presen\u00e7a do fazendeiro, o lobo aproveitaria a oportunidade para devorar a cabra. De maneira similar, se a cabra ficar sozinha com o repolho, ela n\u00e3o resistiria \u00e0 tenta\u00e7\u00e3o e comeria o repolho. Portanto, em cada momento \u2013 seja na margem de origem ou na margem de destino \u2013 o arranjo dos itens deve ser cuidadosamente planejado para que nunca se encontre uma situa\u00e7\u00e3o em que o lobo e a cabra ou a cabra e o repolho fiquem juntos sem a supervis\u00e3o do fazendeiro.</p> <p>Qual sequ\u00eancia de viagens pelo rio permitir\u00e1 que o fazendeiro, utilizando seu modesto barco, transporte com seguran\u00e7a o lobo, a cabra e o repolho para o outro lado, garantindo que, em nenhum momento, ocorra uma situa\u00e7\u00e3o de perigo?</p> Resposta <p>O fazendeiro precisa atravessar o rio com seguran\u00e7a, garantindo que nem o lobo coma a cabra, nem a cabra coma o repolho. Para isso, ele deve seguir a seguinte sequ\u00eancia de travessias.</p> <p>Vamos assumir a seguinte nota\u00e7\u00e3o para a solu\u00e7\u00e3o a seguir:</p> <ul> <li>F: fazendeiro</li> <li>L: lobo</li> <li>C: cabra</li> <li>R: repolho</li> <li>: barco</li> </ul> Descri\u00e7\u00e3o Margem esquerda Margem direita Estado inicial FLCR O fazendeiro leva a cabra para a margem direita LR FC O fazendeiro retorna sozinho para a margem esquerda FLR C O fazendeiro leva o lobo para a margem direita R FLC O fazendeiro traz a cabra de volta para a margem esquerda FCR L O fazendeiro leva o repolho para a margem direita C FLR O fazendeiro retorna sozinho para a margem esquerda FC LR O fazendeiro leva a cabra para a margem direita FLCR <p>Seguindo essa sequ\u00eancia de travessias, o fazendeiro consegue transportar com seguran\u00e7a o lobo, a cabra e o repolho para a outra margem do rio, sem que ocorra nenhuma situa\u00e7\u00e3o de perigo em que o lobo fique sozinho com a cabra ou a cabra fique sozinha com o repolho</p>"},{"location":"desafios/#cruzando-a-ponte","title":"Cruzando a ponte","text":"<p>Dica</p> <p>Tente reduzir o tempo gasto nas viagens de volta com a tocha otimizando quem faz a viagem de retorno.</p> <p>Em uma noite escura, quatro amigos aventureiros precisam atravessar uma ponte velha para escapar de uma floresta cheia de perigos. No entanto, h\u00e1 v\u00e1rios desafios a serem superados. Primeiro, a ponte \u00e9 extremamente fr\u00e1gil e s\u00f3 pode suportar no m\u00e1ximo duas pessoas ao mesmo tempo. Segundo, n\u00e3o h\u00e1 ilumina\u00e7\u00e3o al\u00e9m de uma \u00fanica tocha que eles precisam carregar para enxergar o caminho. E, para piorar, cada um dos quatro amigos caminha em velocidades diferentes devido \u00e0 idade e condi\u00e7\u00e3o f\u00edsica.</p> <p>Os tempos que cada um leva para atravessar a ponte individualmente s\u00e3o os seguintes:</p> <ul> <li>Abelardo, o mais \u00e1gil do grupo leva apenas 1 minuto.</li> <li>Benedito, o segundo mais r\u00e1pido leva 2 minutos.</li> <li>Carlos, o terceiro, um pouco mais lento, precisa de 5 minutos.</li> <li>Dagoberto, o \u00faltimo, que \u00e9 o mais velho e mais cansado, leva 10 minutos para atravessar.</li> </ul> <p>Quando duas pessoas atravessam juntas, elas devem se mover na velocidade da pessoa mais lenta. Al\u00e9m disso, a tocha deve ser levada sempre que algu\u00e9m atravessar, pois sem ela ningu\u00e9m consegue enxergar na escurid\u00e3o.</p> <p>O objetivo \u00e9 encontrar a estrat\u00e9gia mais r\u00e1pida poss\u00edvel para que todos cheguem ao outro lado da ponte em seguran\u00e7a. Qual \u00e9 o menor tempo necess\u00e1rio para completar a travessia e como deve ser organizada a sequ\u00eancia de idas e voltas?</p> Resposta <p>Vamos assumir a seguinte nota\u00e7\u00e3o para as solu\u00e7\u00f5es a seguir:</p> <ul> <li>A: Abelardo</li> <li>B: Benedito</li> <li>C: Carlos</li> <li>D: Dagoberto</li> <li>: Tocha</li> </ul> <p>Estrat\u00e9gia 1</p> Descri\u00e7\u00e3o Antes da ponte Depois da ponte Tempo do passo Tempo acumulado Situa\u00e7\u00e3o inicial ABCD Abelardo e Benedito atravessam CD AB 2 2 Abelardo retorna ACD B 1 3 Carlos e Dagoberto atravessam A BCD 10 13 Benedito retorna AB CD 2 15 Abelardo e Benedito atravessam ABCD 2 17 Total 17 <p>Estrat\u00e9gia 2</p> Descri\u00e7\u00e3o Antes da ponte Depois da ponte Tempo do passo Tempo acumulado Situa\u00e7\u00e3o inicial ABCD Abelardo e Benedito atravessam CD AB 2 2 Benedito retorna BCD A 2 4 Carlos e Dagoberto atravessam B ACD 10 14 Abelardo retorna AB CD 1 15 Abelardo e Benedito atravessam ABCD 2 17 Total 17 <p>Em ambas as estrat\u00e9gias, a chave \u00e9 usar os amigos mais r\u00e1pidos para as viagens de retorno com a tocha e fazer com que os mais lentos atravessem juntos. Assim, a travessia de todos pode ser completada em 17 minutos, e essas duas varia\u00e7\u00f5es s\u00e3o equivalentes em termos de tempo total.</p>"},{"location":"desafios/#os-chapeus-dos-magicos","title":"Os chap\u00e9us dos m\u00e1gicos","text":"<p>Dica</p> <p>Pense bem na l\u00f3gica do racioc\u00ednio deles e no que o sil\u00eancio inicial pode significar.</p> <p>Tr\u00eas m\u00e1gicos est\u00e3o sentados ao redor de uma mesa, cada um usando um chap\u00e9u que pode ser vermelho ou azul. Nenhum deles consegue ver o pr\u00f3prio chap\u00e9u, apenas os chap\u00e9us dos outros dois.</p> <p>O organizador do desafio lhes d\u00e1 as seguintes informa\u00e7\u00f5es:</p> <ul> <li>Pelo menos um dos tr\u00eas est\u00e1 usando um chap\u00e9u vermelho.</li> <li>Eles n\u00e3o podem se comunicar entre si de nenhuma forma al\u00e9m de pensar sobre o que est\u00e3o vendo.</li> <li>Se conseguirem deduzir a cor do pr\u00f3prio chap\u00e9u, devem diz\u00ea-lo em voz alta assim que tiverem certeza.</li> </ul> <p>Os tr\u00eas m\u00e1gicos olham ao redor, analisam o que veem e, ap\u00f3s um breve sil\u00eancio, todos dizem ao mesmo tempo a cor do pr\u00f3prio chap\u00e9u com certeza absoluta. Como cada um deles conseguiu deduzir a cor do pr\u00f3prio chap\u00e9u e qual deve ser essa cor?</p> Resposta <p>Todos os tr\u00eas m\u00e1gicos est\u00e3o usando chap\u00e9us vermelhos.</p> <p>Observa\u00e7\u00e3o inicial Cada m\u00e1gico sabe que h\u00e1 pelo menos um chap\u00e9u vermelho. Se algum deles visse os outros dois usando chap\u00e9us azuis, ele imediatamente concluiria que o seu pr\u00f3prio chap\u00e9u deve ser vermelho para satisfazer a condi\u00e7\u00e3o.</p> <p>Sil\u00eancio imediato Como ningu\u00e9m falou imediatamente, nenhum dos m\u00e1gicos viu dois chap\u00e9us azuis. Portanto, cada um observou que pelo menos um dos outros estava usando um chap\u00e9u vermelho.</p> <p>Racioc\u00ednio rec\u00edproco Suponha que um m\u00e1gico (digamos, o m\u00e1gico A) veja que tanto B quanto C est\u00e3o usando chap\u00e9us vermelhos. A pensa:</p> <p>\"Se meu chap\u00e9u fosse azul, ent\u00e3o B veria um chap\u00e9u azul (o meu) e um vermelho (o de C). Nesse cen\u00e1rio, B poderia ter uma d\u00favida, mas, se B tivesse visto dois chap\u00e9us azuis, ele falaria imediatamente. O fato de que ningu\u00e9m falou logo significa que B n\u00e3o viu dois azuis. Agora, sabendo que B n\u00e3o conseguiu determinar de imediato, ele tamb\u00e9m deve estar passando pelo mesmo racioc\u00ednio, o que s\u00f3 seria poss\u00edvel se todos estiv\u00e9ssemos usando chap\u00e9us vermelhos.\"</p> <p>Conclus\u00e3o simult\u00e2nea Esse racioc\u00ednio se aplica a cada m\u00e1gico. Cada um, ao ver dois chap\u00e9us vermelhos e refletir sobre o sil\u00eancio dos outros, deduziu que seu pr\u00f3prio chap\u00e9u tamb\u00e9m devia ser vermelho. Assim, ap\u00f3s o breve sil\u00eancio, todos falaram ao mesmo tempo: \"vermelho.\"</p> <p>Dessa forma, cada m\u00e1gico, usando o mesmo racioc\u00ednio l\u00f3gico, concluiu corretamente que seu chap\u00e9u era vermelho.</p>"},{"location":"desafios/#duas-portas","title":"Duas portas","text":"<p>Dica</p> <p>Que tal fazer uma pergunta que force ambos os guardas a dar a mesma resposta sobre uma das portas?</p> <p>Voc\u00ea est\u00e1 em uma sala com duas portas misteriosas. Uma delas leva \u00e0 liberdade, enquanto a outra esconde um destino terr\u00edvel. No entanto, voc\u00ea n\u00e3o sabe qual \u00e9 qual. Ao lado de cada porta, h\u00e1 um guarda. Um deles sempre diz a verdade (o Cavaleiro), enquanto o outro sempre mente (o Trapaceiro). No entanto, voc\u00ea n\u00e3o sabe qual deles \u00e9 qual, mas eles sabem.</p> <p>Para escapar com seguran\u00e7a, voc\u00ea pode fazer apenas uma \u00fanica pergunta a um dos guardas. A resposta ser\u00e1 um simples \"sim\" ou \"n\u00e3o\".</p> <p>Qual pergunta voc\u00ea deve fazer e como ela garante que voc\u00ea escolha a porta correta?</p> Resposta <p>A pergunta que voc\u00ea deve fazer a um dos guardas \u00e9:</p> <p>\"Se eu perguntar ao outro guarda se a porta que ele est\u00e1 guardando leva \u00e0 liberdade, ele responderia 'sim'?\"</p> <p>Agora, vamos analisar as poss\u00edveis respostas e como elas indicam qual porta voc\u00ea deve escolher:</p> <ol> <li> <p>Se voc\u00ea perguntar ao Cavaleiro (que sempre diz a verdade):</p> <ul> <li>Se a porta do Cavaleiro leva \u00e0 liberdade, o Trapaceiro mentiria e diria \"n\u00e3o\". Neste caso, o Cavaleiro responderia \"n\u00e3o\" \u00e0 sua pergunta.</li> <li>Se a porta do Trapaceiro leva \u00e0 liberdade, o Trapaceiro mentiria e diria \"n\u00e3o\". Neste caso, o Cavaleiro responderia \"sim\" \u00e0 sua pergunta.</li> </ul> </li> <li> <p>Se voc\u00ea perguntar ao Trapaceiro (que sempre mente):</p> <ul> <li>Se a porta do Cavaleiro leva \u00e0 liberdade, o Trapaceiro sabe que o Cavaleiro diria \"sim\". Mas, como o Trapaceiro mente, ele responder\u00e1 \"n\u00e3o\" \u00e0 sua pergunta.</li> <li>Se a porta do Trapaceiro leva \u00e0 liberdade, o Trapaceiro sabe que o Cavaleiro diria \"n\u00e3o\". Mas, como o Trapaceiro mente, ele responder\u00e1 \"sim\" \u00e0 sua pergunta.</li> </ul> </li> </ol> <p>Em resumo:</p> <ul> <li>Se a resposta for \"n\u00e3o\", escolha a porta do guarda a quem voc\u00ea fez a pergunta.</li> <li>Se a resposta for \"sim\", escolha a porta do outro guarda.</li> </ul>"},{"location":"desafios/#os-missionarios-e-os-canibais","title":"Os mission\u00e1rios e os canibais","text":"<p>Tr\u00eas mission\u00e1rios e tr\u00eas canibais precisam curzar um rio. Eles t\u00eam a disposi\u00e7\u00e3o um barco capaz de transportar duas pessoas. Por quest\u00f5es de seguran\u00e7a (e sobreviv\u00eancia), em nenhum momento pode haver mais canibais que mission\u00e1rios em uma margem ou dentro do barco (\u00e9 ok ter o mesmo n\u00famero de canibais e mission\u00e1rios). Como eles devem se organizar para efetuar essa travessia?</p> Resposta <p>Vamos assumir a seguinte nota\u00e7\u00e3o para a solu\u00e7\u00e3o a seguir:</p> <ul> <li>M: mission\u00e1rio</li> <li>C: canibal</li> <li>: barco</li> </ul> Descri\u00e7\u00e3o Margem esquerda Margem direita Estado inicial MMMCCC Dois canibais atravessam para a direita MMMC CC Um canibal retorna para a esquerda MMMCC C Dois canibais atravessam para a direita MMM CCC Um canibal retorna para a esquerda MMMC CC Dois mission\u00e1rios atravessam para a direita MC MMCC Um mission\u00e1rio e um canibal retornam para a esquerda MMCC MC Dois mission\u00e1rios atravessam para a direita CC MMMC Um canibal retorna para a esquerda CCC MMM Dois canibais atravessam para a direita C MMMCC Um canibal retorna para a esquerda CC MMMC Dois canibais atravessam para a direita MMMCCC"},{"location":"fluxograma/","title":"Fluxogramas","text":"<p>Um fluxograma \u00e9 uma representa\u00e7\u00e3o gr\u00e1fica de um algoritmo (ou combina\u00e7\u00f5es de tipos de processamento) que utiliza s\u00edmbolos predefinidos e linhas de conex\u00e3o para ilustrar uma sequ\u00eancia de opera\u00e7\u00f5es que conduzem a um resultado desejado. Esta ferramenta visual emprega s\u00edmbolos espec\u00edficos, como ovais (in\u00edcio/fim), ret\u00e2ngulos (processos/a\u00e7\u00f5es), losangos (pontos de decis\u00e3o) e setas (dire\u00e7\u00e3o do fluxo de trabalho), cada um com significados particulares que ajudam a representar conceitos complexos em etapas simples e compreens\u00edveis, mesmo por quem n\u00e3o \u00e9 da \u00e1rea de inform\u00e1tica.</p>"},{"location":"fluxograma/#principais-simbolos","title":"Principais s\u00edmbolos","text":"<p>Os principais s\u00edmbolos utilizados em fluxogramas s\u00e3o:</p> <ul> <li>Terminal: Representa o in\u00edcio ou fim de um processo. Geralmente cont\u00e9m termos como \"In\u00edcio\", \"Come\u00e7o\" ou \"Fim\" e \u00e9 posicionado no topo/esquerda (in\u00edcio) ou na parte inferior/direita (fim) do fluxograma.</li> </ul> <p>Veja bem, preste aten\u00e7\u00e3o!</p> <p>S\u00f3 pode haver um \"In\u00edcio\" e um \"Fim\".</p> <pre><code>   flowchart LR\n      A\n      B\n      A@{ shape: stadium, label: \"In\u00edcio\" }\n      B@{ shape: stadium, label: \"Fim\" }</code></pre> <p>S\u00edmbolo para terminal</p> <ul> <li>Processo: Um dos s\u00edmbolos mais comuns, representa uma etapa, tarefa, atividade ou opera\u00e7\u00e3o no fluxo do processo. \u00c9 considerado o componente b\u00e1sico de um fluxograma.</li> </ul> <pre><code>   flowchart LR\n      A\n      A@{ shape: process, label: \"x &amp;larr; x + 1\" }</code></pre> <p>S\u00edmbolo para processo</p> <ul> <li>Fluxo: Mostra a dire\u00e7\u00e3o e a ordem do processo, conectando os v\u00e1rios s\u00edmbolos do fluxograma. Tamb\u00e9m pode indicar retorno a determinados processos at\u00e9 que uma condi\u00e7\u00e3o seja atendida. \u00c9 poss\u00edvel e recomendado adicionar r\u00f3tulos ao fluxo em um fluxograma. Os r\u00f3tulos s\u00e3o utilizados principalmente para fornecer informa\u00e7\u00f5es adicionais sobre a transi\u00e7\u00e3o entre etapas ou para clarificar condi\u00e7\u00f5es, como por exemplo em fluxos que saem de s\u00edmbolos de decis\u00e3o (losangos), para indicar claramente qual caminho seguir com base na resposta (como \"Sim\" ou \"N\u00e3o\") ou para adicionar informa\u00e7\u00f5es sobre condi\u00e7\u00f5es espec\u00edficas que devem ser atendidas para seguir determinado caminho.</li> </ul> <pre><code>   flowchart LR\n    A --&gt; B -- Sim --&gt; C\n\n    A@{ shape: process, label: \" \" }\n    B@{ shape: process, label: \" \" }\n    C@{ shape: process, label: \" \" }\n    style A fill:#FFFFFF00, stroke:#FFFFFF00;\n    style B fill:#FFFFFF00, stroke:#FFFFFF00;\n    style C fill:#FFFFFF00, stroke:#FFFFFF00;</code></pre> <p>S\u00edmbolo para fluxo</p> <ul> <li>Decis\u00e3o: Representa um ponto de decis\u00e3o no fluxo do processo, quando h\u00e1 mais de um resultado poss\u00edvel para uma etapa espec\u00edfica. Geralmente cont\u00e9m perguntas de sim/n\u00e3o ou verdadeiro/falso, com caminhos diferentes dependendo da resposta.</li> </ul> <pre><code>   flowchart LR\n      A\n      A@{ shape: question, label: \"saldo &gt; 10\"}</code></pre> <p>S\u00edmbolo para decis\u00e3o (testar se o saldo \u00e9 maior que 10)</p> <ul> <li>Entrada: Representa opera\u00e7\u00f5es de entrada de dados por meio da intera\u00e7\u00e3o do usu\u00e1rio com o programa (o usu\u00e1rio digita alguma coisa, por exemplo)</li> </ul> <pre><code>   flowchart LR\n      A\n      A@{ shape: manual-input, label: \" idade \"}</code></pre> <p>S\u00edmbolo para entrada de dados (ler o valor de idade)</p> <ul> <li>Sa\u00edda: Representa opera\u00e7\u00f5es de sa\u00edda de dados no terminal, como a exibi\u00e7\u00e3o de resultados, ou em algum dispositivo de impress\u00e3o.</li> </ul> <pre><code>   flowchart TD\n      A\n      B\n      A@{ shape: display, label: \"A\"}\n      B@{ shape: doc, label: \"B\"}</code></pre> <p>S\u00edmbolos para sa\u00edda de dados (mostrar o valor de A; imprimir o valor de B)</p> <ul> <li>Conector: Usado para conectar diferentes partes de um fluxograma, especialmente em diagramas complexos. Geralmente cont\u00e9m n\u00fameros ou letras para facilitar a refer\u00eancia.</li> </ul> <pre><code>   flowchart LR\n      Nada --&gt; A\n      Nada@{ shape: process, label: \" \" }\n      style Nada fill:#FFFFFF00,stroke:#FFFFFF00\n      A@{ shape: circle, label: \"A\"}\n\n      B --&gt; Nada2\n      Nada2@{ shape: process, label: \" \" }\n      style Nada2 fill:#FFFFFF00,stroke:#FFFFFF00\n      B@{ shape: circle, label: \"A\"}\n</code></pre> <p>S\u00edmbolo para conector (v\u00e1 para o conector A, acima; ponto de chegada A, abaixo)</p>"},{"location":"fluxograma/#outros-simbolos-usados-em-fluxogramas","title":"Outros s\u00edmbolos usados em fluxogramas","text":"<ul> <li>Armazenamento em mem\u00f3ria secund\u00e1ria: Indica que determina informa\u00e7\u00e3o est\u00e1 sendo armazenada ou recuperada da mem\u00f3ria secund\u00e1ria, como por exemplo o disco r\u00edgido</li> </ul> <pre><code>   flowchart TD\n      A\n      B\n      A@{ shape: das, label: \"Arquivo com as m\u00e9dias\"}\n      B@{ shape: lin-cyl, label: \"Arquivo com as m\u00e9dias\"}</code></pre> <p>S\u00edmbolos para armazenamento em mem\u00f3ria secund\u00e1ria</p> <ul> <li>Prepara\u00e7\u00e3o condicional: Geralmente usado para representar uma \"prepara\u00e7\u00e3o\" ou \"inicializa\u00e7\u00e3o\" de uma condi\u00e7\u00e3o. Isso significa que ele \u00e9 usado para configurar valores ou realizar c\u00e1lculos que ser\u00e3o usados posteriormente em uma decis\u00e3o. </li> </ul> <pre><code>   flowchart LR\n      A\n      A@{ shape: prepare, label: \"Recuperar arquivos de notas fiscais\"}</code></pre> <p>S\u00edmbolo para prepara\u00e7\u00e3o condicional</p> <ul> <li>Opera\u00e7\u00e3o manual: Quando alguma tarefa precisa ser executada fora do programa, para que o programa possa ser executado, podemos utilizar o s\u00edmbolo que indica uma opera\u00e7\u00e3o manual. </li> </ul> <pre><code>   flowchart LR\n      A\n      A@{ shape: trap-t, label: \"Coletar provas dos alunos\"}</code></pre> <p>S\u00edmbolo para prepara\u00e7\u00e3o condicional</p>"},{"location":"fluxograma/#exemplos-de-fluxogramas","title":"Exemplos de Fluxogramas","text":"<p>Conhecendo os s\u00edmbolos, podemos come\u00e7ar a construir fluxogramas para resolver determinados problemas. Vamos ver alguns exemplos de problemas e um poss\u00edvel fluxograma que resolva o problema (lembre-se que um problema pode ser resolvido de v\u00e1rias formas).</p> <p>O ideal \u00e9 desenhar o fluxograma de cima para baixo, e da esquerda para a direita.  Em alguns casos, \u00e9 aceit\u00e1vel fazendo apenas da esquerda para a direita.</p> <ul> <li>A divis\u00e3o de dois n\u00fameros pode ser feita como uma sucess\u00e3o de subtra\u00e7\u00f5es do valor do divisor do valor do dividendo. O n\u00famero de divis\u00f5es que puderam ser feitas antes de o dividendo ficar menor que zero \u00e9 o quociente, e o que sobrou do dividendo \u00e9 o resto da divis\u00e3o. Fa\u00e7a um fluxograma que leia o dividendo e o divisor e apresente o quociente e o resto utilizando o m\u00e9todo das subtra\u00e7\u00f5es sucessivas</li> </ul> <pre><code>   flowchart TD\n      I([In\u00edcio]) --&gt; A --&gt; B --&gt; C\n      C -- Sim --&gt; D --&gt; E --&gt; C\n      C -- N\u00e3o --&gt; F --&gt; G --&gt; Z([Fim])\n\n      A@{ shape: manual-input, label: \"dividendo&lt;br&gt;divisor\" }\n      B@{ shape: process, label: \"quociente &amp;larr; 0\" }\n      C@{ shape: question, label: \"dividendo &gt;= divisor?\" }\n      D@{ shape: process, label: \"dividendo &amp;larr; dividendo - divisor\" }\n      E@{ shape: process, label: \"quociente &amp;larr; quociente + 1\" }\n      F@{ shape: process, label: \"resto &amp;larr; dividendo\" }\n      G@{ shape: curv-trap, label: \"quociente&lt;br&gt;resto\" }</code></pre> <ul> <li>Chico tem 150cm e cresce 2cm por ano, enquanto Z\u00e9 tem 110cm e cresce 3cm por ano. Construa um fluxograma que calcule e imprima quantos anos s\u00e3o necess\u00e1rios para que Z\u00e9 fique mais alto que Chico</li> </ul> <pre><code>   flowchart TD\n      I([In\u00edcio]) --&gt; A --&gt; B\n      B -- Sim --&gt; C --&gt; Z([Fim])\n      B -- N\u00e3o --&gt; D --&gt; B\n\n      A@{ shape: process, label: \"chico &amp;larr; 150&lt;br&gt;ze &amp;larr; 110&lt;br&gt;anos &amp;larr; 0\" }\n      B@{ shape: question, label: \"ze &gt; chico?\" }\n      C@{ shape: curv-trap, label: \"anos\" }\n      D@{ shape: process, label: \"ze &amp;larr; ze + 3&lt;br&gt;chico &amp;larr; chico + 2&lt;br&gt;anos &amp;larr; anos + 1\" }</code></pre> <ul> <li>Uma empresa paga ao vendedor uma comiss\u00e3o calculada de acordo com o valor de suas vendas. Se o valor da venda de um corretor for de \\(\\text{R\\$}~50000.00\\) ou mais, a comiss\u00e3o ser\u00e1 de 12% do valor vendido. Se o valor da venda for maior que \\(\\text{R\\$}~30000.00\\) e menor que \\(\\text{R\\$}~50000.00\\), a comiss\u00e3o \u00e9 de 9,5%. Nos demais casos, a comiss\u00e3o \u00e9 de 7%.\u00a0 Leia o total de vendas de um vendedor e imprima a comiss\u00e3o devida pela empresa a ele.</li> </ul> <pre><code>flowchart TD\n    0([In\u00edcio]) --&gt; A --&gt; B\n    B -- Sim --&gt; C --&gt; G\n    B -- N\u00e3o --&gt; D\n    D -- Sim --&gt; E --&gt; G\n    D -- N\u00e3o --&gt; F --&gt; G\n    subgraph Sub1[ ]\n    direction LR\n    H --&gt; I --&gt; Z([Fim])\n    end\n\n    A@{ shape: manual-input, label: \"totalVendas\" }\n    B@{ shape: question, label: \"totalVendas&lt;br /&gt;&gt;= 50000\" }\n    C@{ shape: process, label: \"comissao &amp;larr; totalVendas * 12/100\" }\n    D@{ shape: question, label: \"totalVendas &lt;br /&gt;&gt; 30000\" }\n    E@{ shape: process, label: \"comissao &amp;larr; totalVendas * 9.5/100\" }\n    F@{ shape: process, label: \"comissao &amp;larr; totalVendas * 7/100\" }\n    G@{ shape: circle, label: \"A\" }\n    H@{ shape: circle, label: \"A\" }\n    I@{ shape: display, label: \"comissao\" }\n    style Sub1 fill:#FFFFFF00, stroke:#FFFFFF00;</code></pre> <ul> <li>Jo\u00e3o e Maria s\u00e3o amigos desde que se conheceram na creche. Desde ent\u00e3o, eles compartilham uma rotina de brincadeiras: todas as vezes que eles se encontram, eles jogam Cara ou Coroa com uma moeda, e quem ganhar tem o privil\u00e9gio de decidir quais brincadeiras eles ir\u00e3o jogar durante o dia. Maria sempre escolhe cara, e Jo\u00e3o sempre escolhe coroa. Hoje em dia eles est\u00e3o na faculdade, mas continuam sendo bons amigos. Sempre que se encontram, eles ainda jogam Cara ou Coroa, e o vencedor decide que filme assistir, ou em que restaurante jantar, e assim por diante. Ontem Maria contou a Jo\u00e3o que ela guarda um registro de todas as vezes que eles jogaram, desde os tempos da creche. Jo\u00e3o ficou espantado. Por\u00e9m Jo\u00e3o est\u00e1 estudando Ci\u00eancia da Computa\u00e7\u00e3o e decidiu que essa era uma boa oportunidade para mostrar a Maria suas habilidades em programa\u00e7\u00e3o, escrevendo um programa que mostrasse o n\u00famero de vezes que cada um deles venceu ao longo de todos esses anos. Leia um inteiro N que indica o n\u00famero de partidas jogadas, e depois N inteiros que indicam se Maria (0) ou Jo\u00e3o (1) ganhou a partida. Por fim, diga quantas partidas Jo\u00e3o ganhou, e quantas partidas Maria ganhou.</li> </ul> <pre><code>flowchart TD\n    0([In\u00edcio])\n    9([Final])    \n\n    0 --&gt; A --&gt; B --&gt; C\n    C -- Sim --&gt; I --&gt; 9\n    C -- N\u00e3o --&gt; D --&gt; E\n    E -- Sim --&gt; F --&gt; J\n    E -- N\u00e3o --&gt; H --&gt; K\n    L --&gt; G --&gt; C\n\n    A@{ shape: manual-input, label: \"N\" }\n    B@{ shape: process, label: \"joaoVitorias &amp;larr; 0&lt;br /&gt;mariaVitorias &amp;larr; 0&lt;br /&gt;contador &amp;larr; 0\" }\n    C@{ shape: question, label: \"contador == N\" }\n    D@{ shape: manual-input, label: \"resultado\" }\n    E@{ shape: question, label: \"resultado == 1\" }\n    F@{ shape: process, label: \"joaoVitorias &amp;larr; joaoVitorias + 1\" }\n    G@{ shape: process, label: \"contador &amp;larr; contador + 1\" }\n    H@{ shape: process, label: \"mariaVitorias &amp;larr; mariaVitorias + 1\" }\n    I@{ shape: display, label: \"joaoVitorias&lt;br /&gt;mariaVitorias\" }\n\n    J@{ shape: circle, label: \"A\"}\n    K@{ shape: circle, label: \"A\"}\n    L@{ shape: circle, label: \"A\"}</code></pre>"},{"location":"porqueaprenderaprogramar/","title":"Por que voc\u00ea deve aprender a escrever programas?","text":"<p>Escrever programas (ou programar) \u00e9 uma atividade muito criativa e recompensadora. Voc\u00ea pode escrever programas por muitas raz\u00f5es, que variam desde ganhar dinheiro resolvendo problemas complexos de an\u00e1lise de dados, at\u00e9 simplesmente se divertir ajudando algu\u00e9m a resolver um problema. As p\u00e1ginas que comp\u00f5em este site assume que todos precisam aprender a programar, e uma vez que voc\u00ea tenha aprendido, cabe a voc\u00ea decidir o que fazer com as suas novas habilidades.</p> <p>Estamos cercados, no nosso dia-a-dia, por computadores que variam de laptops a telefones celulares. Podemos pensar nesses computadores como nossos assistentes pessoais, capazes de resolver v\u00e1rios problemas para n\u00f3s. O hardware em nossos computadores atuais foi constru\u00eddo para, basicamente, perguntar de forma cont\u00ednua: \"o que eu devo fazer agora?\".</p> <p>Os programadores adicionam um sistema operacional e um conjunto de aplica\u00e7\u00f5es ao hardware e acabam com um assistente pessoal que \u00e9 suficientemente \u00fatil e capaz de ajudar-nos a fazer v\u00e1rias coisas diferentes.</p> <p>Nossos computadores s\u00e3o r\u00e1pidos e possuem uma grande quantidade de mem\u00f3ria, podendo ser realmente \u00fateis para n\u00f3s se soubermos a linguagem necess\u00e1ria para dizer ao computador \"o que fazer agora\". Se conhecermos essa linguagem, podemos dizer ao computador para executar tarefas repetitivas por n\u00f3s. Curiosamente, o que os computadores fazem de melhor s\u00e3o as tarefas que os humanos acham entediantes e mentalmente estafantes.</p> <p>Por exemplo, observe os tr\u00eas primeiros par\u00e1grafos deste cap\u00edtulo e me diga a palavra que mais aparece, e quantas vezes aparece. Enquanto voc\u00ea \u00e9 capaz de ler e entender as palavras em alguns segundos, cont\u00e1-las \u00e9 complicado e entediante, pois esse n\u00e3o \u00e9 o tipo de problema para o qual o c\u00e9rebro humano foi projetado. Para o computador, \u00e9 o oposto: ler e compreender o texto a partir de um peda\u00e7o de papel ou da tela do pr\u00f3prio computador \u00e9 dif\u00edcil, mas contar as palavras e dizer qual a mais comum \u00e9 uma atividade simples para o computador.</p> <p>Este fato de que os computadores s\u00e3o bons em coisas que os humanos n\u00e3o s\u00e3o \u00e9 raz\u00e3o pela qual voc\u00ea precisa se tornar h\u00e1bil em falar \"linguagem de computador\". Uma vez que voc\u00ea aprenda essa linguagem, \u00e9 poss\u00edvel delegar tarefas mundanas para o seu parceiro (computador), deixando mais tempo para que voc\u00ea fa\u00e7a as coisas nas quais voc\u00ea \u00e9 bom. Voc\u00ea tr\u00e1s criatividade, intui\u00e7\u00e3o e inventividade para essa parceria.</p>"},{"location":"porqueaprenderaprogramar/#criatividade-e-motivacao","title":"Criatividade e motiva\u00e7\u00e3o","text":"<p>Apesar de estas p\u00e1ginas n\u00e3o serem voltados para programadores profissionais, a programa\u00e7\u00e3o profissional pode ser um trabalho financeira e pessoalmente muito recompensador. Construir programas \u00fateis, elegantes e inteligentes para que outros os usem \u00e9 uma atividade muito criativa. Normalmente o seu computador ou telefone celular possui v\u00e1rios programas de diferentes grupos de programadores, todos competindo pela sua aten\u00e7\u00e3o e interesse. Eles tentam ao m\u00e1ximo, durante o processo, atender \u00e0s suas necessidades e oferecer uma boa experi\u00eancia com o usu\u00e1rio. Em alguns casos, quando voc\u00ea escolhe um determinado programa, os programadores s\u00e3o diretamente recompensados pela sua escolha.</p> <p>Por enquanto, a nossa motiva\u00e7\u00e3o principal n\u00e3o \u00e9 fazer dinheiro ou agradar o usu\u00e1rio final, mas sim nos tornarmos mais produtivos quando estivermos manipulando dados e informa\u00e7\u00f5es que encontraremos em nossas vidas. No in\u00edcio, voc\u00ea ser\u00e1 tanto o programador quanto o usu\u00e1rio final dos programas. Conforme voc\u00ea for adquirindo habilidades como programador e programar se tornar mais criativo para voc\u00ea, seus pensamentos podem se voltar para o desenvolvimento de programas para os outros.</p>"},{"location":"porqueaprenderaprogramar/#arquitetura-do-hardware-do-computador","title":"Arquitetura do hardware do computador","text":"<p>Antes de come\u00e7armos a aprender a linguagem que iremos \"falar\" para dar ordens aos computadores ao desenvolvermos um programa, precisamos aprender um pouco sobre como os computadores s\u00e3o constru\u00eddos. Se voc\u00ea pudesse desmontar o seu computador ou telefone celular e olhar dentro dos componentes principais, veria as partes identificadas na figura a seguir.</p> <p></p> <p>Componentes da arquitetura de um computador</p> <p>As defini\u00e7\u00f5es em alto n\u00edvel dessas partes s\u00e3o:</p> <ul> <li>Unidade Central de Processamento (UCP) \u00e9 a parte do computador constru\u00edda para ser obcecada pela pergunta \"e agora, o que fa\u00e7o?\". De uma maneira bem simples, se o computador tem uma velocidade de 3GHz, isso significa que a UCP vai perguntar \"e agora, o que fa\u00e7o?\" tr\u00eas bilh\u00f5es de vezes por segundo. Voc\u00ea vai precisar aprender a falar r\u00e1pido para manter a UCP ocupada.</li> <li>A Mem\u00f3ria Principal \u00e9 usada para armazenar informa\u00e7\u00e3o que a UCP precisa rapidamente. A mem\u00f3ria principal \u00e9 quase t\u00e3o r\u00e1pida quanto a UCP. Mas a informa\u00e7\u00e3o armazenada na mem\u00f3ria principal se esvai quando o computador \u00e9 desligado.</li> <li>A Mem\u00f3ria Secund\u00e1ria tamb\u00e9m \u00e9 utilizada para armazenar informa\u00e7\u00e3o, mas \u00e9 muito mais lenta que a mem\u00f3ria principal. A vantagem da mem\u00f3ria secund\u00e1ria \u00e9 que ela pode armazenar informa\u00e7\u00e3o mesmo quando n\u00e3o h\u00e1 energia alimentado o computador. Exemplos de mem\u00f3ria secund\u00e1ria s\u00e3o os discos r\u00edgidos, discos de estado s\u00f3lido, cart\u00f5es de mem\u00f3ria e pen drives.</li> <li>Os Dispositivos de Entrada e Sa\u00edda s\u00e3o simplesmente nossas telas, teclados, mouses, microfones e caixas de som entre outros. Eles s\u00e3o a forma como interagimos com o computador.</li> <li>Nos dias atuais, a maior parte dos computadores tamb\u00e9m possuem Conex\u00e3o de Rede para poder recuperar informa\u00e7\u00e3o a partir de uma rede de computadores, como a Internet, por exemplo. Podemos pensar na rede como um lugar bem lento para armazenar e recuperar informa\u00e7\u00e3o e, de alguma forma, como uma mem\u00f3ria secund\u00e1ria n\u00e3o confi\u00e1vel.</li> </ul> <p>Mesmo que a maior parte dos detalhes desses componentes seja conhecida e esteja sob responsabilidade dos engenheiros que constroem os computadores, ajuda conhecer alguma terminologia para que possamos falar dessas diferentes partes enquanto escrevemos nossos programas.</p> <p>Como um programador, seu trabalho \u00e9 usar e orquestrar cada um desses recursos para que resolvam o problema que voc\u00ea precisa resolver e permitam a an\u00e1lise dos dados que voc\u00ea obt\u00e9m da solu\u00e7\u00e3o. Como um programador, na maior parte das vezes voc\u00ea vai estar \"falando\" com a UCP e dizendo o que ela deve fazer agora. Algumas vezes, voc\u00ea vai dizer \u00e0 UCP que use a mem\u00f3ria principal, a mem\u00f3ria secund\u00e1ria, a rede ou os dispositivos de entrada e sa\u00edda.</p> <p>Voc\u00ea precisa ser a pessoa que vai responder \u00e0 quest\u00e3o da UCP (\"e agora, o que fa\u00e7o?\"). Mas fica um pouco desconfort\u00e1vel  encolher para a escala microsc\u00f3pica e falar o que a UCP deve fazer a uma velocidade de tr\u00eas bilh\u00f5es de instru\u00e7\u00f5es por segundo. Assim, voc\u00ea deve escrever essas instru\u00e7\u00f5es de forma antecipada. N\u00f3s chamamos essas instru\u00e7\u00f5es armazenadas de programa, e o ato de escrever essas instru\u00e7\u00f5es de forma correta \u00e9 chamado de programar.</p>"},{"location":"porqueaprenderaprogramar/#vai-ser-assim-programar-em-c-ou-outra-linguagem-direto","title":"Vai ser assim? Programar em C ou outra linguagem, direto?","text":"<p>Quando vamos programar, dificilmente somos capazes de escrever os programas diretamente na linguagem de programa\u00e7\u00e3o escolhida, seja ela Python, Ruby, C, Java, C# ou qualquer outra que voc\u00ea pensar.</p> <p>Isso acontece (quase sempre) tanto com os novatos quanto com os experientes. Com o tempo, e com o dom\u00ednio que voc\u00ea passa a ter sobre a linguagem, problemas pequenos podem at\u00e9 ser resolvidos diretamente na linguagem de programa\u00e7\u00e3o, mas geralmente voc\u00ea vai sentir a necessidade e criar um \"rascunho da solu\u00e7\u00e3o\", de definir grandes passos ou etapas necess\u00e1rias para resolver o problema. Nesses casos aparecem os algoritmos.</p> <p>O termo algoritmo vem da matem\u00e1tica, mais precisamente da \u00e1lgebra, e foi cunhado a partir da forma latina (algoritmi) do nome do matem\u00e1tico persa Abu Ja'far Mu\u1e25ammad ibn M\u016bs\u0101 al-Khw\u0101rizm\u012b<sup>1</sup>, que viveu entre 780 a 850 dC no Califado Ab\u00e1ssida (750 a 1299dC). \u00c9 dele o sistema de numera\u00e7\u00e3o decimal posicional que adotamos hoje (unidade, dezena, centena, unidade de milhar...) e v\u00e1rias contribui\u00e7\u00f5es para a \u00e1lgebra, como por exemplo seis tipos de equa\u00e7\u00f5es alg\u00e9bricas e suas respectivas solu\u00e7\u00f5es (ou, na nomenclatura de hoje, os algoritmos). Ele n\u00e3o atuou apenas na matem\u00e1tica: h\u00e1 contribui\u00e7\u00f5es do al-Khwarizmi na astronomia, geografia e no calend\u00e1rio judeu por exemplo.</p> <p>Um algoritmo pode ser definido de v\u00e1rias formas:</p> <ul> <li>Sequ\u00eancia finita e ordenada de passos que resolvem um problema</li> <li>Uma sequ\u00eancia de passos que visa atingir um objetivo bem espec\u00edfico</li> <li>\u00c9 a descri\u00e7\u00e3o de uma sequ\u00eancia de passos que deve ser seguida para a realiza\u00e7\u00e3o de uma tarefa</li> <li>\u00c9 uma sequ\u00eancia finita de instru\u00e7\u00f5es ou opera\u00e7\u00f5es cuja execu\u00e7\u00e3o, em tempo finito, resolve um problema computacional, qualquer que seja sua inst\u00e2ncia</li> <li>S\u00e3o regras formais para a obten\u00e7\u00e3o de um resultado ou da solu\u00e7\u00e3o de um problema, englobando f\u00f3rmulas de express\u00f5es aritm\u00e9ticas</li> <li>\u00c9 um conjunto de passos que levam \u00e0 solu\u00e7\u00e3o de um determinado problema</li> <li>Um procedimento passo-a-passo para a solu\u00e7\u00e3o de um problema</li> <li>Uma sequ\u00eancia detalhada de a\u00e7\u00f5es a serem executadas para realizar alguma tarefa</li> </ul> <p>Alguns conceitos e ideias s\u00e3o comuns a todas essas defini\u00e7\u00f5es, entre elas o fato de que um algoritmo \u00e9 uma sequ\u00eancia de passos que, se executados, resolvem o problema.</p> <p>\u00c9 importante entender desde o in\u00edcio que um algoritmo n\u00e3o \u00e9 a solu\u00e7\u00e3o de um problema, pois problemas podem ter v\u00e1rias solu\u00e7\u00f5es. Os caminhos que levam a uma solu\u00e7\u00e3o s\u00e3o muitos, logo, n\u00e3o existe apenas um algoritmo para resolver um problema, e sim v\u00e1rios poss\u00edveis. Todos est\u00e3o corretos. Talvez alguns sejam mais r\u00e1pidos, outros consumam mais mem\u00f3ria, outros gastem mais energia, mas todos eles, se resolverem o problema, s\u00e3o algoritmos v\u00e1lidos (ou \"corretos\" se voc\u00ea quiser usar esse termo).</p> <pre><code>flowchart LR\n    A[Problema] --&gt; S1(Algoritmo 1) --&gt; X[Solu\u00e7\u00e3o]\n    A --&gt; S2(Algoritmo 2) --&gt; X\n    A --&gt; S3(Algoritmo 3) --&gt; X\n    A --&gt; S4(Algoritmo 4) --&gt; X\n\n    style S3 fill:#ADD8E6,stroke:#000,stroke-width:1px\n    style A fill:#ADD8E6,stroke:#000,stroke-width:1px\n    style X fill:#ADD8E6,stroke:#000,stroke-width:1px\n\n    linkStyle 4,5 stroke:#FF0000,stroke-width:3px</code></pre> <p>H\u00e1 diversos algoritmos que solucionam um problema, cada um com caracter\u00edsticas (tamanho, consumo de mem\u00f3ria, tempo de execu\u00e7\u00e3o...) diferentes.</p> <p>Assim, apesar de este site focar na produ\u00e7\u00e3o de programas utilizando C ou Python, \u00e9 fundamental entender que, na constru\u00e7\u00e3o das solu\u00e7\u00f5es, poderemos (e na maior parte das vezes iremos) passar por um est\u00e1gio intermedi\u00e1rio onde um algoritmo ser\u00e1 constru\u00eddo. H\u00e1 v\u00e1rios livros que discutem em detalhes o processo de constru\u00e7\u00e3o de algoritmos utilizando diversas t\u00e9cnicas, como descri\u00e7\u00e3o narrativa, fluxograma ou portugu\u00eas estruturado e eles podem ser consultados se o leitor assim desejar.</p>"},{"location":"porqueaprenderaprogramar/#entendendo-a-programacao","title":"Entendendo a programa\u00e7\u00e3o","text":"<p>No resto deste site n\u00f3s vamos tentar te transformar em uma pessoa com habilidades na arte de programar. No final, voc\u00ea vai ser um programador \u2014 talvez n\u00e3o um programador profissional, mas pelo menos voc\u00ea ter\u00e1 as habilidade para olhar para um problema de an\u00e1lise de dados ou informa\u00e7\u00f5es e desenvolver um programa que o solucione.</p> <p>De certa forma, voc\u00ea precisa de duas habilidades para ser um programador:</p> <ul> <li>Primeiro, voc\u00ea precisa conhecer a linguagem de programa\u00e7\u00e3o (no nosso caso, C ou Python) \u2014 voc\u00ea precisa conhecer o vocabul\u00e1rio e a gram\u00e1tica. Voc\u00ea precisa ser capaz de soletrar as palavras nessa nova linguagem de forma correta e precisa saber como construir senten\u00e7as \"bem formadas\" nessa nova linguagem.</li> <li>Em segundo lugar, voc\u00ea precisa \"contar uma hist\u00f3ria\". Ao escrever uma hist\u00f3ria, voc\u00ea combina palavras e senten\u00e7as para apresentar uma ideia ao leitor. H\u00e1 uma mistura entre habilidade e arte para construir hist\u00f3rias, e melhorar as habilidades de escrever hist\u00f3rias passa por escrever v\u00e1rias hist\u00f3rias e obter avalia\u00e7\u00e3o dessas hist\u00f3rias. Em programa\u00e7\u00e3o, nosso programa \u00e9 a \"hist\u00f3ria\", e o problema que estamos tentando resolver \u00e9 a \"ideia\".</li> </ul> <p>Uma vez que voc\u00ea aprender uma linguagem de programa\u00e7\u00e3o, voc\u00ea achar\u00e1 muito mais f\u00e1cil aprender uma segunda linguagem de programa\u00e7\u00e3o, como TypeScript, Java ou C#. A nova linguagem de programa\u00e7\u00e3o vai ter vocabul\u00e1rio e gram\u00e1tica diferentes, mas as habilidade de resolver problemas ser\u00e3o as mesmas em qualquer linguagem de programa\u00e7\u00e3o.</p> <p>Acreditamos que voc\u00ea aprender\u00e1 o vocabul\u00e1rio e as senten\u00e7as de C ou de Python rapidamente. Levar\u00e1 mais tempo para que voc\u00ea seja capaz de escrever um programa coerente que resolva um problema novo.  Ensinamos a programar mais ou menos da mesma forma que ensinamos a escrever. Come\u00e7amos lendo e explicando programas, depois escrevemos programas simples, e vamos aumentando a complexidade dos programas ao longo do tempo. Em algum momento voc\u00ea \"pega o jeito\" e come\u00e7a a identificar padr\u00f5es sozinho e consegue ver de forma mais natural como encarar um problema e escrever um programa que o resolva. E quando voc\u00ea chegar a esse ponto, programar vai se tornar uma atividade agrad\u00e1vel e criativa.</p> <p>Vamos come\u00e7ar com o vocabul\u00e1rio e a estrutura de programas em C ou Python. Seja paciente, pois esses exemplos simples se parecer\u00e3o com os textos que lhe foram apresentados quando voc\u00ea come\u00e7ou a ler pela primeira vez: bobinhos, mas fundamentais para entender textos mais complexos.</p> <p>Mas antes, vamos come\u00e7ar falando de algoritmos.</p> <p>Veja bem, preste aten\u00e7\u00e3o!</p> <p>Aprender a programar \u00e9 igual a aprender a nadar.</p> <p>Por mais que voc\u00ea sente ao lado da piscina e fique vendo o professor nadar, mover os bra\u00e7os, virar a cabe\u00e7a para respirar e mover as pernas de forma coordenada, voc\u00ea s\u00f3 vai aprender a nadar se voc\u00ea fizer esses movimentos. Enquanto voc\u00ea n\u00e3o pular na \u00e1gua, engolir um pouco de \u00e1gua, bater as pernas e bra\u00e7os totalmente sem coordena\u00e7\u00e3o, voc\u00ea n\u00e3o vai aprender a nadar. N\u00e3o adianta pedir para o professor pular de novo na \u00e1gua, bater os bra\u00e7os, bater as pernas e voc\u00ea ficar apenas olhando de novo, e de novo, e de novo...</p> <p>Ler este material e acompanhar as aulas \u00e9 sentar ao lado da piscina e ver o professor nadar. Se voc\u00ea n\u00e3o tentar escrever os programas, n\u00e3o fizer os exerc\u00edcios, n\u00e3o encarar erros, n\u00e3o tentar resolver os erros, voc\u00ea n\u00e3o vai aprender a programar \u2014 sinto muito.</p> <ol> <li> <p>Voc\u00ea pode ver a biografia do al-Khwarizmi em aqui ou aqui \u21a9</p> </li> </ol>"},{"location":"tiposdeprocessamento/","title":"Tipos de processamento","text":"<p>H\u00e1 alguns padr\u00f5es conceituais de baixo n\u00edvel que usamos para construir programas. Esses construtores n\u00e3o aparecem apenas nos programas em C ou Python - eles s\u00e3o parte de qualquer linguagem de programa\u00e7\u00e3o, de alto ou baixo n\u00edvel.</p> <ul> <li>entrada: obt\u00e9m dados do mundo exterior. Isso pode significar ler o conte\u00fado de um arquivo, ou mesmo de um sensor como microfone ou GPS. Nos primeiros programas que faremos, a entrada ser\u00e1 obtida a partir do usu\u00e1rio digitando dados em um teclado;</li> <li>sa\u00edda: mostra o resultado de um programa na tela, em um arquivo ou mesmo em um dispositivo como alto-falantes ou impressoras;</li> <li>estruturas sequenciais: executa senten\u00e7as, uma ap\u00f3s a outra, na ordem em que s\u00e3o encontradas no programa;</li> <li>estruturas condicionais: verifica se determinadas condi\u00e7\u00f5es s\u00e3o satisfeitas e ent\u00e3o executa ou deixa de executar um conjunto de senten\u00e7as;</li> <li>estruturas de repeti\u00e7\u00e3o: executa um conjunto de senten\u00e7as de forma repetitiva, geralmente com alguma varia\u00e7\u00e3o;</li> <li>reuso: escrever um conjunto de instru\u00e7\u00f5es, atribuir-lhe um nome, e ent\u00e3o reutilizar esse conjunto no programa ou em outros programas.</li> </ul> <p>Parece ser muito simples para ser verdade, e \u00e9. \u00c9 mais ou menos como dizer que para andar basta \"colocar um p\u00e9 na frente do outro\". A \"arte\" de escrever programas \u00e9 compor e misturar esses elementos b\u00e1sicos v\u00e1rias vezes de forma a produzir algo \u00fatil para o usu\u00e1rio.</p>"},{"location":"tiposdeprocessamento/#entrada-e-saida","title":"Entrada e sa\u00edda","text":"<p>A entrada e sa\u00edda s\u00e3o como as portas de comunica\u00e7\u00e3o entre o computador e o mundo exterior. Imagine que voc\u00ea est\u00e1 em uma sala fechada e precisa se comunicar com algu\u00e9m do lado de fora. Voc\u00ea precisaria de uma forma de receber mensagens (entrada) e enviar suas respostas (sa\u00edda).</p> <p>Na entrada, o computador recebe informa\u00e7\u00f5es que ser\u00e3o processadas. Por exemplo, quando voc\u00ea usa uma calculadora, os n\u00fameros que voc\u00ea digita s\u00e3o a entrada. O computador precisa dessas informa\u00e7\u00f5es para realizar os c\u00e1lculos. A sa\u00edda \u00e9 o resultado que o computador nos mostra depois de processar as informa\u00e7\u00f5es. Na calculadora, seria o resultado da opera\u00e7\u00e3o matem\u00e1tica exibido na tela. Sem sa\u00edda, n\u00e3o ter\u00edamos como saber o que o computador fez com nossas informa\u00e7\u00f5es.</p> <p>Por exemplo:</p> <ul> <li>Se quisermos criar um sistema para uma loja que calcule o troco de uma venda, precisar\u00edamos do valor da compra e o valor pago pelo cliente (entrada) para produzirmos o valor do troco que deve ser devolvido (sa\u00edda);</li> <li>Imagine que voc\u00ea est\u00e1 jogando um videogame. A entrada seria o que voc\u00ea faz no controle: apertar bot\u00f5es, mover o joystick. O jogo recebe esses comandos e os usa para fazer as coisas acontecerem na tela. A sa\u00edda \u00e9 tudo o que voc\u00ea v\u00ea e ouve: os gr\u00e1ficos, os sons, a m\u00fasica. \u00c9 como o jogo te mostra o que est\u00e1 acontecendo. Ou;</li> <li>Se um programa pede sua idade e voc\u00ea digita \"15\", essa informa\u00e7\u00e3o \u00e9 uma entrada. Se o programa responde \"Voc\u00ea ter\u00e1 20 anos em 5 anos\", essa \u00e9 a sa\u00edda</li> </ul>"},{"location":"tiposdeprocessamento/#processamento-sequencial","title":"Processamento sequencial","text":"<p>Aqui, as instru\u00e7\u00f5es s\u00e3o executadas, umas depois das outras, na exata ordem em que aparecem no algoritmo; ou seja, a ordem na qual as instru\u00e7\u00f5es est\u00e3o escritas pode influenciar no resultado final. Lembra da ordem das viradas (esquerda, direita) no guia de navega\u00e7\u00e3o?</p> <p>Pense em uma receita de bolo. Cada passo precisa ser seguido na ordem correta para que o bolo d\u00ea certo. Primeiro, voc\u00ea mistura os ingredientes secos, depois os molhados, e assim por diante. Se voc\u00ea inverter a ordem, o bolo pode n\u00e3o ficar bom.</p> <p>Nos programas de computador, o processamento sequencial funciona da mesma forma. As instru\u00e7\u00f5es s\u00e3o executadas linha por linha, de cima para baixo. Se voc\u00ea mudar a ordem das linhas, o resultado do programa pode ser diferente.</p>"},{"location":"tiposdeprocessamento/#processamento-condicional","title":"Processamento condicional","text":"<p>Nele, o conjunto de instru\u00e7\u00f5es que vai ser executado depende do resultado da avalia\u00e7\u00e3o de uma express\u00e3o l\u00f3gica (um teste); uma express\u00e3o que avalie como verdadeira, vai disparar a execu\u00e7\u00e3o de um determinado conjunto de instru\u00e7\u00f5es e, opcionalmente, outro conjunto pode ser executado se a express\u00e3o avaliar como falsa.</p> <p>O processamento condicional \u00e9 como tomar decis\u00f5es no dia a dia. Voc\u00ea analisa uma situa\u00e7\u00e3o e, com base nela, decide o que fazer. Por exemplo: \"Se estiver chovendo, vou levar um guarda-chuva; caso contr\u00e1rio, deixo ele em casa.\".</p> <p>Ou imagine que voc\u00ea est\u00e1 jogando um jogo e precisa passar por uma porta. A porta s\u00f3 abre se voc\u00ea tiver a chave certa. A chave \u00e9 como uma condi\u00e7\u00e3o: se voc\u00ea tiver a chave, a porta abre (verdadeiro); se n\u00e3o tiver, a porta permanece fechada (falso).</p> <p>Na vida real, tomamos decis\u00f5es o tempo todo. Se voc\u00ea est\u00e1 com fome, come algo; se n\u00e3o est\u00e1, continua suas atividades. Se seu celular est\u00e1 com pouca bateria, voc\u00ea o carrega; se n\u00e3o, continua usando normalmente. Esse tipo de processamento \u00e9 fundamental para criar programas que se adaptam a diferentes situa\u00e7\u00f5es.</p>"},{"location":"tiposdeprocessamento/#processamento-com-repeticao","title":"Processamento com repeti\u00e7\u00e3o","text":"<p>Algum conjunto de instru\u00e7\u00f5es que precise ser executado mais de uma vez pode ser organizado como um processamento com repeti\u00e7\u00e3o. O n\u00famero de vezes que o conjunto de instru\u00e7\u00f5es vai ser executado pode ser definido a priori (repeti\u00e7\u00e3o determinada), ou a parada pode ser determinada pela avalia\u00e7\u00e3o de uma express\u00e3o l\u00f3gica (repeti\u00e7\u00e3o indeterminada).</p>"},{"location":"tiposdeprocessamento/#determinada","title":"Determinada","text":"<p>A repeti\u00e7\u00e3o determinada ocorre quando sabemos de antem\u00e3o quantas vezes um conjunto de instru\u00e7\u00f5es ser\u00e1 executado. Imagine que voc\u00ea precisa enviar a mesma mensagem para 5 amigos diferentes. Voc\u00ea sabe desde o in\u00edcio que a a\u00e7\u00e3o de \"enviar mensagem\" ser\u00e1 repetida 5 vezes, uma para cada amigo. Ou se voc\u00ea est\u00e1 fazendo 20 flex\u00f5es, sabe que o movimento de subir e descer ser\u00e1 repetido exatamente 20 vezes.</p> <p>Outro exemplo pr\u00e1tico seria um programa que imprime os n\u00fameros de 1 a 5 na tela. Como sabemos que ele vai repetir esse processo exatamente cinco vezes, usamos uma repeti\u00e7\u00e3o determinada.</p>"},{"location":"tiposdeprocessamento/#indeterminada","title":"Indeterminada","text":"<p>Na repeti\u00e7\u00e3o indeterminada, n\u00e3o sabemos exatamente quantas vezes as instru\u00e7\u00f5es ser\u00e3o executadas, pois a decis\u00e3o se as instru\u00e7\u00f5es continuam a ser repetidas ou n\u00e3o de uma condi\u00e7\u00e3o que pode mudar durante a execu\u00e7\u00e3o das instru\u00e7\u00f5es.</p> <p>Imagine um jogo onde um personagem continua andando enquanto n\u00e3o encontrar um obst\u00e1culo. Como n\u00e3o sabemos quantos passos ele dar\u00e1 antes de parar, o n\u00famero de repeti\u00e7\u00f5es \u00e9 desconhecido. O programa deve verificar constantemente se a condi\u00e7\u00e3o de parada foi atingida. Ou quando voc\u00ea est\u00e1 jogando um videogame, voc\u00ea continua jogando at\u00e9 perder todas as suas vidas. Voc\u00ea n\u00e3o sabe exatamente quantas rodadas vai jogar - podem ser 3, podem ser 30, dependendo do seu desempenho.</p> <p>Na vida real, muitas atividades seguem esse padr\u00e3o: estudar at\u00e9 entender o conte\u00fado, procurar as chaves at\u00e9 encontr\u00e1-las, tentar resolver um quebra-cabe\u00e7a at\u00e9 conseguir, lavar os pratos at\u00e9 todos estarem lavados.</p>"},{"location":"tiposdeprocessamento/#funcoes-e-procedimentos","title":"Fun\u00e7\u00f5es e procedimentos","text":"<p>Fun\u00e7\u00f5es e procedimentos s\u00e3o como pequenas \"m\u00e1quinas\" especializadas que realizam tarefas espec\u00edficas. Eles nos permitem escrever uma sequ\u00eancia de instru\u00e7\u00f5es uma vez e reutiliz\u00e1-la sempre que necess\u00e1rio, sem precisar reescrever tudo novamente.</p> <p>Imagine que voc\u00ea tem uma receita de molho de tomate que usa em v\u00e1rios pratos diferentes: lasanha, espaguete, pizza. Em vez de escrever a receita completa do molho cada vez que faz um desses pratos, voc\u00ea simplesmente diz \"prepare o molho de tomate\" e segue a receita que j\u00e1 conhece.</p> <p>Na escola, voc\u00ea aprende f\u00f3rmulas matem\u00e1ticas que pode aplicar em diferentes problemas. A f\u00f3rmula para calcular a \u00e1rea de um c\u00edrculo (\\(\\pi r^2\\)) \u00e9 sempre a mesma, independentemente do tamanho do c\u00edrculo. Voc\u00ea n\u00e3o precisa redescobrir a f\u00f3rmula toda vez - apenas a aplica quando necess\u00e1rio.</p> <p>As fun\u00e7\u00f5es geralmente retornam um valor ap\u00f3s realizar sua tarefa. Por exemplo, uma fun\u00e7\u00e3o que calcula a \u00e1rea de um c\u00edrculo recebe o raio como entrada e retorna a \u00e1rea calculada. Os procedimentos, por outro lado, realizam uma tarefa sem necessariamente retornar um valor, como um procedimento para imprimir um documento.</p> <p>Usar fun\u00e7\u00f5es e procedimentos torna o trabalho mais organizado e eficiente, permitindo que tarefas complexas sejam divididas em partes menores e mais gerenci\u00e1veis. Al\u00e9m disso, se precisarmos modificar como uma tarefa \u00e9 realizada, s\u00f3 precisamos alterar a fun\u00e7\u00e3o correspondente, e todas as partes do sistema que a utilizam ser\u00e3o automaticamente atualizadas.</p>"},{"location":"variaveis/","title":"Vari\u00e1veis","text":"<p>Vari\u00e1veis s\u00e3o a base para qualquer processamento computacional, funcionando como os cont\u00eaineres que armazenam os dados com os quais o programa trabalha</p> <p>Durante a execu\u00e7\u00e3o de qualquer tipo de programa, os computadores est\u00e3o manipulando informa\u00e7\u00f5es parciais ou finais. Para que essas informa\u00e7\u00f5es fiquem dispon\u00edveis e possam ser processadas ou mesmo apresentadas, o computador precisa guard\u00e1-las em sua mem\u00f3ria. Para acessar individualmente cada uma destas informa\u00e7\u00f5es, a princ\u00edpio, seria necess\u00e1rio saber o que est\u00e1 guardado l\u00e1 (um n\u00famero? uma palavra?) e a posi\u00e7\u00e3o inicial deste conjunto de bytes na mem\u00f3ria. Isso seria muito complicado para o programador, al\u00e9m de engessar demais o programa (as informa\u00e7\u00f5es teriam que estar, sempre, nos mesmos lugares da mem\u00f3ria).</p> <p>Para contornar esta situa\u00e7\u00e3o criou-se o conceito de vari\u00e1vel, que \u00e9 uma entidade destinada a guardar uma informa\u00e7\u00e3o.</p> <p>Podemos pensar nas vari\u00e1veis como caixas etiquetadas em uma sala. Cada caixa (vari\u00e1vel) tem uma etiqueta (nome) que nos permite encontr\u00e1-la facilmente, um tipo espec\u00edfico de conte\u00fado que pode armazenar (tipo de dado), e o conte\u00fado em si (valor). Assim como n\u00e3o colocar\u00edamos l\u00edquidos em uma caixa de papel\u00e3o, cada vari\u00e1vel s\u00f3 pode armazenar dados compat\u00edveis com seu tipo.</p> <p>Os nome de uma vari\u00e1vel \u00e9 um identificador simb\u00f3lico que permite ao programador referenciar a informa\u00e7\u00e3o armazenada sem precisar lidar diretamente com endere\u00e7os de mem\u00f3ria.</p>"},{"location":"variaveis/#atributos-ciclo-de-vida-e-escopo","title":"Atributos, ciclo de vida e escopo","text":"<p>Uma vari\u00e1vel possui tr\u00eas atributos fundamentais: um nome, um tipo de dado associado \u00e0 mesma e a informa\u00e7\u00e3o por ela guardada.</p> <p>O ciclo de vida de uma vari\u00e1vel geralmente envolve quatro etapas principais: declara\u00e7\u00e3o, onde informamos ao computador que precisamos de um espa\u00e7o na mem\u00f3ria; inicializa\u00e7\u00e3o, quando atribu\u00edmos um valor inicial \u00e0 vari\u00e1vel; utiliza\u00e7\u00e3o, quando lemos ou modificamos seu valor durante a execu\u00e7\u00e3o do programa; e, em algumas linguagens, destrui\u00e7\u00e3o, quando a mem\u00f3ria ocupada pela vari\u00e1vel \u00e9 liberada para reutiliza\u00e7\u00e3o. Entender este ciclo \u00e9 fundamental para usar vari\u00e1veis de forma eficiente e evitar erros comuns.</p> <p>Al\u00e9m dos atributos b\u00e1sicos, as vari\u00e1veis tamb\u00e9m possuem um escopo, que determina onde no programa elas podem ser acessadas. Vari\u00e1veis locais s\u00e3o vis\u00edveis apenas dentro do trecho de c\u00f3digo (fun\u00e7\u00e3o ou bloco) onde foram declaradas, enquanto vari\u00e1veis globais podem ser acessadas em todo o programa. O gerenciamento adequado do escopo \u00e9 crucial para evitar conflitos de nomes e garantir que os dados sejam acess\u00edveis apenas onde necess\u00e1rio.</p>"},{"location":"variaveis/#tipagem-estatica-ou-dinamica","title":"Tipagem est\u00e1tica ou din\u00e2mica","text":"<p>Algumas linguagens de programa\u00e7\u00e3o permitem que se defina uma vari\u00e1vel sem indicar explicitamente o seu tipo; outras linguagens, por sua vez, obrigam que o programador indique explicitamente o tipo de dados que vai ser guardado na vari\u00e1vel.</p> <p>As linguagens que exigem declara\u00e7\u00e3o expl\u00edcita de tipos s\u00e3o conhecidas como linguagens de tipagem est\u00e1tica. Nelas, o programador deve informar previamente qual tipo de dado cada vari\u00e1vel ir\u00e1 armazenar, como n\u00fameros inteiros, n\u00fameros decimais, texto ou valores l\u00f3gicos. Exemplos dessas linguagens incluem C, C++, Java e TypeScript. Esta abordagem oferece v\u00e1rias vantagens significativas. Primeiramente, ela permite que o compilador detecte erros de tipo durante a compila\u00e7\u00e3o, antes mesmo do programa ser executado. Por exemplo, se um programador tentar armazenar texto em uma vari\u00e1vel declarada como n\u00famero, o compilador identificar\u00e1 esse erro imediatamente. Isso resulta em programas mais robustos e confi\u00e1veis, pois muitos erros s\u00e3o capturados precocemente no processo de desenvolvimento.</p> <p>Al\u00e9m disso, a tipagem est\u00e1tica frequentemente leva a um melhor desempenho do programa. Como o compilador conhece antecipadamente os tipos de todas as vari\u00e1veis, ele pode otimizar o c\u00f3digo gerado, alocando a quantidade exata de mem\u00f3ria necess\u00e1ria e escolhendo as instru\u00e7\u00f5es mais eficientes para manipular cada tipo de dado. Isso \u00e9 particularmente importante em sistemas com recursos limitados ou aplica\u00e7\u00f5es que exigem alta performance.</p> <p>Por outro lado, as linguagens de tipagem din\u00e2mica, como Python, JavaScript, Ruby e PHP, n\u00e3o exigem que o programador declare explicitamente os tipos das vari\u00e1veis. Nestas linguagens, o tipo \u00e9 inferido automaticamente com base no valor atribu\u00eddo \u00e0 vari\u00e1vel e pode mudar durante a execu\u00e7\u00e3o do programa. Esta flexibilidade torna a programa\u00e7\u00e3o mais \u00e1gil e intuitiva para muitos desenvolvedores, especialmente iniciantes. O c\u00f3digo tende a ser mais conciso, pois elimina a necessidade de declara\u00e7\u00f5es de tipo, e o desenvolvimento pode ser mais r\u00e1pido, j\u00e1 que h\u00e1 menos detalhes t\u00e9cnicos para se preocupar inicialmente.</p> <p>A tipagem din\u00e2mica tamb\u00e9m facilita certos padr\u00f5es de programa\u00e7\u00e3o e manipula\u00e7\u00e3o de dados heterog\u00eaneos. Por exemplo, uma lista em Python pode conter elementos de diferentes tipos sem problemas, enquanto em linguagens de tipagem est\u00e1tica isso geralmente requer solu\u00e7\u00f5es mais complexas. Esta flexibilidade \u00e9 particularmente \u00fatil em cen\u00e1rios como processamento de dados, prototipagem r\u00e1pida e desenvolvimento web.</p> <p>No entanto, esta liberdade vem com um custo. Erros de tipo em linguagens din\u00e2micas s\u00f3 s\u00e3o descobertos durante a execu\u00e7\u00e3o do programa, potencialmente resultando em falhas inesperadas em produ\u00e7\u00e3o. Al\u00e9m disso, sem declara\u00e7\u00f5es expl\u00edcitas de tipo, o c\u00f3digo pode se tornar menos autodocumentado, dificultando a compreens\u00e3o de qual tipo de dado uma fun\u00e7\u00e3o espera receber ou retornar.</p> <p>Algumas linguagens modernas, como Kotlin, Swift e Scala, adotam uma abordagem h\u00edbrida conhecida como \"infer\u00eancia de tipo\". Nestas linguagens, o programador pode optar por declarar explicitamente os tipos ou deixar que o compilador os infira automaticamente. Isso oferece um equil\u00edbrio entre a seguran\u00e7a da tipagem est\u00e1tica e a conveni\u00eancia da tipagem din\u00e2mica, permitindo c\u00f3digo conciso sem sacrificar a verifica\u00e7\u00e3o de tipos em tempo de compila\u00e7\u00e3o.</p> <p>Para ilustrar estes conceitos na pr\u00e1tica, vejamos exemplos simples em duas linguagens populares:</p> PythonC variaveis.py<pre><code># Em Python (tipagem din\u00e2mica)\ncontador = 0  # Declara\u00e7\u00e3o e inicializa\u00e7\u00e3o em uma \u00fanica etapa\ncontador = contador + 1  # Utiliza\u00e7\u00e3o - incrementando o valor\nmensagem = \"O valor \u00e9: \" + str(contador)  # Utiliza\u00e7\u00e3o em outra vari\u00e1vel\ndel contador  # Destrui\u00e7\u00e3o da vari\u00e1vel\n</code></pre> variaveis.c<pre><code>// Em C (tipagem est\u00e1tica)\nint contador = 0;  // Declara\u00e7\u00e3o com tipo expl\u00edcito e inicializa\u00e7\u00e3o\ncontador = contador + 1;  // Utiliza\u00e7\u00e3o - incrementando o valor\nprintf(\"O valor e: %d\\n\", contador)  // Utiliza\u00e7\u00e3o\n</code></pre> <p>A escolha entre tipagem est\u00e1tica e din\u00e2mica frequentemente depende do contexto do projeto, das prefer\u00eancias da equipe e dos requisitos espec\u00edficos da aplica\u00e7\u00e3o. Projetos que priorizam robustez, desempenho e manuten\u00e7\u00e3o a longo prazo geralmente se beneficiam da tipagem est\u00e1tica, enquanto aqueles que valorizam agilidade, flexibilidade e prototipagem r\u00e1pida podem preferir a tipagem din\u00e2mica.</p> <p>Ao utilizar vari\u00e1veis, o mesmo c\u00f3digo pode ser reutilizado para diferentes entradas, tornando os programas mais vers\u00e1teis e reutiliz\u00e1veis: ao inv\u00e9s de criar um algoritmo que funcione apenas com valores espec\u00edficos, podemos usar vari\u00e1veis para criar solu\u00e7\u00f5es gen\u00e9ricas que funcionam com qualquer conjunto de dados v\u00e1lido. Por exemplo, um algoritmo para calcular a \u00e1rea de um ret\u00e2ngulo pode usar vari\u00e1veis para comprimento e largura, permitindo que o mesmo algoritmo calcule a \u00e1rea de qualquer ret\u00e2ngulo, n\u00e3o apenas um com dimens\u00f5es predefinidas. Sem vari\u00e1veis, n\u00e3o ter\u00edamos como capturar e utilizar dados fornecidos pelo usu\u00e1rio durante a execu\u00e7\u00e3o do programa.</p> <p>As vari\u00e1veis tamb\u00e9m facilitam a manuten\u00e7\u00e3o e atualiza\u00e7\u00e3o dos algoritmos. Se precisarmos alterar um valor usado em v\u00e1rias partes do algoritmo, podemos simplesmente modificar o valor da vari\u00e1vel correspondente em um \u00fanico lugar, em vez de procurar e alterar cada ocorr\u00eancia desse valor no c\u00f3digo.</p>"},{"location":"c/biblioteca_c/","title":"Trechos de c\u00f3digo relevantes em C e cheat sheets","text":""},{"location":"c/biblioteca_c/#leitura-de-inteiros-reais-e-cadeias-de-caractere-sem-o-uso-de-scanf","title":"Leitura de inteiros, reais e cadeias de caractere sem o uso de scanf()","text":"entrada_saida.h<pre><code>#ifndef ENTRADA_SAIDA_H\n#define ENTRADA_SAIDA_H\n#include &lt;stdio.h&gt;\n\nint    lerInt(const char *prompt);\nlong   lerLong(const char *prompt);\ndouble lerDouble(const char *prompt);\nchar * lerLinha(const char *prompt);\nchar * lerLinhaArquivo(FILE *arquivo);\n\n#endif //ENTRADA_SAIDA_H\n</code></pre> entrada_saida.c<pre><code>#include \"entrada_saida.h\"\n\n#include &lt;limits.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\n/**\n * @brief L\u00ea um n\u00famero inteiro da entrada padr\u00e3o.\n *\n * Esta fun\u00e7\u00e3o solicita ao usu\u00e1rio a entrada de um valor inteiro atrav\u00e9s\n * do prompt fornecido. A fun\u00e7\u00e3o continuar\u00e1 solicitando a entrada at\u00e9 que\n * um valor inteiro v\u00e1lido seja fornecido, dentro dos limites do tipo int.\n *\n * @param prompt Mensagem exibida ao usu\u00e1rio solicitando a entrada (pode\n *        ser NULL)\n * @return O valor inteiro lido da entrada padr\u00e3o\n */\nint lerInt(const char *prompt)\n{\n  char *linha = NULL;\n  char *p     = NULL;\n  long  valor = 0L;\n\n  while (1)\n  {\n    if (prompt != NULL)\n    {\n      printf(\"%s\", prompt);\n    }\n    linha = lerLinha(NULL);\n    valor = strtol(linha, &amp;p, 10);\n    if ((p == linha) || (errno == ERANGE) || (*p &amp;&amp; *p != '\\n'))\n    {\n      free(linha);\n      continue;\n    }\n    if (valor &lt; INT_MIN || valor &gt; INT_MAX)\n    {\n      free(linha);\n      continue;\n    }\n    break;\n  }\n  free(linha);\n  return (int) valor;\n}\n\n/**\n * @brief L\u00ea um n\u00famero long da entrada padr\u00e3o.\n *\n * Esta fun\u00e7\u00e3o solicita ao usu\u00e1rio a entrada de um valor do tipo long\n * atrav\u00e9s do prompt fornecido. A fun\u00e7\u00e3o continuar\u00e1 solicitando a\n * entrada at\u00e9 que um valor long v\u00e1lido seja fornecido.\n *\n * @param prompt Mensagem exibida ao usu\u00e1rio solicitando a entrada (pode\n *        ser NULL)\n * @return O valor long lido da entrada padr\u00e3o\n */\nlong lerLong(const char *prompt)\n{\n  char *linha = NULL;\n  char *p     = NULL;\n  long  valor = 0L;\n\n  while (1)\n  {\n    if (prompt != NULL)\n    {\n      printf(\"%s\", prompt);\n    }\n    linha = lerLinha(NULL);\n    valor = strtol(linha, &amp;p, 10);\n    if ((p == linha) || (errno == ERANGE) || (*p &amp;&amp; *p != '\\n'))\n    {\n      free(linha);\n      continue;\n    }\n    break;\n  }\n  free(linha);\n  return valor;\n}\n\n/**\n * @brief L\u00ea um n\u00famero de ponto flutuante (double) da entrada padr\u00e3o.\n *\n * Esta fun\u00e7\u00e3o solicita ao usu\u00e1rio a entrada de um valor double atrav\u00e9s\n * do prompt fornecido. A fun\u00e7\u00e3o continuar\u00e1 solicitando a entrada at\u00e9\n * que um valor double v\u00e1lido seja fornecido.\n *\n * @param prompt Mensagem exibida ao usu\u00e1rio solicitando a entrada (pode\n *        ser NULL)\n * @return O valor double lido da entrada padr\u00e3o\n */\ndouble lerDouble(const char *prompt)\n{\n  char * linha = NULL;\n  char * p     = NULL;\n  double valor;\n\n  while (1)\n  {\n    if (prompt != NULL)\n    {\n      printf(\"%s\", prompt);\n    }\n    linha = lerLinha(NULL);\n    valor = strtod(linha, &amp;p);\n    if ((p == linha) || (errno == ERANGE) || (*p &amp;&amp; *p != '\\n'))\n    {\n      free(linha);\n      continue;\n    }\n    break;\n  }\n  free(linha);\n  return valor;\n}\n\n/**\n * @brief L\u00ea uma linha de texto da entrada padr\u00e3o.\n *\n * Esta fun\u00e7\u00e3o l\u00ea uma linha completa de texto da entrada padr\u00e3o\n * (stdin), at\u00e9 encontrar um caractere de nova linha ou EOF. A mem\u00f3ria\n * para armazenar a linha \u00e9 alocada dinamicamente.\n *\n * @param prompt Mensagem exibida ao usu\u00e1rio solicitando a entrada (pode\n *        ser NULL)\n * @return Ponteiro para a string lida (deve ser liberada pelo chamador\n *         usando free())\n */\nchar *lerLinha(const char *prompt)\n{\n  char *line = NULL;\n  if (prompt != NULL)\n  {\n    printf(\"%s\", prompt);\n  }\n  line = lerLinhaArquivo(stdin);\n  return line;\n}\n\n/**\n * @brief L\u00ea uma linha de texto de um arquivo especificado.\n *\n * Esta fun\u00e7\u00e3o l\u00ea uma linha completa de texto do arquivo especificado,\n * at\u00e9 encontrar um caractere de nova linha ou EOF. A mem\u00f3ria para\n * armazenar a linha \u00e9 alocada dinamicamente. A fun\u00e7\u00e3o gerencia\n * automaticamente o redimensionamento do buffer se necess\u00e1rio.\n *\n * @param arquivo Ponteiro para o arquivo de onde a linha ser\u00e1 lida\n * @return Ponteiro para a string lida (deve ser liberada pelo chamador\n *         usando free()), ou NULL se EOF for encontrado sem ler nenhum\n *         caractere\n */\nchar *lerLinhaArquivo(FILE *arquivo)\n{\n  char *       line  = NULL;\n  char *       nline = NULL;\n  unsigned int n     = 0;\n  unsigned int size  = 4096;\n  int          ch    = 0;\n\n  line = (char *) malloc(size + 1);\n  if (line == NULL)\n  {\n    printf(\"Sem memoria\\n\");\n    exit(1);\n  }\n  while ((ch = getc(arquivo)) != '\\n' &amp;&amp; ch != EOF)\n  {\n    if (n == size)\n    {\n      size += size;\n      nline = (char *) malloc(size + 1);\n      if (nline == NULL)\n      {\n        free(line);\n        printf(\"Sem memoria\\n\");\n        exit(1);\n      }\n      strncpy(nline, line, n);\n      free(line);\n      line = nline;\n    }\n    line[n++] = (char) ch;\n  }\n  if (n == 0 &amp;&amp; ch == EOF)\n  {\n    free(line);\n    return (NULL);\n  }\n  line[n] = '\\0';\n  nline   = (char *) malloc(n + 1);\n  if (nline == NULL)\n  {\n    free(line);\n    printf(\"Sem memoria\");\n    exit(1);\n  }\n  strcpy(nline, line);\n  free(line);\n  return nline;\n}\n</code></pre>"},{"location":"c/biblioteca_c/#removendo-caracteres-em-branco-no-inicio-e-no-final-de-linhas-de-texto","title":"Removendo caracteres em branco no \u00ednicio e no final de linhas de texto","text":"limpa_string.h<pre><code>void trimString(char *);\n</code></pre> limpa_string.c<pre><code>#include &lt;ctype.h&gt;\n#include &lt;string.h&gt;\n\nvoid trimString(char *str) {\n    int start = 0, end = strlen(str) - 1;\n\n    // Remove espa\u00e7os no in\u00edcio\n    while (isspace((unsigned char)str[start]))\n        start++;\n\n    // Remove espa\u00e7os no final\n    while ((end &gt;= start) &amp;&amp; isspace((unsigned char)str[end]))\n        end--;\n\n    // Move os caracteres para o in\u00edcio\n    memmove(str, str + start, end - start + 1);\n    str[end - start + 1] = '\\0';\n}\n</code></pre>"},{"location":"c/biblioteca_c/#numeros-aleatorios","title":"N\u00fameros aleat\u00f3rios","text":"aleatorios.h<pre><code>#ifndef ALEATORIOS_H\n#define ALEATORIOS_H\n#include &lt;stdio.h&gt;\n\nvoid Randomize(void);\nint RandomInteger(int, int);\ndouble RandomReal(double, double);\n\n#endif //ALEATORIOS_H\n</code></pre> aleatorios.c<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;time.h&gt;\n\n/**\n * @brief Inicializa o gerador de n\u00fameros aleat\u00f3rios.\n *\n * Esta fun\u00e7\u00e3o inicializa o gerador de n\u00fameros pseudoaleat\u00f3rios\n * utilizando o tempo atual como semente. Deve ser chamada uma \u00fanica\n * vez no in\u00edcio do programa antes de qualquer chamada \u00e0s fun\u00e7\u00f5es\n * RandomInteger ou RandomReal.\n */\nvoid Randomize(void)\n{\n  srand((int) time(NULL));\n}\n\n/**\n * @brief Gera um n\u00famero inteiro aleat\u00f3rio dentro de um intervalo especificado.\n *\n * Esta fun\u00e7\u00e3o retorna um n\u00famero inteiro pseudoaleat\u00f3rio uniformemente\n * distribu\u00eddo no intervalo [low, high], inclusive. Requer que a fun\u00e7\u00e3o\n * Randomize() tenha sido chamada previamente para inicializar o gerador\n * de n\u00fameros aleat\u00f3rios.\n *\n * @param low Limite inferior do intervalo\n * @param high Limite superior do intervalo\n * @return Um n\u00famero inteiro aleat\u00f3rio entre low e high, inclusive\n */\nint RandomInteger(int low, int high)\n{\n  int k;\n  double d;\n\n  d = (double) rand() / ((double) RAND_MAX + 1);\n  k = (int) (d * (high - low + 1));\n  return (low + k);\n}\n\n/**\n * @brief Gera um n\u00famero real aleat\u00f3rio dentro de um intervalo especificado.\n *\n * Esta fun\u00e7\u00e3o retorna um n\u00famero de ponto flutuante pseudoaleat\u00f3rio\n * uniformemente distribu\u00eddo no intervalo [low, high). Note que o limite\n * superior (high) n\u00e3o est\u00e1 inclu\u00eddo no intervalo de valores poss\u00edveis.\n * Requer que a fun\u00e7\u00e3o Randomize() tenha sido chamada previamente para\n * inicializar o gerador de n\u00fameros aleat\u00f3rios.\n *\n * @param low Limite inferior do intervalo (inclu\u00eddo)\n * @param high Limite superior do intervalo (n\u00e3o inclu\u00eddo)\n * @return Um n\u00famero real aleat\u00f3rio entre low (inclusive) e high (exclusive)\n */\ndouble RandomReal(double low, double high)\n{\n  double d;\n\n  d = (double) rand() / ((double) RAND_MAX + 1);\n  return (low + d * (high - low));\n}\n</code></pre>"},{"location":"c/biblioteca_c/#data-atual","title":"Data atual","text":"data.c<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;time.h&gt;\n\nint main()\n{\n  time_t t = time(NULL);\n  struct tm tm = *localtime(&amp;t);\n\n  /*\n   * struct tm {\n   *   int tm_sec;   // segundos.....: entre 0 e 59\n   *   int tm_min;   // minutos......: entre 0 e 59\n   *   int tm_hour;  // horas........: entre 0 e 23\n   *   int tm_mday;  // dia..........: entre 1 e 31\n   *   int tm_mon;   // mes..........: entre 0 e 11\n   *   int tm_year;  // ano..........: anos desde 1900\n   *   int tm_wday;  // dia da semana: entre 0 e 6\n   *   int tm_yday;  // dia do ano...: entre 0 e 365\n   *   int tm_isdst; // horario de verao ativo?\n   * };\n   */\n\n  printf(\"Agora sao %02:%02d:%02d\\n\", tm.tm_hour, tm.tm_min, tm.tm_sec);\n  return 0;\n}\n</code></pre>"},{"location":"c/biblioteca_c/#limites-e-constantes","title":"Limites e constantes","text":""},{"location":"c/biblioteca_c/#limitsh","title":"<code>limits.h</code>","text":"Macro Valor<sup>1</sup> Descri\u00e7\u00e3o Tipo de dado <code>CHAR_BIT</code> 8 N\u00famero de bits em um byte <code>SCHAR_MIN</code> -128 Menor valor para um caractere com sinal <code>char</code> <code>SCHAR_MAX</code> +127 Maior valor para um caractere com sinal <code>char</code> <code>UCHAR_MAX</code> 255 Maior valor para um caractere sem sinal <code>unsigned char</code> <code>CHAR_MIN</code> -128 Define o menor valor para o tipo caractere e o seu valor vai ser igual a SCHAR_MIN se o caractere representar valores negativos, ou zero caso contr\u00e1rio <code>char</code> <code>CHAR_MAX</code> +127 Define o maior valor para o tipo caractere e o seu valor vai ser igual a SCHAR_MAX se o caractere representar valores negativos, ou zero caso contr\u00e1rio <code>char</code> <code>MB_LEN_MAX</code> 16 Define o n\u00famero m\u00e1ximo de bytes em um caractere multi-byte <code>SHRT_MIN</code> -32768 Define o menor valor para um inteiro curto <code>short int</code> <code>SHRT_MAX</code> +32767 Define o maior valor para um inteiro curto <code>short int</code> <code>USHRT_MAX</code> 65535 Define o maior valor para um inteiro curto sem sinal <code>unsigned short int</code> <code>INT_MIN</code> -2147483648 Define o menor valor para um inteiro <code>int</code> <code>INT_MAX</code> +2147483647 Define o maior valor para um inteiro <code>int</code> <code>UINT_MAX</code> 4294967295 Define o maior valor para um inteiro sem sinal <code>unsigned int</code> <code>LONG_MIN</code> -9223372036854775808 Define o menor valor para um inteiro longo <code>long int</code> <code>LONG_MAX</code> +9223372036854775807 Define o maior valor para um inteiro longo <code>long int</code> <code>ULONG_MAX</code> 18446744073709551615 Define o maior valor para um inteiro longo sem sinal <code>unsigned long int</code> <code>LLONG_MIN</code> -9223372036854775808 Define o menor valor para um inteiro longo longo <code>long long int</code> <code>LLONG_MAX</code> +9223372036854775807 Define o maior valor para um inteiro longo longo <code>long long int</code> <code>ULLONG_MAX</code> 18446744073709551615 Define o maior valor para um inteiro longo longo sem sinal <code>unsigned long long int</code>"},{"location":"c/biblioteca_c/#floath","title":"<code>float.h</code>","text":"Macro Valor<sup>1</sup> Descri\u00e7\u00e3o Tipo de dado <code>FLT_MAX</code> \\(3,4 \\times 10^{38}\\) Maior valor positivo de ponto flutuante com precis\u00e3o de at\u00e9 6 casas decimais <code>float</code> <code>FLT_MIN</code> \\(1,2 \\times 10^{-38}\\) Menor valor positivo de ponto flutuante com precis\u00e3o de at\u00e9 6 casas decimais <code>float</code> <code>-FLT_MAX</code> \\(-3,4 \\times 10^{38}\\) Maior valor negativo de ponto flutuante com precis\u00e3o de at\u00e9 6 casas decimais <code>float</code> <code>-FLT_MIN</code> \\(-1,2 \\times 10^{-38}\\) Menor valor negativo de ponto flutuante com precis\u00e3o de at\u00e9 6 casas decimais <code>float</code> <code>FLT_DIG</code> 6 N\u00famero de d\u00edgitos decimais que podem ser representados sem perda de precis\u00e3o <code>float</code> <code>FLT_EPSILON</code> \\(1,19 \\times 10^{-7}\\) Diferen\u00e7a entre 1.0 e o pr\u00f3ximo valor represent\u00e1vel <code>float</code> <code>DBL_MAX</code> \\(1,7 \\times 10^{308}\\) Maior valor positivo de ponto flutuante com precis\u00e3o de at\u00e9 15 casas decimais <code>double</code> <code>DBL_MIN</code> \\(2,3 \\times 10^{-308}\\) Menor valor positivo de ponto flutuante com precis\u00e3o de at\u00e9 15 casas decimais <code>double</code> <code>-DBL_MAX</code> \\(-1,7 \\times 10^{308}\\) Maior valor negativo de ponto flutuante com precis\u00e3o de at\u00e9 15 casas decimais <code>double</code> <code>-DBL_MIN</code> \\(-2,3 \\times 10^{-308}\\) Menor valor negativo de ponto flutuante com precis\u00e3o de at\u00e9 15 casas decimais <code>double</code> <code>DBL_DIG</code> 15 N\u00famero de d\u00edgitos decimais que podem ser representados sem perda de precis\u00e3o <code>double</code> <code>DBL_EPSILON</code> \\(2,22 \\times 10^{-16}\\) Diferen\u00e7a entre 1.0 e o pr\u00f3ximo valor represent\u00e1vel <code>double</code> <code>LDBL_MAX</code> \\(1,2 \\times 10^{4932}\\) Maior valor positivo de ponto flutuante de precis\u00e3o estendida <code>long double</code> <code>LDBL_MIN</code> \\(3,36 \\times 10^{-4932}\\) Menor valor positivo de ponto flutuante de precis\u00e3o estendida <code>long double</code> <code>-LDBL_MAX</code> \\(-1,2 \\times 10^{4932}\\) Maior valor negativo de ponto flutuante de precis\u00e3o estendida <code>long double</code> <code>-LDBL_MIN</code> \\(-3,36 \\times 10^{-4932}\\) Menor valor negativo de ponto flutuante de precis\u00e3o estendida <code>long double</code> <code>LDBL_DIG</code> 18 N\u00famero de d\u00edgitos decimais que podem ser representados sem perda de precis\u00e3o <code>long double</code> <code>LDBL_EPSILON</code> \\(1,08 \\times 10^{-19}\\) Diferen\u00e7a entre 1.0 e o pr\u00f3ximo valor represent\u00e1vel <code>long double</code>"},{"location":"c/biblioteca_c/#mathh","title":"<code>math.h</code>","text":"<p> Macro Valor Descri\u00e7\u00e3o <code>M_E</code> \\(e\\) Base dos logaritmos naturais <code>M_LOG2E</code> \\(\\log_2e\\) Logaritmo de e na base 2 <code>M_LOG10E</code> \\(\\log_{10}e\\) Logaritmo de e na base 10 <code>M_LN2</code> \\(\\ln 2\\) Logaritmo natural de 2 <code>M_LN10</code> \\(\\ln 10\\) Logaritmo natural de 10 <code>M_PI</code> \\(\\pi\\) Constante pi (raz\u00e3o entre a circunfer\u00eancia e o di\u00e2metro de um c\u00edrculo) <code>M_PI_2</code> \\(\\dfrac{\\pi}{2}\\) Metade de pi <code>M_PI_4</code> \\(\\dfrac{\\pi}{4}\\) Um quarto de pi <code>M_1_PI</code> \\(\\dfrac{1}{\\pi}\\) Inverso de pi <code>M_2_PI</code> \\(\\dfrac{2}{\\pi}\\) Duas vezes o inverso de pi <code>M_2_SQRTPI</code> \\(\\dfrac{2}{\\sqrt{\\pi}}\\) Duas vezes o inverso da raiz quadrada de pi <code>M_SQRT2</code> \\(\\sqrt{2}\\) Raiz quadrada de 2 <code>M_SQRT1_2</code> \\(\\dfrac{1}{\\sqrt{2}}\\) Inverso da raiz quadrada de 2 <code>INFINITY</code> \\(\\infty\\) Representa o infinito (positivo) <p></p>"},{"location":"c/biblioteca_c/#mascaras-de-formatacao-para-printf-e-scanf","title":"M\u00e1scaras de formata\u00e7\u00e3o para printf e scanf","text":"<p> M\u00e1scara Significado <code>%c</code> Caractere <code>%d</code> ou <code>%i</code> N\u00famero decimal inteiro com sinal (base 10) <code>%ld</code> N\u00famero decimal inteiro longo com sinal (base 10) <code>%lld</code> N\u00famero decimal inteiro longo longo com sinal (base 10) <code>%lu</code> N\u00famero decimal inteiro longo sem sinal (base 10) <code>%llu</code> N\u00famero decimal inteiro longo longo sem sinal (base 10) <code>%e</code> ou <code>%E</code> N\u00famero de ponto flutuante com nota\u00e7\u00e3o exponencial <code>%f</code> N\u00famero de ponto flutuante (decimal) <code>%lf</code> N\u00famero de ponto flutuante de precis\u00e3o dupla (double) <code>%Lf</code> N\u00famero de ponto flutuante de precis\u00e3o estendida (long double) <code>%g</code> ou <code>%G</code> Escolhe automaticamente <code>%e</code> ou <code>%f</code> com base no valor <code>%o</code> N\u00famero octal (base 8) <code>%s</code> Cadeia de caracteres (string) <code>%u</code> N\u00famero decimal inteiro sem sinal (base 10) <code>%x</code> ou <code>%X</code> N\u00famero hexadecimal (base 16) <code>%p</code> Endere\u00e7o de ponteiro (em hexadecimal) <code>%%</code> Caractere literal <code>%</code> <p></p>"},{"location":"c/biblioteca_c/#modificadores-para-alinhamento-e-tamanho","title":"Modificadores para alinhamento e tamanho","text":"<p> Exemplo Resultado<sup>2</sup> <code>printf(\"[%3d]\", 0);</code> <code>[__0]</code> <code>printf(\"[%3d]\", 123456789);</code> <code>[123456789]</code> <code>printf(\"[%3d]\", -10);</code> <code>[-10]</code> <code>printf(\"[%3d]\", -123456789);</code> <code>[-123456789]</code> <code>printf(\"[%-3d]\", 0);</code> <code>[0__]</code> <code>printf(\"[%-3d]\", 123456789);</code> <code>[123456789]</code> <code>printf(\"[%-3d]\", -10);</code> <code>[-10]</code> <code>printf(\"[%-3d]\", -123456789);</code> <code>[-123456789]</code> <code>printf(\"[%03d]\", 0);</code> <code>[000]</code> <code>printf(\"[%03d]\", 1);</code> <code>[001]</code> <code>printf(\"[%03d]\", 123456789);</code> <code>[123456789]</code> <code>printf(\"[%03d]\", -10);</code> <code>[-10]</code> <code>printf(\"[%03d]\", -123456789);</code> <code>[-123456789]</code> <code>printf(\"[%+5d]\", 10);</code> <code>[__+10]</code> <code>printf(\"[%-+5d]\", 10);</code> <code>[+10__]</code> <code>printf(\"[%6.2f]\", 6.4);</code> <code>[__6.40]</code> <code>printf(\"[%.2f]\", 6.4);</code> <code>[6.40]</code> <p></p> <ol> <li> <p>O valor pode variar em fun\u00e7\u00e3o de compilador, sistema operacional e arquitetura onde o programa est\u00e1 executando\u00a0\u21a9\u21a9</p> </li> <li> <p><code>_</code> indica um espa\u00e7o.\u00a0\u21a9</p> </li> </ol>"},{"location":"c/criacao/","title":"A cria\u00e7\u00e3o de um programa em C","text":"<p>Quando escrevemos um programa em C, o c\u00f3digo que criamos, geralmente salvo em arquivos com extens\u00e3o <code>.c</code> (os arquivos fonte), n\u00e3o pode ser executado diretamente pelo computador.</p> <p>A raz\u00e3o disso \u00e9 porque o processador s\u00f3 entende instru\u00e7\u00f5es em linguagem de m\u00e1quina, um c\u00f3digo bin\u00e1rio bem diferente das palavras e comandos que usamos em C, como <code>printf()</code> ou <code>int</code>. O processo de compila\u00e7\u00e3o \u00e9 justamente o que transforma esse c\u00f3digo leg\u00edvel por humanos em algo que o computador pode executar.</p> <p>Para transformar arquivos com o c\u00f3digo fonte em um programa que possa ser executado pelo computador, precisamos passar por quatro etapas: edi\u00e7\u00e3o do c\u00f3digo fonte, pr\u00e9-processamento, compila\u00e7\u00e3o e montagem, e link-edi\u00e7\u00e3o. O programa execut\u00e1vel s\u00f3 existe depois da \u00faltima etapa conclu\u00edda.</p> <pre><code>graph TD\n  Fonte1 --&gt; Preprocessamento1 --&gt; Processado1\n  Fonte2 --&gt; Preprocessamento2 --&gt; Processado2\n  BibEstat1 --&gt; Compilador1\n  BibEstat2 --&gt; Compilador1\n  Processado1 --&gt; Compilador1 --&gt; Obj1\n  Processado2 --&gt; Compilador2\n  BibEstat1 --&gt; Compilador2 --&gt; Obj2\n  Obj2 --&gt; Link\n  Obj1 --&gt; Link --&gt; Exec\n\n  Fonte1@{ shape: doc, label: \"**C\u00f3digo fonte**&lt;br /&gt;(.c, .h)\" }\n  Fonte2@{ shape: doc, label: \"**C\u00f3digo fonte**&lt;br /&gt;(.c, .h)\" }\n  Preprocessamento1@{ shape: process, label: \"Pr\u00e9-processamento\" }\n  Preprocessamento2@{ shape: process, label: \"Pr\u00e9-processamento\" }\n  Processado1@{ shape: doc, label: \"**C\u00f3digo pr\u00e9-processado**&lt;br /&gt;(.i)\" }\n  Processado2@{ shape: doc, label: \"**C\u00f3digo pr\u00e9-processado**&lt;br /&gt;(.i)\" }\n  BibEstat1@{ shape: lin-doc, label: \"**Biblioteca B1**&lt;br /&gt;(.so)\" }\n  BibEstat2@{ shape: lin-doc, label: \"**Biblioteca B2**&lt;br /&gt;(.so)\" }\n  Compilador1@{shape: process, label: \"Compila\u00e7\u00e3o e montagem\" }\n  Compilador2@{shape: process, label: \"Compila\u00e7\u00e3o e montagem\" }\n  Obj1@{ shape: doc, label: \"**C\u00f3digo objeto**&lt;br /&gt;(.o)\" }\n  Obj2@{ shape: doc, label: \"**C\u00f3digo objeto**&lt;br /&gt;(.o)\" }\n  Link@{ shape: process, label: \"Link-edi\u00e7\u00e3o\" }\n  Exec@{ shape: doc, label: \"**Programa execut\u00e1vel**&lt;br /&gt;(.exe)\" }</code></pre> <p>Vamos discutir de maneira simplificada cada uma delas.</p>"},{"location":"c/criacao/#edicao-do-codigo-fonte","title":"Edi\u00e7\u00e3o do c\u00f3digo fonte","text":"<p>Analisando friamente, podemos utilizar qualquer editor de textos para escrever um programa em linguagem C (ou qualquer outra linguagem, como Python, Java ou TypeScript).  O problema \u00e9 que a nossa produtividade (linhas de c\u00f3digo que escrevemos pelo esfor\u00e7o dispendido) n\u00e3o vai ser boa.</p> <p>Um editor de texto est\u00e1 preparado para editar qualquer tipo de texto. Ele n\u00e3o foi pensando para escrever programas, ent\u00e3o faltam algumas coisas importantes, como por exemplo a integra\u00e7\u00e3o com um compilador, um ambiente para executar o programa, ferramentas para auxiliar a resolver erros que aparecem durante a execu\u00e7\u00e3o ou compila\u00e7\u00e3o do programa.  O ideal \u00e9 que fa\u00e7amos o desenvolvimento dentro de um IDE.</p> <p>Um Ambiente Integrado de Desenvolvimento (IDE, do ingl\u00eas Integrated Development Environment) \u00e9 um software que re\u00fane diversas ferramentas essenciais para a programa\u00e7\u00e3o em um \u00fanico local, facilitando o desenvolvimento de aplica\u00e7\u00f5es. Ele geralmente inclui um editor de c\u00f3digo, um compilador ou interpretador, um depurador e outros recursos que auxiliam na escrita, teste e manuten\u00e7\u00e3o do c\u00f3digo. Eles surgiram para simplificar o processo de programa\u00e7\u00e3o, que anteriormente exigia que os desenvolvedores escrevessem c\u00f3digo em um editor de texto, salvassem o arquivo, acionassem o compilador separadamente e depois retornassem ao editor para corrigir eventuais erros.</p> <p>Uma das principais caracter\u00edsticas de uma IDE \u00e9 o suporte \u00e0 edi\u00e7\u00e3o inteligente de c\u00f3digo. Recursos como realce de sintaxe, autocompletar e sugest\u00f5es autom\u00e1ticas ajudam a evitar erros e tornam a escrita do c\u00f3digo mais eficiente. Al\u00e9m disso, muitas IDEs oferecem integra\u00e7\u00e3o com sistemas de controle de vers\u00e3o, permitindo que os desenvolvedores trabalhem de forma colaborativa em projetos sem perder o controle das altera\u00e7\u00f5es. Algumas tamb\u00e9m possibilitam a utiliza\u00e7\u00e3o de bibliotecas e frameworks externos, simplificando o desenvolvimento de aplica\u00e7\u00f5es mais complexas. Para iniciantes, os IDEs tamb\u00e9m oferecem uma curva de aprendizado mais suave, com recursos que auxiliam na compreens\u00e3o da sintaxe e na identifica\u00e7\u00e3o de erros comuns.</p> <p></p> <p>Tela principal da IDE CLion (JetBrains)</p>"},{"location":"c/criacao/#comentarios","title":"Coment\u00e1rios","text":"<p>Os coment\u00e1rios em linguagem C s\u00e3o elementos n\u00e3o execut\u00e1veis que fornecem descri\u00e7\u00f5es e explica\u00e7\u00f5es adicionais dentro do c\u00f3digo-fonte. Eles desempenham um papel fundamental na documenta\u00e7\u00e3o do programa, tornando-o mais leg\u00edvel e compreens\u00edvel tanto para o pr\u00f3prio desenvolvedor quanto para outros programadores que possam trabalhar com o c\u00f3digo no futuro.</p> <p>Note</p> <p>Historicamente, antes da vers\u00e3o C99 (lan\u00e7ada em 1999), apenas os coment\u00e1rios de m\u00faltiplas linhas (<code>/* */</code>) eram suportados na linguagem C. Os coment\u00e1rios de linha \u00fanica (<code>//</code>) foram incorporados aos compiladores C com o padr\u00e3o C99, tendo sido originalmente uma caracter\u00edstica da linguagem C++.</p> <p>A linguagem C suporta dois tipos principais de coment\u00e1rios.</p> <p>O primeiro tipo s\u00e3o os coment\u00e1rios de linha \u00fanica, que come\u00e7am com duas barras (<code>//</code>) e se estendem at\u00e9 o final da linha. Tudo que estiver ap\u00f3s essas duas barras ser\u00e1 ignorado pelo compilador durante o processo de compila\u00e7\u00e3o. Por exemplo, podemos escrever a linha abaixo em qualquer parte do c\u00f3digo, e o compilador simplesmente ignorar\u00e1 esse texto.</p> <pre><code>// Este \u00e9 um coment\u00e1rio de linha \u00fanica\n</code></pre> <p>O segundo tipo s\u00e3o os coment\u00e1rios de m\u00faltiplas linhas, tamb\u00e9m conhecidos como coment\u00e1rios em bloco. Estes come\u00e7am com a sequ\u00eancia <code>/*</code> e terminam com <code>*/</code>. Todo o texto entre esses delimitadores \u00e9 considerado um coment\u00e1rio, independentemente de quantas linhas ele ocupe, como no exemplo abaixo.</p> <pre><code>/* Este coment\u00e1rio pode se estender por v\u00e1rias\n   linhas e explicar detalhadamente o funcionamento\n   de determinado trecho de c\u00f3digo */\n</code></pre> <p>Os coment\u00e1rios s\u00e3o utilizados por diversas raz\u00f5es importantes no desenvolvimento de software:</p> <ul> <li>Eles tornam o c\u00f3digo mais leg\u00edvel para refer\u00eancia futura, o que \u00e9 especialmente \u00fatil quando o programador precisa revisitar seu pr\u00f3prio c\u00f3digo ap\u00f3s um longo per\u00edodo;</li> <li>Os coment\u00e1rios s\u00e3o ferramentas valiosas para depura\u00e7\u00e3o, permitindo que partes do c\u00f3digo sejam temporariamente desativadas para testes;</li> <li>Em ambientes onde m\u00faltiplos desenvolvedores trabalham no mesmo projeto, coment\u00e1rios bem escritos facilitam o entendimento do c\u00f3digo por todos os membros da equipe, principalmente em c\u00f3digos complexos ou otimizados, onde a l\u00f3gica pode n\u00e3o ser imediatamente \u00f3bvia.</li> </ul> <p>Veja bem, preste aten\u00e7\u00e3o!</p> <p>Vale ressaltar que os coment\u00e1rios n\u00e3o devem ser usados como substitutos para c\u00f3digo mal escrito. A prioridade deve ser sempre escrever c\u00f3digo limpo e compreens\u00edvel, utilizando coment\u00e1rios como complemento para esclarecer inten\u00e7\u00f5es e l\u00f3gicas complexas.</p> <p>Para utilizar coment\u00e1rios de forma eficaz, \u00e9 recomendado que eles expliquem o \"porqu\u00ea\" por tr\u00e1s do c\u00f3digo, n\u00e3o apenas o \"como\". Coment\u00e1rios devem ser claros e concisos, fornecendo informa\u00e7\u00f5es suficientes para entender o prop\u00f3sito do c\u00f3digo sem serem excessivamente detalhados.</p> <p>\u00c9 importante manter os coment\u00e1rios atualizados quando o c\u00f3digo \u00e9 modificado. Coment\u00e1rios desatualizados podem causar confus\u00e3o e levar a erros de interpreta\u00e7\u00e3o. Al\u00e9m disso, deve-se evitar coment\u00e1rios redundantes que apenas repetem o que o c\u00f3digo j\u00e1 expressa claramente.</p>"},{"location":"c/criacao/#pre-processamento","title":"Pr\u00e9-processamento","text":"<pre><code>graph LR\n  Fonte1 --&gt; Preprocessamento1 --&gt; Processado1\n\n  Fonte1@{ shape: doc, label: \"**C\u00f3digo fonte**&lt;br /&gt;(.c, .h)\" }\n  Preprocessamento1@{ shape: process, label: \"Pr\u00e9-processamento\" }\n  Processado1@{ shape: doc, label: \"**C\u00f3digo pr\u00e9-processado**&lt;br /&gt;(.i)\" }</code></pre> <p>A segunda etapa \u00e9 o pr\u00e9-processamento, feita pelo pr\u00e9-processador, um programa que \"prepara\" o c\u00f3digo antes da compila\u00e7\u00e3o propriamente dita.</p> <p>Quando escrevemos um programa em C, usamos diretivas que come\u00e7am com <code>#</code>. Essas diretivas s\u00e3o instru\u00e7\u00f5es para o pr\u00e9-processador.</p> <p>Durante esta fase:</p> <ul> <li>As macros s\u00e3o expandidas;</li> <li>Os arquivos de cabe\u00e7alho (.h) s\u00e3o inclu\u00eddos no arquivo-fonte;</li> <li>Espa\u00e7os desnecess\u00e1rios s\u00e3o removidos, e;</li> <li>Coment\u00e1rios s\u00e3o eliminados</li> </ul> <p>O resultado \u00e9 uma vers\u00e3o do c\u00f3digo fonte \"limpa\". Este arquivo, normalmente com extens\u00e3o <code>.i</code>, cont\u00e9m todo o c\u00f3digo-fonte original mais o conte\u00fado dos arquivos inclu\u00eddos e as macros expandidas, gerando um arquivo significativamente maior que o original.</p> <p>As principais diretivas de pr\u00e9-compila\u00e7\u00e3o s\u00e3o:</p> <ul> <li> <p><code>#include</code>: substituem declara\u00e7\u00f5es de inclus\u00e3o de arquivos, como arquivos de cabe\u00e7alho (.h). Isso permite que fun\u00e7\u00f5es e defini\u00e7\u00f5es externas sejam incorporadas ao c\u00f3digo. Por exemplo, ao escrever <code>#include &lt;stdio.h&gt;</code>, estamos pedindo para incluir o conte\u00fado do arquivo de cabe\u00e7alho <code>stdio.h</code> (que cont\u00e9m declara\u00e7\u00f5es de fun\u00e7\u00f5es como <code>printf()</code>) no nosso c\u00f3digo;</p> </li> <li> <p><code>#define</code>: realizam substitui\u00e7\u00f5es de macros, que podem ser valores constantes ou pequenas fun\u00e7\u00f5es inline. Se usarmos, por exemplo, <code>#define PI 3.14</code>, o pr\u00e9-processador substituir\u00e1 todas as ocorr\u00eancias de <code>PI</code> no c\u00f3digo por <code>3.14</code>. Ao fazermos <code>#define QUADRADO(x) ((x) * (x))</code> o pr\u00e9-processador substitui todas as ocorr\u00eancias de <code>QUADRADO(valor)</code> pela express\u00e3o <code>(valor * valor)</code> antes da compila\u00e7\u00e3o. A diretiva pode ser usada tamb\u00e9m apenas para a defini\u00e7\u00e3o de um s\u00edmbolo (<code>#define DEBUG</code>, por exemplo) que pode ter a exist\u00eancia verificada (<code>#ifdef DEBUG</code>, por exemplo);</p> </li> <li> <p><code>#undef</code>: remove faz com que o s\u00edmbolo ou macro seja apagada da tabela interna. A partir deste ponto, o compilador n\u00e3o conhece mais esta macro;</p> </li> <li> <p><code>#ifdef</code>, <code>#ifndef</code> e outras relacionadas: permitem compilar trechos espec\u00edficos do c\u00f3digo com base em defini\u00e7\u00f5es previamente estabelecidas. Isso \u00e9 extremamente \u00fatil quando estamos escrevendo um programa que deve rodar em mais de uma arquitetura e, dependendo da arquitetura vai utilizar uma biblioteca ou outra, por exemplo.</p> </li> </ul> Exemplos de uso de diretivas de compila\u00e7\u00e3o<pre><code>#include &lt;stdio.h&gt;\n\n#define max(A, B) ((A &gt; B) ? (A) : (B))\n#define min(A, B) ((A &lt; B) ? (A) : (B))\n#define DEBUG\n\nint main ()\n{\n  int x, y, maior;\n#ifdef DEBUG\n  printf(\"Depurando o programa\");\n#endif\n  x = 5;\n  y = 7;\n  maior = max(x, y);\n\n  printf (\"Entre %d e %d, o maior \u00e9 %d\\n\", x, y, maior);\n\n  return 0;\n}\n</code></pre>"},{"location":"c/criacao/#compilacao-e-montagem","title":"Compila\u00e7\u00e3o e montagem","text":"<pre><code>graph LR\n  BibEstat1 --&gt; Compilador1\n  BibEstat2 --&gt; Compilador1\n  Processado1 --&gt; Compilador1 --&gt; Obj1\n\n  Processado1@{ shape: doc, label: \"**C\u00f3digo pr\u00e9-processado**&lt;br /&gt;(.i)\" }\n  BibEstat1@{ shape: lin-doc, label: \"**Biblioteca B1**&lt;br /&gt;(.so)\" }\n  BibEstat2@{ shape: lin-doc, label: \"**Biblioteca B2**&lt;br /&gt;(.so)\" }\n  Compilador1@{shape: process, label: \"Compila\u00e7\u00e3o e montagem\" }\n  Obj1@{ shape: doc, label: \"**C\u00f3digo objeto**&lt;br /&gt;(.o)\" }</code></pre> <p>Nesta etapa, o compilador realiza a an\u00e1lise sint\u00e1tica e sem\u00e2ntica do c\u00f3digo pr\u00e9-processado. Ele verifica se o c\u00f3digo est\u00e1 escrito corretamente, seguindo as regras da linguagem C, como par\u00eanteses n\u00e3o fechados, falta de ponto e v\u00edrgula, entre outros erros sint\u00e1ticos.</p> <p>Se n\u00e3o houver erros, o compilador traduz o c\u00f3digo para a linguagem de montagem da m\u00e1quina (linguagem assembly), que \u00e9 uma representa\u00e7\u00e3o de baixo n\u00edvel mais pr\u00f3xima da linguagem de m\u00e1quina. O resultado \u00e9, normalmente, um arquivo com extens\u00e3o <code>.s</code></p> <p>O c\u00f3digo em assembly resultante vai conter instru\u00e7\u00f5es espec\u00edficas para a arquitetura do processador (como x86 ou ARM) que ser\u00e1 utilizado.</p> <p>A etapa de montagem transforma o c\u00f3digo assembly em c\u00f3digo-objeto, que est\u00e1 em linguagem de m\u00e1quina, por\u00e9m ainda n\u00e3o est\u00e1 pronto para ser executado. O c\u00f3digo bin\u00e1rio resultante ainda n\u00e3o pode ser executado porque pode depender de fun\u00e7\u00f5es ou vari\u00e1veis definidas em outros lugares (como em outro arquivo <code>.c</code> ou em bibliotecas externas). Cada arquivo <code>.c</code> gera seu pr\u00f3prio arquivo objeto, de extens\u00e3o <code>.o</code>, nessa etapa.</p> <p>A parte do compilador que faz essa convers\u00e3o \u00e9 o montador, ou assembler.</p>"},{"location":"c/criacao/#link-edicao","title":"Link-edi\u00e7\u00e3o","text":"<pre><code>graph LR\n  Obj1 --&gt; Link --&gt; Exec\n\n  Obj1@{ shape: doc, label: \"**C\u00f3digo objeto**&lt;br /&gt;(.o)\" }\n  Link@{ shape: process, label: \"Link-edi\u00e7\u00e3o\" }\n  Exec@{ shape: doc, label: \"**Programa execut\u00e1vel**&lt;br /&gt;(.exe)\" }</code></pre> <p>Imagine que os arquivos objeto .o s\u00e3o como pe\u00e7as de um quebra-cabe\u00e7a: cada um tem uma parte do programa, mas eles precisam ser conectados para formar o todo. A link-edi\u00e7\u00e3o \u00e9 a etapa final do processo, onde o linkeditor (linker) combina todos os arquivos-objeto gerados e as bibliotecas necess\u00e1rias em um \u00fanico arquivo execut\u00e1vel. O linker realiza as seguintes tarefas:</p> <ul> <li>Resolve refer\u00eancias entre os diferentes m\u00f3dulos do programa, garantindo que todas as refer\u00eancias a fun\u00e7\u00f5es e vari\u00e1veis estejam devidamente definidas e resolvidas;</li> <li>Se o programa utiliza fun\u00e7\u00f5es externas, como as da biblioteca padr\u00e3o do C (<code>stdio.h</code>, <code>math.h</code>), o linker adiciona os arquivos correspondentes ao execut\u00e1vel final, e;</li> <li>Gera o arquivo execut\u00e1vel final</li> </ul> <p>O arquivo execut\u00e1vel gerado pode ser executado diretamente pelo sistema operacional.</p>"},{"location":"c/criacao/#um-programa-em-c-minimo","title":"Um programa em C m\u00ednimo","text":"<p>Um programa em C m\u00ednimo para escrever \"Ol\u00e1, mundo!\" na tela pode ser o seguinte</p> ola_mundo.c<pre><code>#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    printf(\"Ola, mundo!\\n\");\n}\n</code></pre> <p>Este programa \u00e9 um exemplo cl\u00e1ssico que foi popularizado pelo livro \"The C Programming Language\", escrito por Brian Kernighan e Dennis Ritchie, os criadores da linguagem C. Atrav\u00e9s de sua simplicidade, ele nos introduz aos conceitos fundamentais da linguagem, como inclus\u00e3o de cabe\u00e7alhos, declara\u00e7\u00e3o de fun\u00e7\u00f5es, blocos de c\u00f3digo e opera\u00e7\u00f5es de entrada e sa\u00edda.</p> <p>A primeira linha, <code>#include &lt;stdio.h&gt;</code>, como j\u00e1 vimos, \u00e9 uma diretiva de pr\u00e9-processador. Neste caso, <code>#include</code> instrui o pr\u00e9-processador a inserir o conte\u00fado do arquivo especificado no local onde a diretiva se encontra. O arquivo <code>&lt;stdio.h&gt;</code> \u00e9 um cabe\u00e7alho da biblioteca padr\u00e3o de entrada e sa\u00edda (Standard Input/Output Header). Os colchetes angulares (<code>&lt;&gt;</code>) indicam que o arquivo deve ser buscado nos diret\u00f3rios padr\u00e3o do sistema. Este cabe\u00e7alho cont\u00e9m declara\u00e7\u00f5es de fun\u00e7\u00f5es essenciais para opera\u00e7\u00f5es de entrada e sa\u00edda, incluindo a fun\u00e7\u00e3o <code>printf()</code>, que utilizaremos para exibir a mensagem na tela.</p> <p>A segunda linha \u00e9 uma linha em branco, utilizada para melhorar a legibilidade do c\u00f3digo. Embora n\u00e3o tenha impacto na execu\u00e7\u00e3o do programa, ela serve para separar visualmente a se\u00e7\u00e3o de inclus\u00e3o de cabe\u00e7alhos da defini\u00e7\u00e3o da fun\u00e7\u00e3o principal.</p> <p>A terceira linha, <code>int main(void)</code>, define a fun\u00e7\u00e3o principal do programa, chamada main. Em C, a fun\u00e7\u00e3o <code>main</code> \u00e9 especial, pois \u00e9 o ponto de entrada obrigat\u00f3rio para qualquer programa. A palavra-chave <code>int</code> indica que a fun\u00e7\u00e3o retorna um valor inteiro, que representa o c\u00f3digo de sa\u00edda do programa. O nome <code>main</code> \u00e9 fixo e n\u00e3o pode ser alterado. Os par\u00eanteses <code>(void)</code> indicam que a fun\u00e7\u00e3o n\u00e3o recebe nenhum par\u00e2metro. Em C, <code>void</code> \u00e9 utilizado para especificar explicitamente que n\u00e3o h\u00e1 par\u00e2metros, garantindo maior clareza e seguran\u00e7a no c\u00f3digo.</p> <p>A quarta linha, <code>{</code>, abre o bloco de c\u00f3digo (corpo) da fun\u00e7\u00e3o <code>main</code>. Em C, blocos de c\u00f3digo s\u00e3o delimitados por chaves (<code>{}</code>), que agrupam um conjunto de instru\u00e7\u00f5es relacionadas.</p> <p>A quinta linha, <code>printf(\"Ola, mundo!\\n\");</code>, \u00e9 onde a m\u00e1gica acontece. Aqui, chamamos a fun\u00e7\u00e3o <code>printf()</code>, que faz parte da biblioteca padr\u00e3o e foi declarada no cabe\u00e7alho <code>&lt;stdio.h&gt;</code>. A fun\u00e7\u00e3o <code>printf()</code> exibe texto formatado na sa\u00edda padr\u00e3o, que geralmente \u00e9 a tela do computador. A string literal <code>\"Ola, mundo!\\n\"</code> \u00e9 passada como argumento para a fun\u00e7\u00e3o. Uma string literal \u00e9 uma sequ\u00eancia de caracteres delimitada por aspas duplas. O caractere especial <code>\\n</code> \u00e9 uma sequ\u00eancia de escape que representa uma nova linha, fazendo com que o cursor avance para a pr\u00f3xima linha ap\u00f3s a exibi\u00e7\u00e3o da mensagem. O ponto e v\u00edrgula (<code>;</code>) marca o fim de uma instru\u00e7\u00e3o em C, assim como um ponto final em uma frase.</p> <p>A sexta e \u00faltima linha, <code>}</code>, fecha o bloco de c\u00f3digo da fun\u00e7\u00e3o main, marcando o fim da fun\u00e7\u00e3o principal.</p> <p>\u00c9 importante notar que este programa n\u00e3o possui uma instru\u00e7\u00e3o <code>return</code> expl\u00edcita. No entanto, em C99 e vers\u00f5es posteriores, se a fun\u00e7\u00e3o <code>main</code> terminar sem uma instru\u00e7\u00e3o <code>return</code>, o compilador automaticamente insere <code>return 0;</code>, indicando que o programa foi executado com sucesso. Al\u00e9m disso, a fun\u00e7\u00e3o main pode ser declarada de outras formas v\u00e1lidas, como <code>int main()</code> ou <code>int main(int argc, char *argv[])</code>, que s\u00e3o utilizadas para receber argumentos da linha de comando.</p>"},{"location":"c/entrada_saida/","title":"Entrada e sa\u00edda","text":""},{"location":"c/entrada_saida/#fluxos-de-entrada-e-saida","title":"Fluxos de entrada e sa\u00edda","text":"<p>A linguagem C oferece um modelo padronizado de entrada e sa\u00edda baseado em tr\u00eas fluxos fundamentais:</p> <ul> <li>stdin (standard input): fluxo de entrada padr\u00e3o, geralmente associado ao teclado.</li> <li>stdout (standard output): fluxo de sa\u00edda padr\u00e3o, comumente direcionado ao terminal.</li> <li>stderr (standard error): fluxo de sa\u00edda de erros, utilizado para exibir mensagens de erro separadamente da sa\u00edda padr\u00e3o.</li> </ul> <p>Esses fluxos permitem flexibilidade na intera\u00e7\u00e3o entre o programa e o sistema operacional, possibilitando que a entrada e a sa\u00edda sejam redirecionadas para arquivos ou dispositivos espec\u00edficos.</p>"},{"location":"c/entrada_saida/#entrada-de-dados","title":"Entrada de Dados","text":""},{"location":"c/entrada_saida/#funcao-scanf","title":"Fun\u00e7\u00e3o <code>scanf</code>","text":"<p>A fun\u00e7\u00e3o <code>scanf()</code> \u00e9 uma das primeiras que aprendemos a utilizar em C. Com ela, \u00e9 poss\u00edvel atribuir a uma vari\u00e1vel algum valor (num\u00e9rico ou n\u00e3o) informado pelo usu\u00e1rio. O <code>f</code> no nome da fun\u00e7\u00e3o indica que ela faz uma entrada formatada.  Os caracteres que definem as m\u00e1scaras de formata\u00e7\u00e3o est\u00e3o definidos em outra parte deste documento.</p> <p>Se n\u00e3o houver redirecionamento de fluxo padr\u00e3o, a leitura \u00e9 feita a partir da entrada padr\u00e3o.</p> Lendo a idade<pre><code>int idade;\nprintf(\"Digite sua idade: \");\nscanf(\"%d\", &amp;idade);\nprintf(\"Voc\u00ea tem %d anos.\\n\", idade);\n</code></pre> <p>Um dos problemas que aparecem com o uso de <code>scanf()</code> \u00e9 na hora de misturar a leitura de valores num\u00e9ricos com valores n\u00e3o-num\u00e9ricos: a fun\u00e7\u00e3o pode deixar caracteres pendentes no fluxo de entrada, causando problemas nas leituras subsequentes:</p> Problema no uso de scanf<pre><code>char nome[50];\nint idade;\nprintf(\"Digite sua idade: \");\nscanf(\"%d\", &amp;idade);\nprintf(\"Digite seu nome: \");\nscanf(\"%s\", nome);\nprintf(\"Nome: %s, Idade: %d\\n\", nome, idade);\n</code></pre> <p>O problema ocorre porque <code>scanf(\"%d\", &amp;idade)</code> deixa um <code>\\n</code> n\u00e3o processado no fluxo de entrada.</p> <p>A solu\u00e7\u00e3o ideal para esse caso \u00e9 n\u00e3o utilizar <code>scanf()</code>.  Na biblioteca de c\u00f3digos h\u00e1 a proposta de algumas rotinas que resolvem esse problema.</p> <p>Uma outra alternativa, mais simples, mas que nem sempre funciona, \u00e9 consumir manualmente o <code>\\n</code> com a fun\u00e7\u00e3o <code>getchar()</code>, que ser\u00e1 detalhada a seguir.</p> Consumindo o \\n restante<pre><code>char nome[50];\nint idade;\nprintf(\"Digite sua idade: \");\nscanf(\"%d\", &amp;idade);\ngetchar(); // Consome o '\\n'\n</code></pre>"},{"location":"c/entrada_saida/#funcao-sscanf","title":"Fun\u00e7\u00e3o <code>sscanf</code>","text":"<p>A fun\u00e7\u00e3o <code>sscanf()</code> l\u00ea dados de uma string ao inv\u00e9s da entrada padr\u00e3o:</p> Uso de sscanf<pre><code>char entrada[] = \"25\";\nint idade;\nsscanf(entrada, \"%d\", &amp;idade);\nprintf(\"Idade lida: %d\\n\", idade);\n</code></pre> <p>Isso permite manipular dados sem interagir diretamente com o usu\u00e1rio. Isso \u00e9 \u00fatil quando, por exemplo, trazemos dados de um arquivo e queremos fazer o processamento formatado deles.</p>"},{"location":"c/entrada_saida/#getc-e-getchar","title":"<code>getc</code> e <code>getchar</code>","text":"<p>As fun\u00e7\u00f5es <code>scanf()</code> e <code>sscanf()</code> fazem o processamento de um fluxo de dados. Se a necessidade for consumir apenas um caracter, podemos utilizar as fun\u00e7\u00f5es <code>getc()</code> e <code>getchar()</code>.</p> Exemplo de uso de getchar()<pre><code>char c;\nprintf(\"Digite um caractere: \");\nc = getchar();\nprintf(\"Voc\u00ea digitou: %c\\n\", c);\n</code></pre> <p>A diferen\u00e7a entre essas duas fun\u00e7\u00f5es \u00e9 que a primeira pode ser usada para obter um caracter de qualquer fluxo, e n\u00e3o apenas do fluxo de entrada padr\u00e3o. \u00c9 como se <code>getchar()</code> fosse o mesmo que <code>getc(stdin)</code>.</p>"},{"location":"c/entrada_saida/#saida-de-dados","title":"Sa\u00edda de Dados","text":""},{"location":"c/entrada_saida/#funcao-printf","title":"Fun\u00e7\u00e3o <code>printf</code>","text":"<p>Tal como podemos usar <code>scanf()</code> para a entrada formatada de dados, a linguagem C oferece uma contra-parte para a sa\u00edda formatada de dados: <code>printf()</code>. \u00c9 muito dif\u00edcil escrever um programa em C que n\u00e3o use pelo menos um <code>printf()</code> em algum lugar para apresentar algum dado para o usu\u00e1rio.</p> <p>Assim como o <code>scanf()</code>, <code>printf()</code> faz uso de caracteres de formata\u00e7\u00e3o nas m\u00e1scaras. Os caracteres dispon\u00edveis podem ser consultados aqui.</p> Exemplo de uso de printf()<pre><code>int idade = 30;\nprintf(\"Idade: %d anos\\n\", idade);\n</code></pre> <p>Al\u00e9m de exibir n\u00fameros, <code>printf()</code> pode formatar strings e caracteres especiais (sequ\u00eancias de escape, que foram apresentadas anteriormente):</p> Exemplo de uso de printf()<pre><code>char nome[] = \"Carlos\";\nprintf(\"Nome: %s\\n\", nome);\nprintf(\"Caracteres especiais: Tab\\tNova linha\\n\");\n</code></pre>"},{"location":"c/entrada_saida/#putc-e-putchar","title":"<code>putc</code> e <code>putchar</code>","text":"<p>Se a necessidade for apresentar apenas um caractere, e n\u00e3o o valor de uma vari\u00e1vel num\u00e9rica ou uma cadeia de caracteres, as fun\u00e7\u00f5es <code>putc()</code> e <code>putchar()</code> podem ser utilizadas.</p> <p>Exemplo de uso de putchar()<pre><code>char c;\nc = 'A';\nputchar(c);\nputchar('\\n');\n</code></pre> A diferen\u00e7a entre essas duas fun\u00e7\u00f5es \u00e9 que a primeira pode ser usada para colocar um caracter de qualquer fluxo, e n\u00e3o apenas do fluxo de sa\u00edda padr\u00e3o. \u00c9 como se <code>putchar()</code> fosse o mesmo que <code>putc(stdout)</code>.</p> <p>Claro, aqui est\u00e1 o texto expandido com um par\u00e1grafo adicional sobre como remover espa\u00e7os antes e depois da linha lida com <code>fgets()</code> e como remover o caractere de nova linha (<code>\\n</code>) do final da linha:</p>"},{"location":"c/entrada_saida/#manipulacao-de-arquivos-em-c","title":"Manipula\u00e7\u00e3o de Arquivos em C","text":"<p>A manipula\u00e7\u00e3o de arquivos em C \u00e9 uma opera\u00e7\u00e3o fundamental que permite ao programador ler e escrever dados em arquivos. Essa capacidade \u00e9 essencial para muitas aplica\u00e7\u00f5es, desde a simples leitura de configura\u00e7\u00f5es at\u00e9 a complexa manipula\u00e7\u00e3o de dados em grandes conjuntos.</p>"},{"location":"c/entrada_saida/#abrindo-arquivos","title":"Abrindo Arquivos","text":"<p>Para abrir um arquivo em C, utiliza-se a fun\u00e7\u00e3o <code>fopen()</code>, que retorna um ponteiro para o <code>FILE</code>. Este ponteiro \u00e9 usado para realizar opera\u00e7\u00f5es no arquivo. A fun\u00e7\u00e3o <code>fopen()</code> requer dois par\u00e2metros: o nome do arquivo e o modo de abertura.</p> Exemplo de abertura de arquivo para leitura em C<pre><code>FILE *arquivo = fopen(\"dados.txt\", \"r\");\nif (arquivo == NULL) {\n    printf(\"Erro ao abrir o arquivo!\\n\");\n    return 1;\n}\n</code></pre> <p>Os modos de abertura dispon\u00edveis s\u00e3o:</p> <ul> <li><code>\"r\"</code>: Modo de leitura. O arquivo deve existir, pois n\u00e3o \u00e9 criado automaticamente.</li> <li><code>\"w\"</code>: Modo de escrita. Se o arquivo j\u00e1 existir, seu conte\u00fado ser\u00e1 sobrescrito. Caso contr\u00e1rio, um novo arquivo ser\u00e1 criado.</li> <li><code>\"a\"</code>: Modo de anexa\u00e7\u00e3o. Novos dados s\u00e3o adicionados ao final do arquivo existente. Se o arquivo n\u00e3o existir, ele ser\u00e1 criado.</li> <li><code>\"r+\"</code>: Modo de leitura e escrita. O arquivo deve existir, pois n\u00e3o \u00e9 criado automaticamente. Permite ler e escrever sem sobrescrever o conte\u00fado existente.</li> <li><code>\"w+\"</code>: Modo de leitura e escrita, criando ou apagando o conte\u00fado existente. Se o arquivo existir, seu conte\u00fado ser\u00e1 apagado. Caso contr\u00e1rio, um novo arquivo ser\u00e1 criado.</li> </ul> <p>Ap\u00f3s realizar opera\u00e7\u00f5es em um arquivo, \u00e9 essencial fech\u00e1-lo com <code>fclose()</code> para garantir a integridade dos dados e liberar recursos do sistema.</p>"},{"location":"c/entrada_saida/#leitura-com-fgets","title":"Leitura com <code>fgets</code>","text":"<p>Para ler uma linha de um arquivo, a fun\u00e7\u00e3o <code>fgets()</code> \u00e9 recomendada. Com ela \u00e9 poss\u00edvel definir tanto a quantidade m\u00e1xima de caracteres que devem ser lidos, como o fluxo de origem da leitura, que pode ser o arquivo ou o fluxo de entrada padr\u00e3o (stdin).</p> Lendo uma linha do arquivo com fgets()<pre><code>#include &lt;stdio.h&gt;\n\nint main()\n{\n  char linha[100];\n  FILE *arquivo = fopen(\"entrada.txt\", \"r\");\n\n  fgets(linha, sizeof(linha), arquivo);\n  printf(\"Linha lida: %s\", linha);\n\n  return 0;\n}\n</code></pre> <p>Ao ler uma linha com <code>fgets()</code>, \u00e9 comum que a string contenha o caractere de nova linha (<code>\\n</code>) no final. Para remover esses espa\u00e7os e o caractere de nova linha, uma estrat\u00e9gia \u00e9 substituir o \u00faltimo caracter da linha pelo caractere <code>\\0</code>, que \u00e9 o indicador de final de cadeia. Isso pode ser feito da seguinte forma:</p> Removendo o caractere de final de linha<pre><code>#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main()\n{\n  char linha[100];\n  FILE *arquivo = fopen(\"entrada.txt\", \"r\");\n\n  fgets(linha, sizeof(linha), arquivo);\n  linha[strlen(linha)-1] = '\\0';\n  printf(\"Linha lida: %s\", linha);\n\n  return 0;\n}\n</code></pre> <p>Na biblioteca de c\u00f3digos h\u00e1 uma fun\u00e7\u00e3o que pode fazer essa remo\u00e7\u00e3o de espa\u00e7os n\u00e3o s\u00f3 do final, mas do in\u00edcio da string tamb\u00e9m.</p>"},{"location":"c/entrada_saida/#escrita-com-fputs","title":"Escrita com <code>fputs</code>","text":"<p>Para escrever strings em um arquivo, a fun\u00e7\u00e3o <code>fputs()</code> \u00e9 usada. Ela n\u00e3o adiciona automaticamente um caractere de nova linha (<code>\\n</code>) ao final da string, ent\u00e3o voc\u00ea deve inclu\u00ed-lo manualmente se necess\u00e1rio.</p> Escrevendo uma linha de texto no arquivo<pre><code>#include &lt;stdio.h&gt;\n\nint main()\n{\n  FILE *arquivo = fopen(\"saida.txt\", \"w\");\n  fputs(\"Linha de exemplo\\n\", arquivo);\n  fclose(arquivo);\n\n  return 0;\n}\n</code></pre>"},{"location":"c/entrada_saida/#redirecionamento-de-fluxos","title":"Redirecionamento de Fluxos","text":"<p>Os fluxos padr\u00f5es podem ser redirecionados via linha de comando, permitindo que os dados sejam lidos ou escritos a partir de diferentes fontes.</p> <p>Por exemplo, um programa que l\u00ea um n\u00famero e imprime o dobro dele pode obter o n\u00famero que deve ser multiplicado por 2 de um arquivo chamado <code>entrada.txt</code>.</p> C\u00f3digo fonteConte\u00fado de <code>entrada.txt</code>Execu\u00e7\u00e3o dobro.c<pre><code>#include &lt;stdio.h&gt;\n\nint main()\n{\n  int num;\n  printf(\"Digite um n\u00famero: \");\n  scanf(\"%d\", &amp;num);\n  printf(\"O dobro de %d \u00e9 %d\\n\", num, num * 2);\n\n  return 0;\n}\n</code></pre> <pre><code>4\n</code></pre> <pre><code>C:\\Users\\danie&gt;dobro.exe &lt; entrada.txt\nDigite um n\u00famero: \nO dobro de 4 \u00e9 8\n\nC:\\Users\\danie&gt;\n</code></pre> <p>O programa ler\u00e1 os dados do arquivo <code>entrada.txt</code> em vez do teclado.</p> <p>A mesma id\u00e9ia pode ser aplicada ao fluxo de sa\u00edda, redirecionando-o para um arquivo.  Nesse caso, nada seria impresso na tela, mas sim redirecionado para o arquivo em quest\u00e3o.</p> <pre><code>C:\\Users\\danie&gt;programa.exe &gt; saida.txt\n\nC:\\Users\\danie&gt;\n</code></pre> <p>Isso salva a sa\u00edda no arquivo <code>saida.txt</code>, ao inv\u00e9s de exibi-la na tela.</p> <p>Os fluxos de entrada e de sa\u00edda podem ser redirecionados simultaneamente, como por exemplo em:</p> <pre><code>C:\\Users\\danie&gt;programa.exe &lt; entrada.txt &gt; saida.txt\n\nC:\\Users\\danie&gt;\n</code></pre>"},{"location":"c/expressoes/","title":"Express\u00f5es e operadores","text":"<p>Nas subse\u00e7\u00f5es a seguir, letras min\u00fasculas como <code>a</code> e <code>b</code> representam valores literais ou nomes de vari\u00e1veis, o que for apropriado no contexto. Ao avaliar uma express\u00e3o, os seguintes operadores podem ser usados. <code>T</code> indica um tipo de dados.</p>"},{"location":"c/expressoes/#expressoes-e-operadores-aritmeticos","title":"Express\u00f5es e operadores aritm\u00e9ticos","text":"<p>Uma express\u00e3o aritm\u00e9tica vai ser constru\u00edda a partir de operadores aritm\u00e9ticos e vari\u00e1veis ou constantes num\u00e9ricas.</p> <pre><code>graph LR\n  defoperando ==&gt; j2 ==&gt; operadoru ==&gt; j3 ==&gt; constante ==&gt; j4 ==&gt; finaloperando\n  j3 ==&gt; variavel ==&gt; j4\n  j2 ==&gt; j3\n\n  expressao ==&gt; operando1 ==&gt; j0 ==&gt; operadorb ==&gt; operando2 ==&gt; j1 ==&gt; finalexpressao\n  j1 ==&gt; j0\n\n  classDef rotulo fill:#ffffff,stroke:#ffffff\n  class expressao,finalexpressao,defoperando,finaloperando rotulo\n\n\n  expressao@{ label: \"Express\u00e3o&lt;br /&gt;aritm\u00e9tica\"}\n  operando1@{ shape: terminal, label: \"Operando\"}\n  operando2@{ shape: terminal, label: \"Operando\"}\n  operadorb@{ shape: terminal, label: \"Operador aritm\u00e9tico&lt;br /&gt;bin\u00e1rio\"}\n  operadoru@{ shape: terminal, label: \"Operador aritm\u00e9tico&lt;br /&gt;un\u00e1rio\"}\n  finalexpressao@{label: \" \"}\n  j0@{ shape: sm-circ }\n  j1@{ shape: sm-circ }\n  j2@{ shape: sm-circ }\n  j3@{ shape: sm-circ }\n  j4@{ shape: sm-circ }\n  defoperando@{ label: \"Operando\" }\n  finaloperando@{ label: \" \" }\n  constante@{ shape: terminal, label: \"Constante&lt;br /&gt;num\u00e9rica\"}\n  variavel@{ shape: terminal, label: \"Vari\u00e1vel&lt;br /&gt;num\u00e9rica\"}</code></pre> Operador Sintaxe Exemplo e/ou observa\u00e7\u00f5es Adi\u00e7\u00e3o <code>a + b</code> Subtra\u00e7\u00e3o <code>a - b</code> Mais un\u00e1rio <code>+a</code> Menos un\u00e1rio (inverso aditivo) <code>-a</code> Multiplica\u00e7\u00e3o <code>a * b</code> O produto ser\u00e1 do tipo com maior precis\u00e3o entre os fatores Divis\u00e3o <code>a / b</code> O quociente ser\u00e1 do tipo com maior precis\u00e3o entre o divisor e o dividendo M\u00f3dulo <code>a % b</code> Resto da divis\u00e3o de <code>a</code> por <code>b</code> Pr\u00e9-incremento <code>++a</code> Incrementa de um o valor de <code>a</code>, e depois utiliza o valor P\u00f3s-incremento <code>a++</code> Utiliza o valor de <code>a</code>, e depois incrementa de um o valor Pr\u00e9-decremento <code>--a</code> Decrementa de um o valor de <code>a</code>, e depois utiliza o valor P\u00f3s-decremento <code>a--</code> Utiliza o valor de <code>a</code>, e depois decrementa de um o valor <p>A diferen\u00e7a entre o pr\u00e9-incremento/decremento e o p\u00f3s-incremento/decremento pode ser visto abaixo</p> Pr\u00e9-incrementoResultado pr\u00e9-incrementoP\u00f3s-incrementoResultado p\u00f3s-incremento <pre><code>int main()\n{\n  int a;\n  a = 5\n  printf(\"%d\\n\", a);\n  printf(\"%d\\n\", ++a);\n  printf(\"%d\\n\", a);\n}\n</code></pre> <pre><code>5\n6\n6\n</code></pre> <pre><code>int main()\n{\n  int a;\n  a = 5\n  printf(\"%d\\n\", a);\n  printf(\"%d\\n\", a++);\n  printf(\"%d\\n\", a);\n}\n</code></pre> <pre><code>5\n5\n6\n</code></pre> <p>Quando os operandos s\u00e3o de tipos diferentes, mas compat\u00edveis, o C faz uma convers\u00e3o de tipo impl\u00edcita, tamb\u00e9m conhecida como coer\u00e7\u00e3o ou type juggling. Nesse caso, dados de um ou mais subtipos podem ser convertidos em um supertipo se necess\u00e1rio.  Por exemplo, se um <code>int</code> for adicionado a um <code>float</code>, o <code>int</code> \u00e9 implicitamente convertido em <code>float</code> e o resultado ser\u00e1 do tipo <code>float</code>.</p> <pre><code>flowchart TD\n  subgraph s1 [Tipos inteiros]\n    direction RL\n    A[int] --&gt; B[unsigned int] --&gt; C[long int] --&gt; D[unsigned&lt;br /&gt;long int] --&gt; E[long long&lt;br /&gt;int] --&gt; F[unsigned long&lt;br /&gt;long int] \n  end\n  subgraph s2 [Tipos reais]\n    direction RL\n    G[float] --&gt; H[double] --&gt; I[long double]\n  end\n  s1 --&gt; s2</code></pre> <p>Veja bem, preste aten\u00e7\u00e3o!</p> <p>A convers\u00e3o impl\u00edcita s\u00f3 acontece quando os tipos s\u00e3o diferentes. Ent\u00e3o, ao efetuar a divis\u00e3o de um inteiro por outro, o resultado ser\u00e1 inteiro, a menos que seja feita a convers\u00e3o expl\u00edcita do dividendo ou do divisor para <code>float</code> ou <code>double</code>. <code>5/2</code> n\u00e3o \u00e9 <code>2.5</code>, e sim <code>2</code>, pois <code>5</code> e <code>2</code> s\u00e3o do mesmo tipo (<code>int</code>), ent\u00e3o o resultado ser\u00e1, tamb\u00e9m, do mesmo tipo (<code>int</code>).  Para que seja <code>2.5</code>, \u00e9 preciso fazer <code>5.0/2</code> ou <code>5/2.0</code>.</p> <p>N\u00e3o lembrar desse pequeno detalhe pode acabar produzindo resultados n\u00e3o esperados durante a execu\u00e7\u00e3o dos programas.</p> <p>Vai dar ruim!</p> C<pre><code>float r;\nint a, b;\n\na = 5; b = 2;\nr = a / b;     // r = 5/2\n</code></pre> <p>Vai dar bom!</p> C<pre><code>float r;\nint a, b;\n\na = 5; b = 2;\nr = (float)a / b;     // r = 5.0/2\n</code></pre>"},{"location":"c/expressoes/#operadores-logicos","title":"Operadores l\u00f3gicos","text":"<pre><code>graph TD\n  expressao ==&gt; j0 ==&gt; operando1 ==&gt; operadorl ==&gt; j0\n  operando1 ==&gt; finalexpressao\n\n  defoperando ==&gt; j1 ==&gt; j2\n  j1 ==&gt; nao ==&gt; j2\n  j2 ==&gt; constantel ==&gt; j3\n  j2 ==&gt; variavell ==&gt; j3\n  j2 ==&gt; expressaor ==&gt; j3\n  j3 ==&gt; finaloperando\n\n  classDef rotulo fill:#ffffff,stroke:#ffffff\n  class expressao,finalexpressao,defoperando,finaloperando rotulo\n\n  expressao@{ label: \"Express\u00e3o&lt;br /&gt;l\u00f3gica\"}\n  nao@{ shape: terminal, label: \"**N\u00c3O**\"}\n  operando1@{ shape: terminal, label: \"Operando&lt;br /&gt;l\u00f3gico\"}\n  operadorl@{ shape: terminal, label: \"Operador&lt;br /&gt;l\u00f3gico\"}\n  finalexpressao@{label: \" \"}\n  j0@{ shape: sm-circ }\n  j1@{ shape: sm-circ }\n  j2@{ shape: sm-circ }\n  j3@{ shape: sm-circ }\n  defoperando@{ label: \"Operando&lt;br /&gt;l\u00f3gico\" }\n  finaloperando@{ label: \" \" }\n  constantel@{ shape: terminal, label: \"Constante&lt;br /&gt;l\u00f3gica\"}\n  variavell@{ shape: terminal, label: \"Vari\u00e1vel&lt;br /&gt;l\u00f3gica\"}\n  expressaor@{ shape: terminal, label: \"Express\u00e3o&lt;br /&gt;relacional\"}\n</code></pre> <p>Operadores l\u00f3gicos retornam um valor do tipo <code>bool</code>, indicando o resultado da opera\u00e7\u00e3o.</p> Operador Sintaxe Exemplo e/ou observa\u00e7\u00f5es NOT (\\(\\lnot\\)) <code>!a</code> Nega o valor de <code>a</code> AND (\\(\\land\\)) <code>a &amp;&amp; b</code> Ser\u00e1 verdadeiro apenas quando <code>a</code> e <code>b</code> forem verdadeiros; em todos os outros casos, falso OR (\\(\\lor\\)) <code>a || b</code> Ser\u00e1 falso apenas quando <code>a</code> e <code>b</code> forem falsos; em todos os outros casos, verdadeiro <p> a AND b Verdadeiro Verdadeiro Verdadeiro Verdadeiro Falso Falso Falso Falso Verdadeiro Falso Falso Falso <p> a OR b Verdadeiro Verdadeiro Verdadeiro Verdadeiro Verdadeiro Falso Falso Verdadeiro Verdadeiro Falso Falso Falso <p> NOT a Falso Verdadeiro Verdadeiro Falso <p></p> <p>Em C, a avalia\u00e7\u00e3o de operadores l\u00f3gicos como <code>&amp;&amp;</code> (E l\u00f3gico) e <code>||</code> (OU l\u00f3gico) segue uma estrat\u00e9gia conhecida como \"curto-circuito\". Esse mecanismo otimiza a execu\u00e7\u00e3o do c\u00f3digo ao interromper a avalia\u00e7\u00e3o de uma express\u00e3o l\u00f3gica assim que o resultado final pode ser determinado de forma inequ\u00edvoca.</p> <p>No caso do operador <code>&amp;&amp;</code>, a avalia\u00e7\u00e3o ocorre da esquerda para a direita. Se o primeiro operando for avaliado como falso, o resultado final da express\u00e3o ser\u00e1 necessariamente falso, independentemente do valor do segundo operando. Portanto, o segundo operando n\u00e3o \u00e9 avaliado, evitando c\u00e1lculos desnecess\u00e1rios e poss\u00edveis efeitos colaterais. Um exemplo pr\u00e1tico seria a verifica\u00e7\u00e3o de um ponteiro antes de acessar a mem\u00f3ria que ele aponta: <code>if (ptr != NULL &amp;&amp; *ptr == 10)</code>. Se <code>ptr</code> for <code>NULL</code>, a segunda parte da condi\u00e7\u00e3o (<code>*ptr == 10</code>) n\u00e3o ser\u00e1 avaliada, evitando um erro de acesso \u00e0 mem\u00f3ria inv\u00e1lida.</p> <p>De forma semelhante, o operador <code>||</code> tamb\u00e9m utiliza o curto-circuito. Se o primeiro operando for avaliado como verdadeiro, o resultado final da express\u00e3o ser\u00e1 necessariamente verdadeiro, independentemente do valor do segundo operando. Logo, o segundo operando n\u00e3o \u00e9 avaliado. Um exemplo comum \u00e9 a verifica\u00e7\u00e3o de m\u00faltiplas condi\u00e7\u00f5es alternativas: <code>if (opcao == 'a' || opcao == 'b' || opcao == 'c')</code>. Se <code>opcao</code> for igual a <code>a</code>, as outras compara\u00e7\u00f5es n\u00e3o ser\u00e3o realizadas.</p> <p>Essa caracter\u00edstica dos operadores l\u00f3gicos em C n\u00e3o apenas melhora a efici\u00eancia do c\u00f3digo, mas tamb\u00e9m permite escrever express\u00f5es mais seguras, prevenindo erros que poderiam ocorrer se todos os operandos fossem avaliados indiscriminadamente.</p>"},{"location":"c/expressoes/#operadores-relacionais","title":"Operadores relacionais","text":"<pre><code>graph LR\n  expressaor ==&gt; j0 ==&gt; expressaoa1 ==&gt; operadorr1 ==&gt; expressaoa2 ==&gt; j1 ==&gt; finalexpressaor\n  j0 ==&gt; expressaol1 ==&gt; operadorr1 ==&gt; expressaol2 ==&gt; j1\n\n  expressaol ==&gt; j2 ==&gt; constantec ==&gt; j3 ==&gt; finalexpressaol\n  j2 ==&gt; variavelc ==&gt; j3\n\n\n  classDef rotulo fill:#ffffff,stroke:#ffffff\n  class expressaor,expressaol,finalexpressaor,finalexpressaol rotulo\n\n\n  expressaor@{ label: \"Express\u00e3o&lt;br /&gt;relacional\"}\n  finalexpressaor@{label: \" \"}\n  expressaol@{ label: \"Express\u00e3o&lt;br /&gt;literal\"}\n  finalexpressaol@{label: \" \"}\n  expressaoa1@{ shape: terminal, label: \"Express\u00e3o&lt;br /&gt;aritm\u00e9tica\"}\n  expressaoa2@{ shape: terminal, label: \"Express\u00e3o&lt;br /&gt;aritm\u00e9tica\"}\n  expressaol1@{ shape: terminal, label: \"Express\u00e3o&lt;br /&gt;literal\"}\n  expressaol2@{ shape: terminal, label: \"Express\u00e3o&lt;br /&gt;literal\"}\n  operadorr1@{ shape: terminal, label: \"Operador&lt;br /&gt;relacional\"}\n  j0@{ shape: sm-circ }\n  j1@{ shape: sm-circ }\n  j2@{ shape: sm-circ }\n  j3@{ shape: sm-circ }\n  constantec@{ shape: terminal, label: \"Constante&lt;br /&gt;caracter\"}\n  variavelc@{ shape: terminal, label: \"Vari\u00e1vel&lt;br /&gt;caracter\"}</code></pre> <p>Veja bem, preste aten\u00e7\u00e3o!</p> <p>Em C, o operador de igualdade \u00e9 um sinal de igual duplo (<code>==</code>).  O sinal de igual simples \u00e9 utilizado para atribui\u00e7\u00e3o, como vamos ver em breve</p> <p>Os operadores relacionais retornam um valor do tipo <code>bool</code> que indica se a rela\u00e7\u00e3o \u00e9 verdadeira ou falsa.    </p> <p> Opera\u00e7\u00e3o Sintaxe Exemplo e/ou observa\u00e7\u00f5es Igual a <code>a == b</code> N\u00e3o igual a(diferente de) <code>a != b</code> Maior que <code>a &gt; b</code> Menor que <code>a &lt; b</code> Maior ou igual a <code>a &gt;= b</code> Menor ou igual a <code>a &lt;= b</code> <p></p> <p>Veja bem, preste aten\u00e7\u00e3o!</p> <p>Se voc\u00ea quer saber se um n\u00famero est\u00e1 entre outros dois, a express\u00e3o usada na matem\u00e1tica (\\(10 &lt; n &lt; 50\\)) n\u00e3o vai funcionar em C. Se voc\u00ea usar essa express\u00e3o, o compilador vai avaliar a primeira parte (\\(10 &lt; n\\)) e, o resultado dessa compara\u00e7\u00e3o ser\u00e1 comparado com 50.</p> <p>A forma correta envolve o operador AND (<code>&amp;&amp;</code>): <code>10 &lt; n &amp;&amp; n &lt; 50</code>.</p>"},{"location":"c/expressoes/#operadores-de-bit","title":"Operadores de bit","text":"<p>Voc\u00ea sabia?</p> <p>Os operadores de deslocamento podem ser usados para efetuar multiplica\u00e7\u00e3o e divis\u00e3o.</p> <p>Suponha que temos um n\u00famero inteiro <code>a = 5</code>. Em representa\u00e7\u00e3o bin\u00e1ria, 5 \u00e9 <code>00000101</code>. Agora, vamos realizar um deslocamento \u00e0 esquerda de 2 bits (<code>a &lt;&lt; 2</code>). O que teremos \u00e9 os bits de <code>a</code> \"empurrados\" 2 posi\u00e7\u00f5es para a esquerda, resultando em <code>00010100</code>. Os bits vazios \u00e0 direita s\u00e3o preenchidos com zeros. Como <code>00010100</code> em bin\u00e1rio corresponde a 20 em decimal, <code>5 &lt;&lt; 2</code> resulta em 20.</p> <p>Uso mesmo n\u00famero a = 5 (bin\u00e1rio <code>00000101</code>), um deslocamento \u00e0 direita de 1 bit (<code>a &gt;&gt; 1</code>) resulta em <code>0000010</code>. Para n\u00fameros sem sinal (<code>unsigned</code>), o bit vazio \u00e0 esquerda \u00e9 preenchido com zero. Para n\u00fameros com sinal (<code>signed</code>), o bit mais significativo (bit de sinal) \u00e9 replicado. Como <code>0000010</code> em bin\u00e1rio \u00e9 2 em decimal, temos que <code>5 &gt;&gt; 1</code> resulta em 2.</p> <p>Resumo:</p> <ul> <li><code>a &lt;&lt; b</code>: Multiplica <code>a</code> por \\(2^b\\).</li> <li><code>a &gt;&gt; b</code>: Divide <code>a</code> por \\(2^b\\) (com comportamento diferente para n\u00fameros negativos).</li> </ul> <p>Os operadores de bit operam sobre os valores bin\u00e1rios da vari\u00e1veis.</p> Opera\u00e7\u00e3o Sintaxe Exemplo e/ou observa\u00e7\u00f5es NOT <code>~a</code> Inverte os bits de <code>a</code> AND <code>a &amp; b</code> Efetua a opera\u00e7\u00e3o AND bit-a-bit sobre os operandos <code>a</code> e <code>b</code> OR <code>a | b</code> Efetua a opera\u00e7\u00e3o OR bit-a-bit sobre os operandos <code>a</code> e <code>b</code> XOR <code>a ^ b</code> Efetua a opera\u00e7\u00e3o OR bit-a-bit sobre os operandos <code>a</code> e <code>b</code> Deslocamento \u00e0 esquerda <code>a &lt;&lt; b</code> Desloca os bits de <code>a</code> para a esquerda por <code>b</code> posi\u00e7\u00f5es. Os bits \u00e0 direita s\u00e3o preenchidos com zeros Deslocamento \u00e0 direita <code>a &gt;&gt; b</code> Desloca os bits de <code>a</code> para a direita por <code>b</code> posi\u00e7\u00f5es. O comportamento dos bits \u00e0 esquerda depende do tipo de <code>a</code>: se <code>a</code> for <code>signed</code>, o bit de sinal \u00e9 replicado (deslocamento aritm\u00e9tico); se <code>a</code> for <code>unsigned</code>, os bits \u00e0 esquerda s\u00e3o preenchidos com zeros (deslocamento l\u00f3gico) <p>O operador XOR (OU-exclusivo) retorna verdadeiro apenas quando <code>a != b</code>.</p> <p> a XOR b Verdadeiro Falso Verdadeiro Verdadeiro Verdadeiro Falso Falso Verdadeiro Verdadeiro Falso Falso Falso <p></p>"},{"location":"c/expressoes/#operadores-de-atribuicao","title":"Operadores de atribui\u00e7\u00e3o","text":"<pre><code>graph LR\n  atrib1 ==&gt; identificador ==&gt; seta ==&gt; expressao ==&gt; pontovirgula ==&gt; finalatrib1\n\n  defexpressao ==&gt; j0 ==&gt; expressaoa ==&gt; j1 ==&gt; finalexpressao\n  j0 ==&gt; expressaol ==&gt; j1\n  j0 ==&gt; expressaolit ==&gt; j1\n\n  classDef rotulo fill:#ffffff,stroke:#ffffff\n  class atrib1,finalatrib1,defexpressao,finalexpressao rotulo\n\n  atrib1@{ label: \"Atribui\u00e7\u00e3o\"}\n  finalatrib1@{ label: \" \"}\n  defexpressao@{ label: \"Express\u00e3o\"}\n  finalexpressao@{label: \" \"}\n\n  expressao@{ shape: terminal, label: \"Express\u00e3o\"}\n  expressaoa@{ shape: terminal, label: \"Express\u00e3o&lt;br /&gt;aritm\u00e9tica\"}\n  expressaol@{ shape: terminal, label: \"Express\u00e3o&lt;br /&gt;l\u00f3gica\"}\n  expressaolit@{ shape: terminal, label: \"Express\u00e3o&lt;br /&gt;literal\"}\n  j0@{ shape: sm-circ }\n  j1@{ shape: sm-circ }\n  identificador@{ shape: terminal, label: \"**Identificador**\" }\n  seta@{ shape: circle, label: \"**&amp;larr;**\" }\n  pontovirgula@{ shape: circle, label: \"**;**\" }</code></pre> <p>Para operadores combinados na forma \\(a~ \\circledcirc= b\\), a opera\u00e7\u00e3o equivalente \u00e9 \\(a = a \\circledcirc b\\).</p> Opera\u00e7\u00e3o Sintaxe Exemplo e/ou observa\u00e7\u00f5es Atribui\u00e7\u00e3o <code>a = b</code> Atribui o valor de <code>b</code> \u00e0 vari\u00e1vel <code>a</code> Adi\u00e7\u00e3o combinada <code>a += b</code> Equivalente a <code>a = a + b</code> Subtra\u00e7\u00e3o combinada <code>a -= b</code> Equivalente a <code>a = a - b</code> Multiplica\u00e7\u00e3o combinada <code>a *= b</code> Equivalente a <code>a = a * b</code> Divis\u00e3o combinada <code>a /= b</code> Equivalente a <code>a = a / b</code> M\u00f3dulo combinado <code>a %= b</code> Equivalente a <code>a = a % b</code> (resto da divis\u00e3o) AND bit-a-bit combinado <code>a &amp;= b</code> Equivalente a <code>a = a &amp; b</code> OR bit-a-bit combinado <code>a |= b</code> Equivalente a <code>a = a | b</code> XOR bit-a-bit combinado <code>a ^= b</code> Equivalente a <code>a = a ^ b</code> Deslocamento \u00e0 esquerda combinado <code>a &lt;&lt;= b</code> Equivalente a <code>a = a &lt;&lt; b</code> Deslocamento \u00e0 direita combinado <code>a &gt;&gt;= b</code> Equivalente a <code>a = a &gt;&gt; b</code>"},{"location":"c/expressoes/#membros-e-ponteiros","title":"Membros e ponteiros","text":"Opera\u00e7\u00e3o Sintaxe Exemplo e/ou observa\u00e7\u00f5es Indire\u00e7\u00e3o <code>*a</code> Objeto apontado por <code>a</code> Endere\u00e7o de <code>&amp;a</code> Endere\u00e7o de mem\u00f3ria do objeto <code>a</code> Dereferenciamento de estrutura <code>a-&gt;b</code> Membro <code>b</code> do objeto apontado por <code>a</code> Referenciamento de estrutura <code>a.b</code> Membro <code>b</code> do objeto <code>a</code>"},{"location":"c/expressoes/#outros","title":"Outros","text":"Opera\u00e7\u00e3o Sintaxe Exemplo e/ou observa\u00e7\u00f5es Tamanho de <code>sizeof a</code><code>sizeof (T)</code> Retorna o tamanho do objeto <code>a</code> ou do tipo <code>T</code> em n\u00famero de <code>chars</code>. Ou seja, <code>sizeof (char)</code> \u00e9 sempre igual a 1. Como em muitos casos o tamanho do caracter (<code>sizeof (char)</code>) \u00e9 igual a 8 bits, ou seja, 1 byte, <code>sizeof (T)</code> retorna o tamanho em bytes ocupado por uma vari\u00e1vel do tipo <code>T</code> Convers\u00e3o expl\u00edcita <code>(T)a</code> Converte o valor de <code>a</code> para o tipo <code>T</code>"},{"location":"c/expressoes/#precedencia-dos-operadores","title":"Preced\u00eancia dos operadores","text":"<p>Da hora de avaliar uma express\u00e3o, seja ela aritm\u00e9tica, de bit ou l\u00f3gica, os diversos operadores presentes precisam ser avaliados na ordem correta de preced\u00eancia. J\u00e1 fazemos isso quando n\u00f3s mesmos resolvemos uma express\u00e3o aritm\u00e9tica no papel: primeiro as pot\u00eancias e ra\u00edzes, depois os produtos e quocientes, e assim sucessivamente.</p> <p>A tabela abaixo mostra os operadores ordenados de forma decrescente de prioridade (primeiro os do in\u00edcio, depois os do final), se possuem um (un\u00e1rios) ou dois (bin\u00e1rios) operandos, e se s\u00e3o avaliados da esquerda para a direita (\u2192) ou da direita para a esquerda (\u2190).</p> Operador Operandos Sentido da avalia\u00e7\u00e3o <code>() [] -&gt; .</code> 2 \u2192 <code>- ++ -- ! &amp; * ~ (tipo) sizeof</code> 1 \u2190 <code>* / %</code> 2 \u2192 <code>+ -</code> 2 \u2192 <code>&lt;&lt;  &gt;&gt;</code> 2 \u2192 <code>&lt; &lt;= &gt;= &gt;</code> 2 \u2192 <code>== !=</code> 2 \u2192 <code>&amp;</code> 2 \u2192 <code>^</code> 2 \u2192 <code>|</code> 2 \u2192 <code>&amp;&amp;</code> 2 \u2192 <code>||</code> 2 \u2192 <code>? :</code> 2 \u2190 <code>=  op\u200a=</code> 2 \u2190 <p>Na \u00faltima linha <code>op=</code> representa os operadores na forma \\(a~ \\circledcirc= b\\) listados em se\u00e7\u00e3o anterior.</p>"},{"location":"c/fluxo/","title":"Controle de fluxo","text":"<p>As estruturas de controle de fluxo s\u00e3o componentes fundamentais em qualquer linguagem de programa\u00e7\u00e3o, incluindo C. Elas permitem que o programador defina caminhos alternativos de execu\u00e7\u00e3o, possibilitando que um programa tome decis\u00f5es e execute diferentes blocos de c\u00f3digo com base em condi\u00e7\u00f5es espec\u00edficas. Sem estas estruturas, os programas seriam executados de forma linear e previs\u00edvel, do primeiro ao \u00faltimo comando, o que limitaria drasticamente sua utilidade e aplicabilidade.</p> <p>A capacidade de alterar o fluxo de execu\u00e7\u00e3o baseado em valores de vari\u00e1veis, entradas do usu\u00e1rio ou resultados de opera\u00e7\u00f5es \u00e9 o que torna os programas verdadeiramente din\u00e2micos e capazes de resolver problemas complexos. Em ess\u00eancia, as estruturas de controle de fluxo s\u00e3o o que permitem que os programas \"pensem\" e se adaptem a diferentes situa\u00e7\u00f5es, aproximando-os do racioc\u00ednio humano.</p>"},{"location":"c/fluxo/#declaracoes-e-blocos","title":"Declara\u00e7\u00f5es e Blocos","text":""},{"location":"c/fluxo/#declaracoes-em-c","title":"Declara\u00e7\u00f5es em C","text":"<p>Em C, uma declara\u00e7\u00e3o \u00e9 uma instru\u00e7\u00e3o completa que o compilador pode executar. Cada declara\u00e7\u00e3o termina com um ponto e v\u00edrgula (<code>;</code>). \u00c9 importante notar que nem toda linha de c\u00f3digo termina com ponto e v\u00edrgula, mas toda declara\u00e7\u00e3o sim. Por exemplo, diretivas de pr\u00e9-processador como <code>#include</code> ou <code>#define</code> n\u00e3o s\u00e3o consideradas declara\u00e7\u00f5es e, portanto, n\u00e3o terminam com ponto e v\u00edrgula.</p> Exemplos de declara\u00e7\u00f5es<pre><code>int x = 10;                 // Declara\u00e7\u00e3o de vari\u00e1vel\nprintf(\"Hello, world!\\n\");  // Chamada de fun\u00e7\u00e3o\nreturn 0;                   // Instru\u00e7\u00e3o de retorno\n</code></pre>"},{"location":"c/fluxo/#blocos-e-escopo","title":"Blocos e Escopo","text":"<p>Em C, uma declara\u00e7\u00e3o composta \u00e9 chamada de bloco. Os blocos s\u00e3o delimitados por chaves (<code>{</code> e <code>}</code>) e podem conter m\u00faltiplas declara\u00e7\u00f5es. Eles s\u00e3o fundamentais para agrupar instru\u00e7\u00f5es que devem ser tratadas como uma unidade, especialmente em estruturas de controle.</p> <p>Uma caracter\u00edstica importante dos blocos \u00e9 que eles definem um escopo para vari\u00e1veis. O escopo determina a visibilidade e o tempo de vida de uma vari\u00e1vel, como j\u00e1 discutimos anteriormente. Vari\u00e1veis declaradas dentro de um bloco s\u00f3 s\u00e3o acess\u00edveis dentro do pr\u00f3prio bloco e em blocos declarados dentro dele. Quando o fluxo de execu\u00e7\u00e3o deixa o o bloco, as vari\u00e1veis declaradas dentro do bloco s\u00e3o destru\u00eddas.</p> <p>Os blocos podem ser aninhados, criando uma hierarquia de escopos. Vari\u00e1veis declaradas em blocos externos s\u00e3o acess\u00edveis em blocos internos, mas o inverso n\u00e3o \u00e9 verdadeiro.</p> <p>Veja o exemplo abaixo:</p> Exemplo de defini\u00e7\u00e3o bloco e de escopo de vari\u00e1vel<pre><code>#include \n\nint main() {\n    int x = 10;  // Vari\u00e1vel no escopo externo\n\n    {\n        int y = 20;  // Vari\u00e1vel no escopo interno\n        printf(\"Dentro do bloco interno: x = %d, y = %d\\n\", x, y);\n\n        {\n            int z = 30;  // Vari\u00e1vel em um bloco ainda mais interno\n            printf(\"No bloco mais interno: x = %d, y = %d, z = %d\\n\", x, y, z);\n        }\n\n        // z n\u00e3o \u00e9 acess\u00edvel aqui\n        printf(\"De volta ao bloco interno: x = %d, y = %d\\n\", x, y);\n    }\n\n    // y n\u00e3o \u00e9 acess\u00edvel aqui\n    printf(\"No bloco externo: x = %d\\n\", x);\n\n    return 0;\n}\n</code></pre> <p>Neste exemplo, a vari\u00e1vel <code>x</code> \u00e9 acess\u00edvel em todos os blocos, <code>y</code> \u00e9 acess\u00edvel apenas no bloco intermedi\u00e1rio e no mais interno, e <code>z</code> \u00e9 acess\u00edvel apenas no bloco mais interno.</p>"},{"location":"c/fluxo/#estruturas-condicionais","title":"Estruturas Condicionais","text":"<p>As estruturas condicionais permitem que um programa execute diferentes blocos de c\u00f3digo dependendo de condi\u00e7\u00f5es espec\u00edficas. Em C, existem principalmente tr\u00eas formas de implementar decis\u00f5es: <code>if else</code>, operador tern\u00e1rio e <code>switch case</code>.</p>"},{"location":"c/fluxo/#estrutura-if-else","title":"Estrutura <code>if-else</code>","text":"<p>A forma mais simples da estrutura <code>if</code> \u00e9:</p> <pre><code>if (condi\u00e7\u00e3o) {\n    // bloco de c\u00f3digo a ser executado se a condi\u00e7\u00e3o for verdadeira\n}\n</code></pre> <p>Se a condi\u00e7\u00e3o for avaliada como verdadeira (qualquer valor diferente de zero, ou <code>true</code>), o bloco de c\u00f3digo dentro das chaves ser\u00e1 executado. Se a condi\u00e7\u00e3o for falsa (zero ou <code>false</code>), o bloco ser\u00e1 ignorado.</p> <p>Note</p> <p>A condi\u00e7\u00e3o pode ser qualquer express\u00e3o l\u00f3gica ou relacional.</p> <p>A estrutura <code>if else</code> estende essa l\u00f3gica, permitindo especificar um bloco alternativo para ser executado quando a condi\u00e7\u00e3o \u00e9 falsa:</p> <pre><code>if (condi\u00e7\u00e3o) {\n    // bloco de c\u00f3digo a ser executado se a condi\u00e7\u00e3o for verdadeira\n} else {\n    // bloco de c\u00f3digo a ser executado se a condi\u00e7\u00e3o for falsa\n}\n</code></pre> <p>Os blocos <code>if</code> podem ser aninhados, permitindo criar l\u00f3gicas de decis\u00e3o mais complexas:</p> <pre><code>if (condi\u00e7\u00e3o1) {\n    // c\u00f3digo a ser executado se condi\u00e7\u00e3o1 for verdadeira\n    if (condi\u00e7\u00e3o2) {\n        // c\u00f3digo a ser executado se condi\u00e7\u00e3o1 e condi\u00e7\u00e3o2 forem verdadeiras\n    } else {\n        // c\u00f3digo a ser executado se condi\u00e7\u00e3o1 for verdadeira e condi\u00e7\u00e3o2 for falsa\n    }\n} else {\n    // c\u00f3digo a ser executado se condi\u00e7\u00e3o1 for falsa\n}\n</code></pre>"},{"location":"c/fluxo/#operador-ternario","title":"Operador Tern\u00e1rio","text":"<p>O operador tern\u00e1rio (<code>? :</code>) \u00e9 uma forma concisa de expressar uma decis\u00e3o condicional. Sua sintaxe \u00e9:</p> <pre><code>condi\u00e7\u00e3o ? express\u00e3o1 : express\u00e3o2\n</code></pre> <p>Se a condi\u00e7\u00e3o for verdadeira, o valor da express\u00e3o ser\u00e1 <code>express\u00e3o1</code>; caso contr\u00e1rio, ser\u00e1 <code>express\u00e3o2</code>. Este operador \u00e9 particularmente \u00fatil para atribui\u00e7\u00f5es condicionais simples, como no exemplo abaixo</p> Exemplo de uso do operador tern\u00e1rio<pre><code>#include \n\nint main() {\n    int idade = 17;\n    char* status = (idade &gt;= 18) ? \"adulto\" : \"menor de idade\";\n\n    printf(\"Uma pessoa com %d anos \u00e9 %s.\\n\", idade, status);\n\n    // Tamb\u00e9m pode ser usado diretamente em express\u00f5es\n    printf(\"Voc\u00ea %s votar.\\n\", (idade &gt;= 16) ? \"pode\" : \"n\u00e3o pode\");\n\n    return 0;\n}\n</code></pre> <p>Neste exemplo, a vari\u00e1vel <code>status</code> recebe o valor <code>\"adulto\"</code> se a idade for maior ou igual a 18, e <code>\"menor de idade\"</code> caso contr\u00e1rio.</p>"},{"location":"c/fluxo/#estrutura-switch-case","title":"Estrutura <code>switch-case</code>","text":"<p>A estrutura <code>switch-case</code> \u00e9 uma alternativa ao uso de m\u00faltiplos <code>if else</code> quando se deseja comparar uma express\u00e3o com v\u00e1rios valores constantes. Sua sintaxe \u00e9:</p> <pre><code>switch (express\u00e3o) {\n    case constante1:\n        // c\u00f3digo a ser executado se express\u00e3o == constante1\n        break;\n    case constante2:\n        // c\u00f3digo a ser executado se express\u00e3o == constante2\n        break;\n    // ... mais casos\n    default:\n        // c\u00f3digo a ser executado se nenhum dos casos anteriores for verdadeiro\n}\n</code></pre> <p>A express\u00e3o \u00e9 avaliada uma \u00fanica vez, e seu valor \u00e9 comparado com cada uma das constantes. Se houver uma correspond\u00eancia, o c\u00f3digo associado a esse caso ser\u00e1 executado. A instru\u00e7\u00e3o <code>break</code> \u00e9 usada para sair da estrutura <code>switch</code>; sem ela, a execu\u00e7\u00e3o continuaria nos casos subsequentes, independentemente de suas constantes corresponderem ou n\u00e3o \u00e0 express\u00e3o (comportamento conhecido como \"fall-through\").</p> <p>O caso <code>default</code> \u00e9 opcional e ser\u00e1 executado apenas se nenhum dos outros casos corresponder \u00e0 express\u00e3o.</p> Exemplo de uso da estrutura `switch case`<pre><code>#include \n\nint main() {\n    int dia = 3;\n\n    switch (dia) {\n        case 1:\n            printf(\"Domingo\\n\");\n            break;\n        case 2:\n            printf(\"Segunda-feira\\n\");\n            break;\n        case 3:\n            printf(\"Ter\u00e7a-feira\\n\");\n            break;\n        case 4:\n            printf(\"Quarta-feira\\n\");\n            break;\n        case 5:\n            printf(\"Quinta-feira\\n\");\n            break;\n        case 6:\n            printf(\"Sexta-feira\\n\");\n            break;\n        case 7:\n            printf(\"S\u00e1bado\\n\");\n            break;\n        default:\n            printf(\"Dia inv\u00e1lido\\n\");\n    }\n\n    return 0;\n}\n</code></pre> <p>Neste exemplo, o programa imprime o nome do dia da semana correspondente ao valor da vari\u00e1vel <code>dia</code>. Se <code>dia</code> n\u00e3o estiver entre 1 e 7, ser\u00e1 impresso <code>\"Dia inv\u00e1lido\"</code>.</p> <p>A estrutura <code>switch case</code> difere de <code>if else</code> aninhados em dois aspectos principais:</p> <ul> <li>O <code>switch</code> avalia a express\u00e3o apenas uma vez, enquanto m\u00faltiplos <code>if else</code> avaliam cada condi\u00e7\u00e3o separadamente, e;</li> <li>O <code>switch</code> s\u00f3 pode comparar a express\u00e3o com valores constantes, enquanto <code>if else</code> pode usar qualquer express\u00e3o condicional.</li> </ul>"},{"location":"c/fluxo/#estruturas-iterativas","title":"Estruturas Iterativas","text":""},{"location":"c/fluxo/#iteracao-vs-interacao","title":"Itera\u00e7\u00e3o vs. Intera\u00e7\u00e3o","text":"<p>\u00c9 importante distinguir entre itera\u00e7\u00e3o e intera\u00e7\u00e3o. Itera\u00e7\u00e3o \u00e9 a repeti\u00e7\u00e3o de um bloco de c\u00f3digo, enquanto intera\u00e7\u00e3o \u00e9 a comunica\u00e7\u00e3o entre diferentes componentes ou entre o programa e o usu\u00e1rio. As estruturas iterativas, tamb\u00e9m conhecidas como la\u00e7os ou loops, permitem executar um bloco de c\u00f3digo repetidamente, seja um n\u00famero determinado de vezes ou at\u00e9 que uma condi\u00e7\u00e3o espec\u00edfica seja atendida.</p> <p>Em C, todas as estruturas iterativas s\u00e3o, tecnicamente, de repeti\u00e7\u00e3o indeterminada, pois dependem de uma condi\u00e7\u00e3o que pode mudar durante a execu\u00e7\u00e3o. No entanto, algumas constru\u00e7\u00f5es, como o loop <code>for</code>, s\u00e3o frequentemente usadas para simular repeti\u00e7\u00f5es determinadas.</p>"},{"location":"c/fluxo/#estrutura-for","title":"Estrutura <code>for</code>","text":"<p>A estrutura <code>for</code> \u00e9 composta por tr\u00eas partes: inicializa\u00e7\u00e3o, condi\u00e7\u00e3o e p\u00f3s-opera\u00e7\u00e3o. Sua sintaxe \u00e9:</p> <pre><code>for (inicializa\u00e7\u00e3o; condi\u00e7\u00e3o; p\u00f3s-opera\u00e7\u00e3o) {\n    // bloco de c\u00f3digo a ser repetido\n}\n</code></pre> <ul> <li>A inicializa\u00e7\u00e3o \u00e9 executada uma \u00fanica vez, antes do in\u00edcio do loop.</li> <li>A condi\u00e7\u00e3o \u00e9 avaliada antes de cada itera\u00e7\u00e3o; se for falsa, o loop termina.</li> <li>A p\u00f3s-opera\u00e7\u00e3o \u00e9 executada ap\u00f3s cada itera\u00e7\u00e3o.</li> </ul> <p>Veja o fluxograma equivalente a execu\u00e7\u00e3o da declara\u00e7\u00e3o <code>for(a; b; c) d;</code></p> <pre><code>   flowchart LR\n      A --&gt; B --&gt; C\n      C -- Sim --&gt; D --&gt; E --&gt; C\n      C -- N\u00e3o ----&gt; F\n\n      A@{ shape: stadium, label: \"In\u00edcio\" }\n      B@{ shape: process, label: \"a\" }\n      C@{ shape: question, label: \"b\" }\n      D@{ shape: process, label: \"d\" }\n      E@{ shape: process, label: \"c\" }\n      F@{ shape: stadium, label: \"Fim\" }</code></pre> <p>Embora a estrutura <code>for</code> seja tecnicamente de repeti\u00e7\u00e3o indeterminada, ela \u00e9 frequentemente usada para simular repeti\u00e7\u00f5es determinadas, como no exemplo abaixo:</p> Exemplo de uso da estrutura `for`<pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    // Loop que executa exatamente 5 vezes\n    for (int i = 0; i &lt; 5; i++) {\n        printf(\"Itera\u00e7\u00e3o %d\\n\", i);\n    }\n\n    return 0;\n}\n</code></pre> <p>Neste exemplo, o loop executa exatamente 5 vezes, com i assumindo os valores de 0 a 4.</p>"},{"location":"c/fluxo/#estruturas-while-e-do-while","title":"Estruturas <code>while</code> e <code>do {} while</code>","text":"<p>A estrutura <code>while</code> executa um bloco de c\u00f3digo enquanto uma condi\u00e7\u00e3o for verdadeira. Sua sintaxe \u00e9:</p> <pre><code>while (condi\u00e7\u00e3o) {\n    // bloco de c\u00f3digo a ser repetido\n}\n</code></pre> <p>A condi\u00e7\u00e3o \u00e9 avaliada antes de cada itera\u00e7\u00e3o. Se for falsa na primeira verifica\u00e7\u00e3o, o bloco n\u00e3o ser\u00e1 executado nenhuma vez.</p> Exemplo de uso da estrutura `while`<pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    int contador = 0;\n\n    while (contador &lt; 5) {\n        printf(\"Contador: %d\\n\", contador);\n        contador++;\n    }\n\n    return 0;\n}\n</code></pre> <p>A estrutura <code>do {} while</code> \u00e9 semelhante, mas garante que o bloco seja executado pelo menos uma vez, pois a condi\u00e7\u00e3o \u00e9 avaliada ap\u00f3s a execu\u00e7\u00e3o do bloco. Sua sintaxe \u00e9:</p> <pre><code>do {\n    // bloco de c\u00f3digo a ser repetido\n} while (condi\u00e7\u00e3o);\n</code></pre> Exemplo de uso da estrutura `do {} while`<pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    int contador = 0;\n\n    do {\n        printf(\"Contador: %d\\n\", contador);\n        contador++;\n    } while (contador &lt; 5);\n\n    return 0;\n}\n</code></pre>"},{"location":"c/fluxo/#equivalencia-entre-for-e-while","title":"Equival\u00eancia entre <code>for</code> e <code>while</code>","text":"<p>Qualquer loop <code>for</code> pode ser reescrito como um loop <code>while</code>. Por exemplo:</p> Equival\u00eancia entre `for` e `while`<pre><code>// Loop for\nfor (int i = 0; i &lt; 5; i++) {\n    printf(\"Itera\u00e7\u00e3o %d\\n\", i);\n}\n\n// Equivalente usando while\nint i = 0;\nwhile (i &lt; 5) {\n    printf(\"Itera\u00e7\u00e3o %d\\n\", i);\n    i++;\n}\n</code></pre> <p>Ambos os loops produzem o mesmo resultado, mas o <code>for</code> agrupa as tr\u00eas partes da itera\u00e7\u00e3o em uma \u00fanica linha, tornando o c\u00f3digo mais conciso e claro em muitos casos.</p>"},{"location":"c/fluxo/#comandos-continue-e-break","title":"Comandos <code>continue</code> e <code>break</code>","text":"<p>Os comandos <code>continue</code> e <code>break</code> s\u00e3o usados para controlar o fluxo dentro de loops.</p> <p>O comando <code>continue</code> interrompe a itera\u00e7\u00e3o atual e passa para a pr\u00f3xima. No caso de um loop <code>for</code>, a p\u00f3s-opera\u00e7\u00e3o \u00e9 executada antes da pr\u00f3xima itera\u00e7\u00e3o.</p> <p>O comando <code>break</code> termina o loop completamente, transferindo o controle para a primeira instru\u00e7\u00e3o ap\u00f3s o loop.</p> Exemplo de uso de `continue` e `break`<pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    // Exemplo de continue\n    printf(\"Exemplo de continue:\\n\");\n    for (int i = 0; i &lt; 10; i++) {\n        if (i % 2 == 0) {\n            continue;  // Pula n\u00fameros pares\n        }\n        printf(\"%d \", i);\n    }\n    printf(\"\\n\\n\");\n\n    // Exemplo de break\n    printf(\"Exemplo de break:\\n\");\n    for (int i = 0; i &lt; 10; i++) {\n        if (i == 5) {\n            break;  // Interrompe o loop quando i \u00e9 5\n        }\n        printf(\"%d \", i);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n</code></pre> <p>Neste exemplo, o primeiro loop imprime apenas os n\u00fameros \u00edmpares de 0 a 9, pois o comando <code>continue</code> pula a itera\u00e7\u00e3o quando <code>i</code> \u00e9 par. O segundo loop imprime os n\u00fameros de 0 a 4, pois o comando <code>break</code> interrompe o loop quando <code>i</code> \u00e9 igual a 5.</p> <p>Estes comandos s\u00e3o particularmente \u00fateis em situa\u00e7\u00f5es onde \u00e9 necess\u00e1rio interromper uma itera\u00e7\u00e3o ou todo o loop com base em condi\u00e7\u00f5es espec\u00edficas, evitando a necessidade de l\u00f3gicas condicionais mais complexas.</p>"},{"location":"c/funcoes/","title":"Funcoes","text":"<p>Fun\u00e7\u00f5es</p> <p>Cabe\u00e7alhos de bibliotecas padr\u00e3o ANSI C (C89)/ISO C (C90):</p> <p>assert.h ctype.h errno.h float.h limits.h locale.h math.h setjmp.h signal.h stdarg.h stddef.h stdio.h stdlib.h string.h time.h Cabe\u00e7alhos adicionados no ISO C (C94/C95):</p> <p>iso646.h wchar.h wctype.h Cabe\u00e7alhos adicionados no ISO C (C99) (suportados somente em compiladores mais novos):</p> <p>complex.h fenv.h inttypes.h stdbool.h stdint.h tgmath.h</p> <p>Usos comuns das diretivas Um uso muito comum das diretivas de compila\u00e7\u00e3o \u00e9 em arquivos-cabe\u00e7alho, que s\u00f3 precisam/devem ser inclu\u00eddos uma vez. Muitas vezes inclu\u00edmos indiretamente um arquivo v\u00e1rias vezes, pois muitos cabe\u00e7alhos dependem de outros cabe\u00e7alhos. Para evitar problemas, costuma-se envolver o arquivo inteiro com um bloco condicional que s\u00f3 ser\u00e1 compilado se o arquivo j\u00e1 n\u00e3o tiver inclu\u00eddo. Para isso usamos um s\u00edmbolo baseado no nome do arquivo. Por exemplo, se nosso arquivo se chama \"cabecalho.h\", \u00e9 comum usar um s\u00edmbolo com o nome CABECALHO_H:</p>"},{"location":"c/funcoes/#ifndef-cabecalho_h","title":"ifndef CABECALHO_H","text":""},{"location":"c/funcoes/#define-cabecalho_h","title":"define CABECALHO_H","text":"<p>. . .</p>"},{"location":"c/funcoes/#endif","title":"endif","text":"<p>Se o arquivo ainda n\u00e3o tiver sido inclu\u00eddo, ao chegar na primeira linha do arquivo, o pr\u00e9-processador n\u00e3o encontrar\u00e1 o s\u00edmbolo CABECALHO_H, e continuar\u00e1 a ler o arquivo, o que lhe far\u00e1 definir o s\u00edmbolo. Se tentarmos incluir novamente o arquivo, o pr\u00e9-processador pular\u00e1 todo o conte\u00fado pois o s\u00edmbolo j\u00e1 foi definido.</p>"},{"location":"c/historia/","title":"Introdu\u00e7\u00e3o e hist\u00f3ria","text":"<p>A linguagem de programa\u00e7\u00e3o C foi desenvolvida nos Laborat\u00f3rios Bell da AT&amp;T entre 1969 e 1973 por Dennis Ritchie, motivada pela necessidade de criar um sistema operacional port\u00e1til, o Unix, que tamb\u00e9m estava sendo desenvolvido no mesmo local.</p> <p></p> <p>Dennis Ritchie</p> <p>C evoluiu a partir da linguagem B, que por sua vez derivou da linguagem BCPL (Basic Combined Programming Language) desenvolvida por Martin Richards na d\u00e9cada de 1960. A BCPL foi criada com o objetivo de facilitar a escrita de compiladores. Ken Thompson simplificou a BCPL e criou a linguagem B, que foi utilizada nas primeiras vers\u00f5es do Unix.</p> <p>A necessidade de tipos de dados mais ricos e melhor suporte \u00e0 manipula\u00e7\u00e3o de hardware levou Ritchie a criar o C, adicionando tipos de dados, estruturas e outras funcionalidades. A primeira vers\u00e3o documentada de C surgiu em 1972.</p> <p>A portabilidade do Unix, possibilitada pelo uso de C, contribuiu significativamente para a r\u00e1pida dissemina\u00e7\u00e3o da linguagem em diversas plataformas. O livro The C Programming Language, escrito por Brian Kernighan e Dennis Ritchie, tornou-se a refer\u00eancia fundamental para programadores de C<sup>1</sup>.</p> <p> Ano Nome informal Padr\u00e3o oficial 1972 Primeira vers\u00e3o 1978 K&amp;R C 1989-90 ANSI C, C89, ISO C, C90 ANSI X3.159-1989 e ISO/IEC 9899:1990 1999 C99, C9X ISO/IEC 9899:1999 2011 C11, C1X ISO/IEC 9899:2011 2018 C17, C18 ISO/IEC 9899:2018 2024 C23, C2X ISO/IEC 9899:2024 A definir C2Y <p></p> <p>A padroniza\u00e7\u00e3o da linguagem pela ANSI (American National Standards Institute) em 1989 (ANSI C ou C89) e pela ISO (International Organization for Standardization) em 1990 (ISO C ou C90) consolidou a linguagem e garantiu sua compatibilidade entre diferentes compiladores.</p> <p>Ap\u00f3s o C90, a linguagem continuou a evoluir com novas revis\u00f5es. O C99 (ISO/IEC 9899:1999) introduziu funcionalidades como tipos de dados long long, arrays de tamanho vari\u00e1vel e suporte para n\u00fameros complexos. O C11 (ISO/IEC 9899:2011) trouxe melhorias como suporte a threads, alinhamento de mem\u00f3ria e fun\u00e7\u00f5es de an\u00e1lise de tipo gen\u00e9rico.</p> <p>O C17 (ISO/IEC 9899:2018), oficialmente conhecido como C18, foi principalmente uma corre\u00e7\u00e3o de bugs e esclarecimentos do C11, sem introduzir grandes funcionalidades novas. O C23 (ISO/IEC 9899:2023) \u00e9 o padr\u00e3o mais recente, que introduziu novos recursos, como melhorias no tipo <code>bool</code> e o atributo <code>defer</code>. Trabalhos j\u00e1 est\u00e3o sendo realizados na pr\u00f3xima vers\u00e3o do padr\u00e3o, que deve se chamar C2Y.</p> <p>Em resumo, C nasceu da necessidade de um sistema operacional port\u00e1til e evoluiu a partir de linguagens como BCPL e B, tornando-se uma linguagem fundamental na hist\u00f3ria da computa\u00e7\u00e3o devido \u00e0 sua portabilidade, efici\u00eancia e influ\u00eancia em outras linguagens. As sucessivas vers\u00f5es, desde C89 at\u00e9 C23, demonstram sua cont\u00ednua evolu\u00e7\u00e3o e adapta\u00e7\u00e3o \u00e0s necessidades da programa\u00e7\u00e3o moderna, al\u00e9m de permanecer h\u00e1 muito tempo nas primeiras posi\u00e7\u00f5es do TIOBE index que mede a popularidade das linguagens de programa\u00e7\u00e3o.</p> <ol> <li> <p>Dispon\u00edvel via Pergamum.\u00a0\u21a9</p> </li> </ol>"},{"location":"c/tiposdedados/","title":"Tipos de dados em C","text":"<p>No C, os tipos de dados definem a sem\u00e2ntica, caracter\u00edsticas de armazenamento e opera\u00e7\u00f5es permitidas para elementos de dados, sendo expressos na sintaxe atrav\u00e9s de declara\u00e7\u00f5es de vari\u00e1veis; a linguagem oferece tipos aritm\u00e9ticos b\u00e1sicos (inteiros e reais) e sintaxe para construir arranjos (arrays) e tipos compostos.</p> <p>O valor m\u00e1ximo que um determinado tipo de dados por armazenar depende de fatores como sistema operacional e tipo de processador. Uma forma de verificar os limites na m\u00e1quina que voc\u00ea est\u00e1 usando, \u00e9 verificar os valores dispon\u00edveis na biblioteca <code>limits.h</code> (veja aqui).</p>"},{"location":"c/tiposdedados/#tipos-principais","title":"Tipos principais","text":"<p>A linguagem C fornece quatro especificadores de tipos dados aritm\u00e9ticos: <code>char</code>, <code>int</code>, <code>float</code> e <code>double</code> (al\u00e9m do tipo l\u00f3gico <code>bool</code>), e os modificados <code>signed</code>, <code>unsigned</code>, <code>short</code> e <code>long</code>. A combina\u00e7\u00e3o dos tipos com os modificadores produz os seguintes tipos de dados.</p> Tipo Detalhes bits Sufixo para constantes <code>bool</code> Tipo booleano, adicionado no C23 1 <code>char</code> Menor unidade endere\u00e7\u00e1vel da m\u00e1quina que pode conter conjunto de caracteres b\u00e1sicos. \\(\\geq 8\\) <code>signed char</code> O mesmo tamanho de <code>char</code>, com valores positivos e negativos \\(\\geq 8\\) <code>unsigned char</code> O mesmo tamanho de <code>char</code>, apenas valores positivos \\(\\geq 8\\) <code>u</code> <code>short</code><code>short int</code><code>signed short</code><code>signed short int</code> Tipo inteiro curto com sinal, com valores positivos e negativos \\(\\geq 16\\) <code>h</code> ou <code>H</code> <code>unsigned short</code><code>unsigned short int</code> Tipo inteiro curto sem sinal (apenas valores positivos) \\(\\geq 16\\) <code>uh</code> ou <code>UH</code> <code>int</code><code>signed</code><code>signed int</code> Tipo inteiro com sinal \\(\\geq 16\\) <code>unsigned</code><code>unsigned int</code> Tipo inteiro sem sinal (apenas valores positivos) \\(\\geq 16\\) <code>u</code> ou <code>U</code> <code>long</code><code>long int</code><code>signed long</code><code>signed long int</code> Tipo inteiro longo com sinal, com valores positivos e negativos \\(\\geq 32\\) <code>l</code> ou <code>L</code> <code>unsigned long</code><code>unsigned long int</code> Tipo inteiro longo sem sinal (apenas valores positivos) \\(\\geq 32\\) <code>ul</code> ou <code>UL</code> <code>long long</code><code>long long int</code><code>signed long long</code><code>signed long long int</code> Tipo inteiro longo longo com sinal, com valores positivos e negativos \\(\\geq 64\\) <code>ll</code> ou <code>LL</code> <code>unsigned long long</code><code>unsigned long long int</code> Tipo inteiro longo longo sem sinal (apenas valores positivos) \\(\\geq 64\\) <code>ull</code> ou <code>ULL</code> <code>float</code> Ponto flutuante de precis\u00e3o simples \\(\\geq 32\\) <code>f</code> ou <code>F</code> <code>double</code> Ponto flutuante de precis\u00e3o dupla \\(\\geq 64\\) <code>long double</code> Ponto flutuante de precis\u00e3o estendida \\(\\geq 64\\) <code>l</code> ou <code>L</code> <p>Os valores m\u00ednimos e m\u00e1ximos de cada tipo de dados pode ser, tamb\u00e9m, consultado na biblioteca <code>limits.h</code></p> <p>A rela\u00e7\u00e3o entre os modificadores obriga que <code>long long</code> n\u00e3o seja menor que <code>long</code>, que n\u00e3o \u00e9 menor que <code>int</code>, que n\u00e3o \u00e9 menor que <code>short</code>. O menor tamanho \u00e9 do tipo <code>char</code>.</p> <p>O tipo <code>int</code> deve ser o tipo inteiro que o processador alvo do programa compilado \u00e9 mais eficiente manipulando. Isso permite grande flexibilidade: por exemplo, todos os tipos podem ser de 64 bits.</p> <p>O padr\u00e3o C99 tamb\u00e9m adicionou os tipos complexos <code>float _Complex</code>, <code>double _Complex</code>, <code>long double _Complex</code>. Os tipos imagin\u00e1rios <code>float _Imaginary</code>, <code>double _Imaginary</code> e <code>long double _Imaginary</code> foram adicionados no padr\u00e3o C11, junto com a biblioteca <code>&lt;complex.h&gt;</code> que permite acesso aos tipos complexo e imagin\u00e1rio.</p> <p>O tipo <code>bool</code> foi introduzido no padr\u00e3o C99 (<code>&lt;stdbool.h&gt;</code>), e melhorado no C23, mas \u00e9 importante notar que antes disso, inteiros eram usados para representar valores booleanos (<code>0</code> para falso e qualquer outro valor para verdadeiro).</p> <p>Tipos de tamanho fixo</p> <p>Os tipos inteiros em C foram projetados para tornar o c\u00f3digo port\u00e1til entre m\u00e1quinas com diferentes tamanhos de palavra, o que significa que cada tipo pode ter diferentes intervalos de valores dependendo da arquitetura. No entanto, essa varia\u00e7\u00e3o pode ser problem\u00e1tica quando um programa precisa operar com um intervalo espec\u00edfico de inteiros ou um tamanho fixo de armazenamento, independentemente da m\u00e1quina em que ser\u00e1 executado. A partir da vers\u00e3o C99 foram introduzidas defini\u00e7\u00f5es de tipos que permitem declarar inteiros com tamanhos exatos, garantindo que o c\u00f3digo-fonte do programa permane\u00e7a independente da arquitetura subjacente. Os tipos s\u00e3o os seguintes:</p> <ul> <li>int\\(b\\)_t: inteiro com exatamente \\(b\\) bits e com sinal</li> <li>uint\\(b\\)_t: inteiro com exatamente \\(b\\) bits e sem sinal</li> </ul> <p>Se n\u00e3o for necess\u00e1rio um tamanho espec\u00edfico, mas o menor tipo capaz de guardar um n\u00famero de \\(b\\) bits, pode-se usar os seguintes tipos:</p> <ul> <li>int_least\\(b\\)_t: inteiro com pelo menos \\(b\\) bits e com sinal</li> <li>uint_least\\(b\\)_t: inteiro com pelo menos \\(b\\) bits e sem sinal</li> </ul> <p>Por quest\u00f5es de projeto do hardware do computador, alguns tamanhos podem ter um desempenho maior ou menor. Para isso, foram criados os tipos abaixo para representar os tipos de acesso mais r\u00e1pido com pelo menos \\(b\\) bits. </p> <ul> <li>int_fast\\(b\\)_t: inteiro de acesso mais r\u00e1pido com pelo menos \\(b\\) bits e com sinal</li> <li>uint_fast\\(b\\)_t: inteiro de acesso mais r\u00e1pido com pelo menos \\(b\\) bits e sem sinal</li> </ul> <p>Para todos os casos, \\(b \\in \\{8, 16, 32, 64\\}\\).  Se por acaso a arquitetura n\u00e3o tiver um determinado tamanho, o tipo n\u00e3o estar\u00e1 definido no compilador, e um erro vai aparecer durante a compila\u00e7\u00e3o.</p> <p>Mais detalhes podem ser obtidos aqui ou aqui.</p>"},{"location":"c/tiposdedados/#constantes","title":"Constantes","text":"<p>Uma constante \u00e9 um nome dado \u00e0 vari\u00e1vel cujos valores n\u00e3o podem ser alterados ou modificados. Uma constante \u00e9 muito semelhante a vari\u00e1veis em C, mas com a principal diferen\u00e7a que s\u00f3 pode ter o valor definido uma \u00fanica vez, durante a declara\u00e7\u00e3o da vari\u00e1vel. Isso significa que, uma vez que atribu\u00edmos um valor \u00e0 constante, n\u00e3o podemos mud\u00e1-lo durante toda a execu\u00e7\u00e3o do programa \u2014 ele permanece fixo.</p> <p>Veja bem, preste aten\u00e7\u00e3o!</p> <p>Na pr\u00e1tica, o uso de <code>const</code> \u00e9 prefer\u00edvel na grande maioria dos casos devido \u00e0 seguran\u00e7a de tipo, possibilidade de depura\u00e7\u00e3o e escopo mais restrito. Use <code>#define</code> apenas se voce tiver uma raz\u00e3o muito forte para tal.</p> <p>Constantes podem ser definidas de duas formas: com o uso da chamada de pr\u00e9-processador <code>#define</code>, ou com o uso da palavra chave <code>const</code> antes do tipo da vari\u00e1vel durante a sua declara\u00e7\u00e3o. Do ponto de vista pr\u00e1tico, as duas formas s\u00e3o equivalentes, apesar de \"por baixo dos panos\" serem completamente diferentes.</p>"},{"location":"c/tiposdedados/#usando-define","title":"Usando <code>#define</code>","text":"<p>A diretiva <code>#define</code> \u00e9 processada pelo pr\u00e9-processador antes da compila\u00e7\u00e3o. O pr\u00e9-processador substitui todas as ocorr\u00eancias do nome da constante pelo seu valor antes do c\u00f3digo ser compilado. Isso significa que:</p> <ul> <li>A constante n\u00e3o tem um tipo associado. O valor substitu\u00eddo depende do contexto em que aparece no c\u00f3digo;</li> <li>Como a substitui\u00e7\u00e3o ocorre antes da an\u00e1lise do c\u00f3digo pelo compilador, erros podem ser mais dif\u00edceis de detectar, e;</li> <li>N\u00e3o ocupa espa\u00e7o na mem\u00f3ria, pois n\u00e3o \u00e9 armazenada como uma vari\u00e1vel real. Apenas ocorre uma substitui\u00e7\u00e3o textual;</li> </ul> <p>Exemplo: Exemplo de constante com #define<pre><code>#include &lt;stdio.h&gt;\n\n#define PI 3.14159\n\nint main() {\n    double raio = 2.0;\n    double area = PI * raio * raio; // O pr\u00e9-processador substitui PI por 3.14159\n    printf(\"\u00c1rea: %f\\n\", area);\n    return 0;\n}\n</code></pre></p> <p>No c\u00f3digo acima, o pr\u00e9-processador transforma <code>PI * raio * raio</code> em <code>3.14159 * raio * raio</code> antes da compila\u00e7\u00e3o.</p>"},{"location":"c/tiposdedados/#usando-const","title":"Usando <code>const</code>","text":"<p>O uso de <code>const</code> define uma vari\u00e1vel que \u00e9 tratada como uma constante pelo compilador. Diferente de <code>#define</code>, essa constante tem um tipo definido e ocupa espa\u00e7o na mem\u00f3ria (a menos que o compilador otimize e substitua seu uso diretamente).</p> <ul> <li>A constante tem um tipo de dado expl\u00edcito, permitindo verifica\u00e7\u00f5es de tipo pelo compilador;</li> <li>Pode ter um escopo definido, ao contr\u00e1rio de <code>#define</code>, que \u00e9 global por padr\u00e3o, e;</li> <li>Pode ser usada para ponteiros, arranjos e outras estruturas de dados.</li> </ul> <p>Exemplo: Exemplo de constante com const<pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    const double PI = 3.14159; // Constante com tipo definido\n    double raio = 2.0;\n    double area = PI * raio * raio;\n    printf(\"\u00c1rea: %f\\n\", area);\n    return 0;\n}\n</code></pre></p> <p>Aqui, <code>PI</code> \u00e9 tratado como uma vari\u00e1vel que n\u00e3o pode ser modificada. Diferente de <code>#define</code>, ele tem um tipo e ocupa uma posi\u00e7\u00e3o de mem\u00f3ria.</p>"},{"location":"c/tiposdedados/#enumeracoes","title":"Enumera\u00e7\u00f5es","text":"<p>As enumera\u00e7\u00f5es (ou enums) na linguagem C s\u00e3o um tipo de dados definido pelo usu\u00e1rio que consistem em um conjunto de constantes inteiras nomeadas. Elas fornecem uma maneira de criar nomes descritivos e significativos para um conjunto de valores inteiros, tornando o c\u00f3digo mais leg\u00edvel e f\u00e1cil de manter.</p> <p>Para declarar uma enumera\u00e7\u00e3o em C, utiliza-se a palavra-chave <code>enum</code> seguida pelo nome da enumera\u00e7\u00e3o e a lista de constantes entre chaves:</p> <pre><code>enum nome_enum {\n    const1,\n    const2,\n    const3\n};\n</code></pre> <p>Por padr\u00e3o, a primeira constante recebe o valor 0, a segunda recebe 1, e assim por diante. No entanto, \u00e9 poss\u00edvel atribuir valores espec\u00edficos \u00e0s constantes, como no exemplo a seguir:</p> <pre><code>enum direcao {\n    NORTE = 10,\n    SUL = 20,\n    LESTE = 30,\n    OESTE = 40\n};\n</code></pre> <p>Ap\u00f3s definir um tipo de enumera\u00e7\u00e3o, \u00e9 poss\u00edvel declarar vari\u00e1veis desse tipo:</p> <pre><code>enum direcao minhaVar;\nminhaVar = LESTE; // Atribui o valor 30 \u00e0 vari\u00e1vel\n</code></pre> <p>Caracter\u00edsticas Importantes</p> <ul> <li>Tamanho em Mem\u00f3ria: Uma vari\u00e1vel de enumera\u00e7\u00e3o ocupa o mesmo espa\u00e7o que um inteiro (geralmente 4 bytes).</li> <li>Uso em Express\u00f5es: As constantes de enumera\u00e7\u00e3o podem ser usadas em qualquer lugar onde a linguagem C permite uma express\u00e3o inteira.</li> <li>Escopo: Os identificadores em uma lista de enumera\u00e7\u00e3o devem ser distintos de outros identificadores no mesmo escopo com a mesma visibilidade.</li> </ul> <p>Uma aplica\u00e7\u00e3o interessante das enumera\u00e7\u00f5es \u00e9 o uso como flags (sinalizadores). Neste caso, cada constante \u00e9 definida como uma pot\u00eancia de 2 para permitir a combina\u00e7\u00e3o de m\u00faltiplas flags usando operadores bit a bit.</p> C\u00f3digo fonteResultado <pre><code>#include &lt;stdio.h&gt;\n\nenum estiloTexto {\n    NEGRITO = 1,     // 00000001 em bin\u00e1rio\n    ITALICO = 2,     // 00000010 em bin\u00e1rio\n    SUBLINHADO = 4   // 00000100 em bin\u00e1rio\n};\n\nint main() {\n    int meuEstilo = NEGRITO | SUBLINHADO; // Combina NEGRITO e SUBLINHADO (5)\n\n    if (meuEstilo &amp; NEGRITO) {\n        printf(\"Texto em negrito\\n\");\n    }\n\n    if (meuEstilo &amp; ITALICO) {\n        printf(\"Texto em it\u00e1lico\\n\");\n    }\n\n    if (meuEstilo &amp; SUBLINHADO) {\n        printf(\"Texto sublinhado\\n\");\n    }\n\n    return 0;\n}\n</code></pre> <pre><code>Texto em negrito\nTexto sublinhado\n</code></pre> <p>As enumera\u00e7\u00f5es s\u00e3o particularmente \u00fateis quando:</p> <ul> <li>Voc\u00ea tem um conjunto de valores relacionados que n\u00e3o mudar\u00e3o, como dias da semana, meses, cores, etc.</li> <li>Voc\u00ea precisa de constantes nomeadas para melhorar a legibilidade do c\u00f3digo.</li> <li>Voc\u00ea est\u00e1 trabalhando com flags e precisa combinar m\u00faltiplos valores.</li> <li>Voc\u00ea quer evitar o uso de n\u00fameros m\u00e1gicos no c\u00f3digo.</li> </ul> <p>Embora seja poss\u00edvel realizar quase tudo em C sem usar enumera\u00e7\u00f5es, elas proporcionam uma maneira elegante e leg\u00edvel de trabalhar com conjuntos de constantes relacionadas, tornando o c\u00f3digo mais f\u00e1cil de entender e manter.</p>"},{"location":"c/tiposdedados/#sequencias-de-escape","title":"Sequ\u00eancias de escape","text":"<p>Alguns caracteres podem ser representados como sequ\u00eancias de escape: s\u00e3o conjuntos de dois ou mais caracteres que, na realidade, representam apenas um caractere. Um exemplo de sequ\u00eancia de escape \u00e9 o <code>\\n</code>, utilizado para representar o final de uma linha.</p> <p>Qualquer caracter pode ser representado pela sequ\u00eancia de escape <code>\\ooo</code>, onde <code>ooo</code> \u00e9 o n\u00famero octal do caracter na tabela ASCII<sup>1</sup>. Outra possibilidade \u00e9 representar o caracter utilizando a sequ\u00eancia de escape <code>\\xhh</code>, onde <code>hh</code> \u00e9 o n\u00famero hexadecimal do caracter na tabela ASCII. Assim, a letra <code>A</code> pode ser armazenada como <code>A</code>, ou como <code>\\101</code>, que \u00e9 a representa\u00e7\u00e3o em octal do valor 65 associado \u00e0 letra A mai\u00fascula na tabela ASCII, ou como <code>\\x41</code>, que \u00e9 a representa\u00e7\u00e3o em hexadecimal de 65.</p> <p>H\u00e1 algumas sequ\u00eancias de escape j\u00e1 definidas na linguagem C, para os caracteres mais comuns que n\u00e3o podem ser diretamente digitados.</p> Sequ\u00eancia Significado <code>\\a</code> Alerta (bipe, sino) <code>\\b</code> Backspace <code>\\f</code> Avan\u00e7o/quebra de p\u00e1gina <code>\\n</code> Avan\u00e7o de linha <code>\\r</code> Retorno de carro <code>\\t</code> Tabula\u00e7\u00e3o horizontal <code>\\v</code> Tabula\u00e7\u00e3o vertical <code>\\\\</code> Barra invertida (backslash) <code>\\'</code> Ap\u00f3strofo, ou aspas simples <code>\\\"</code> Aspas duplas <code>\\?</code> Ponto de interroga\u00e7\u00e3o <code>\\nnn</code> O byte cujo valor num\u00e9rico est\u00e1 representado como o n\u00famero octal ooo <code>\\xhh</code> O byte cujo valor num\u00e9rico est\u00e1 representado como o n\u00famero hexadecimal hh"},{"location":"c/tiposdedados/#estruturas","title":"Estruturas","text":"<p>Estruturas agregam o armazenamento de m\u00faltiplos itens de dados, de mesmo tipo ou n\u00e3o, em um \u00fanico bloco de mem\u00f3ria referenciado por uma \u00fanica vari\u00e1vel. O exemplo abaixo cria uma estrutura chamada <code>aniversario</code> para armazenar o nome e a data de nascimento de uma pessoa; em seguida, temos a declara\u00e7\u00e3o de uma vari\u00e1vel chamada <code>Abelardo</code> do tipo <code>struct aniversario</code></p> Exemplo de estrutura em C<pre><code>struct aniversario {\n    char nome[20];\n    int dia;\n    int mes;\n    int ano;\n};\n\nstruct aniversario Abelardo;\n</code></pre>"},{"location":"c/tiposdedados/#arranjos-arrays","title":"Arranjos (arrays)","text":"<p>Para cada tipo <code>T</code>, exceto o tipo <code>void</code>, existe um tipo \"arranjo de \\(N\\) elementos do tipo <code>T</code>\". Um arranjo \u00e9 uma cole\u00e7\u00e3o de valores, todos do mesmo tipo, armazenados de forma cont\u00edgua na mem\u00f3ria.  Os elementos que comp\u00f5em um arranjo de tamanho \\(N\\) s\u00e3o indexados por inteiros que variam de <code>0</code> at\u00e9 <code>N-1</code>. Por exemplo</p> Declara\u00e7\u00e3o de arranjo unidimensional em C<pre><code>int faltas[10];  // arranjo com 10 elementos, cada \n                 // um do tipo inteiro\n\nc[3] = 8;  // O quarto elemento do arranjo recebe\n           // o valor 8\n</code></pre> <p>Arranjos com mais de uma dimens\u00e3o (as vezes chamados de matrizes) s\u00e3o definidos como um \"arranjo de arranjo ...\", e todas as dimens\u00f5es, exceto a mais externa, precisam ser valores constantes.</p> Declara\u00e7\u00e3o de arranjo bidimensional em C<pre><code>int a[10][8];  // arranjo de 10 elementos, cada um do tipo\n               // 'arranjo de 8 elementos inteiros'\n</code></pre>"},{"location":"c/tiposdedados/#ponteiros","title":"Ponteiros","text":"<p>Um ponteiro do tipo \"ponteiro para <code>T</code>\" \u00e9 um tipo de dados que guarda um endere\u00e7o de mem\u00f3ria onde est\u00e1 armazenado um elemento do tipo <code>T</code>. Cada tipo de dado <code>T</code> tem um tipo de dados correspondente \"ponteiro para <code>T</code>\".</p> <p>Ponteiros s\u00e3o declarados com o uso de um aster\u00edsco (<code>*</code>) depois da declara\u00e7\u00e3o de tipo, e antecedendo o nome da vari\u00e1vel.</p> Declara\u00e7\u00e3o de ponteiros em C<pre><code>char *letra;   // 'letra' guarda um endere\u00e7o de mem\u00f3ria onde est\u00e1\n               // armazenada uma vari\u00e1vel do tipo char\nlong *salario; // 'salario' guarda um endere\u00e7o de mem\u00f3ria onde est\u00e1\n               // armazenada uma vari\u00e1vel do tipo float\nint *faltas;   // 'faltas' guarda um endere\u00e7o de mem\u00f3ria onde est\u00e1\n               // armazenada uma vari\u00e1vel do tipo int\n</code></pre> <p>Os ponteiros podem armazenar endere\u00e7os de vari\u00e1veis do tipo \"arranjo de <code>T</code>\" ou para estruturas, como no exemplo</p> Ponteiros para arranjos e para estruturas em C<pre><code>int *notas[10];  // Ponteiro para um arranjo de 10 valores inteiros\n\nstruct nodo {\n    int valor;\n    struct nodo *proximo;  // Ponteiro (endere\u00e7o de mem\u00f3ria que guarda\n                           //  uma vari\u00e1vel do tipo) para 'struct nodo'\n};\n</code></pre> <p>Ponteiros tamb\u00e9m podem ser declarados para vari\u00e1veis do tipo \"ponteiro para <code>T</code>\", dando origem ao tipo \"ponteiro para ponteiro para <code>T</code>\", ou seja, uma vari\u00e1vel que guarda um endere\u00e7o de mem\u00f3ria onde est\u00e1 armazenado um endere\u00e7o de mem\u00f3ria de uma vari\u00e1vel do tipo <code>T</code> (uma indire\u00e7\u00e3o dupla). Os ponteiros para ponteiros s\u00e3o declarados com <code>**</code>.</p> Declara\u00e7\u00e3o de ponteiro para ponteiro para inteiro<pre><code>int **i;  // Um ponteiro para ponteiro para inteiro\n</code></pre> <p>Em C, os operadores <code>*</code> e <code>&amp;</code> desempenham pap\u00e9is cruciais na manipula\u00e7\u00e3o de ponteiros, permitindo aos programadores interagir diretamente com a mem\u00f3ria.</p> <p>O operador <code>*</code>, quando usado com um ponteiro, \u00e9 conhecido como operador de indire\u00e7\u00e3o ou derefer\u00eancia. Ele permite acessar o valor armazenado na posi\u00e7\u00e3o de mem\u00f3ria para a qual o ponteiro aponta. Em outras palavras, se um ponteiro <code>p</code> armazena o endere\u00e7o de uma vari\u00e1vel inteira <code>x</code>, ent\u00e3o <code>*p</code> retorna o valor armazenado na vari\u00e1vel <code>x</code>. Esse mecanismo \u00e9 fundamental para modificar o valor de uma vari\u00e1vel indiretamente, atrav\u00e9s de seu endere\u00e7o de mem\u00f3ria.</p> <p>Por outro lado, o operador <code>&amp;</code> \u00e9 o operador de endere\u00e7o. Ele retorna o endere\u00e7o de mem\u00f3ria de uma vari\u00e1vel. Ao aplicar <code>&amp;</code> a uma vari\u00e1vel, obtemos um ponteiro para essa vari\u00e1vel. Por exemplo, se <code>x</code> \u00e9 uma vari\u00e1vel inteira, ent\u00e3o <code>&amp;x</code> retorna o endere\u00e7o de mem\u00f3ria onde <code>x</code> est\u00e1 armazenado. Esse operador \u00e9 essencial para inicializar ponteiros, permitindo que eles apontem para vari\u00e1veis espec\u00edficas.</p> <p>A combina\u00e7\u00e3o de <code>*</code> e <code>&amp;</code> possibilita a manipula\u00e7\u00e3o eficiente da mem\u00f3ria, permitindo a cria\u00e7\u00e3o de estruturas de dados din\u00e2micas e a implementa\u00e7\u00e3o de algoritmos que exigem acesso direto \u00e0 mem\u00f3ria.</p> <p>Veja o exemplo a seguir</p> C\u00f3digo fonteResultado ponteiros.c<pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    int valor = 10;   // Vari\u00e1vel inteira comum\n    int *ptr = &amp;valor; // Ponteiro para a vari\u00e1vel 'valor'\n    int **ptr_ptr = &amp;ptr; // Ponteiro para o ponteiro 'ptr'\n\n    // Exibindo os valores e endere\u00e7os\n    printf(\"Valor: %d\\n\", valor);\n    printf(\"Endere\u00e7o de valor: %p\\n\", &amp;valor);\n\n    printf(\"Valor apontado por ptr (o que esta guardado no endereco guardado em ptr): %d\\n\", *ptr);\n    printf(\"Endere\u00e7o de ptr: %p\\n\", &amp;ptr);\n\n    printf(\"Valor apontado por ptr_ptr: %p\\n\", *ptr_ptr);\n    printf(\"Valor apontado por *ptr_ptr: %d\\n\", **ptr_ptr);\n    printf(\"Endere\u00e7o de ptr_ptr: %p\\n\", &amp;ptr_ptr);\n\n    return 0;\n}\n</code></pre> <pre><code>Valor: 10\nEndereco de valor: 00000067953ffb4c\nValor apontado por ptr (o que esta guardado no endereco guardado em ptr): 10\nEndereco de ptr: 00000067953ffb40\nValor apontado por ptr_ptr: 00000067953ffb4c\nValor apontado por *ptr_ptr: 10\nEndereco de ptr_ptr: 00000067953ffb38\n</code></pre> <p>Inicialmente, declaramos uma vari\u00e1vel inteira chamada <code>valor</code> e a inicializamos com o valor 10. Em seguida, declaramos um ponteiro para inteiro chamado <code>ptr</code> e o inicializamos com o endere\u00e7o de mem\u00f3ria da vari\u00e1vel <code>valor</code>, utilizando o operador <code>&amp;</code>. Nesse ponto, <code>ptr</code> \"aponta\" para <code>valor</code>, ou seja, armazena o endere\u00e7o de mem\u00f3ria onde <code>valor</code> est\u00e1 armazenado. Em seguida declaramos um ponteiro para ponteiro para inteiro chamado <code>ptr_ptr</code> e o inicializamos com o endere\u00e7o de mem\u00f3ria do ponteiro <code>ptr</code>. Agora, <code>ptr_ptr</code> \"aponta\" para <code>ptr</code>, armazenando o endere\u00e7o de mem\u00f3ria onde <code>ptr</code> est\u00e1 armazenado.</p> <p>Perceba que <code>ptr_ptr</code> guarda um endere\u00e7o de mem\u00f3ria que armazena um endere\u00e7o de mem\u00f3ria para inteiro. Por isso \u00e9 necess\u00e1rio obter o endere\u00e7o da vari\u00e1vel <code>ptr</code> com <code>&amp;ptr</code>, ao inv\u00e9s de simplesmente fazer <code>int **ptr_ptr = &amp;ptr</code>. A opera\u00e7\u00e3o de atribui\u00e7\u00e3o <code>int **ptr_ptr = &amp;ptr</code> est\u00e1 sem\u00e2nticamente incorreta, pois estamos atribuindo uma vari\u00e1vel do tipo \"ponteiro para inteiro\" para uma vari\u00e1vel do tipo \"ponteiro para ponteiro para inteiro\".</p> <p>A manipula\u00e7\u00e3o de ponteiros em C \u00e9 frequentemente considerada um dos aspectos mais desafiadores da linguagem, gerando debates intensos entre programadores sobre sua complexidade. Essa caracter\u00edstica fundamental da linguagem C tanto possibilita opera\u00e7\u00f5es poderosas quanto introduz riscos significativos de erros. \u00c9 importante entender que um \"ponteiro para <code>T</code>\" \u00e9 uma vari\u00e1vel como outra qualquer, que guarda um determinado valor (endere\u00e7o de uma posi\u00e7\u00e3o de mem\u00f3ria) de um determinado tipo (posi\u00e7\u00e3o de mem\u00f3ria ocupada por um <code>T</code>). O fato de o \"tipo\" ser um \"ponteiro para <code>T</code>\" n\u00e3o faz a vari\u00e1vel ser diferente de uma vari\u00e1vel que guarda, por exemplo, um valor inteiro.</p> <p>A complexidade dos ponteiros em C manifesta-se principalmente atrav\u00e9s dos problemas que podem surgir quando mal utilizados. Um dos exemplos mais claros \u00e9 a ocorr\u00eancia de vazamentos de mem\u00f3ria (memory leaks), que acontecem quando um programador, utilizando ponteiros, aloca mem\u00f3ria dinamicamente, mas esquece de devolver essa mem\u00f3ria ao sistema operacional antes de finalizar as atividade. Esse problema pode degradar o desempenho do programa ao longo do tempo, consumindo recursos do sistema de forma progressiva. Al\u00e9m disso, se o programar devolver a mem\u00f3ria ao sistema operacional e tentar acessar a mem\u00f3ria em seguida, temos um \"ponteiro pendente\" (dangling pointer): um ponteiro que aponta para uma \u00e1rea de mem\u00f3ria que j\u00e1 foi liberada. As consequ\u00eancias disso n\u00e3o s\u00e3o previs\u00edveis.</p> <p>Outro problema grave s\u00e3o as viola\u00e7\u00f5es de acesso (access violations), que ocorrem quando um ponteiro tenta acessar um endere\u00e7o de mem\u00f3ria inexistente ou para o qual o programa n\u00e3o tem permiss\u00e3o. Como ponteiros s\u00e3o essencialmente n\u00fameros inteiros que podem ser manipulados atrav\u00e9s de aritm\u00e9tica, erros nos c\u00e1lculos podem fazer com que apontem para locais desconhecidos na mem\u00f3ria. Apontar para um local desconhecido ou sem autoriza\u00e7\u00e3o n\u00e3o \u00e9 problema: o problema vai acontecer quando o ponteiros for dereferenciado.</p> <p>A aritm\u00e9tica de ponteiros, embora elegante e extremamente \u00fatil, \u00e9 apontada como causa de uma falha de seguran\u00e7a importante na linguagem C. Teoricamente, a aritm\u00e9tica de ponteiros deve ser usada apenas dentro dos limites de um objeto alocado. Isso significa que, se voc\u00ea tem um arranjo de 10 elementos, voc\u00ea deve ajustar o ponteiro apenas para acessar esses 10 elementos. No entanto, C n\u00e3o realiza verifica\u00e7\u00f5es autom\u00e1ticas de limites. Se um programador, por erro ou mal\u00edcia, ajustar um ponteiro para al\u00e9m dos limites do objeto alocado, o sistema n\u00e3o impedir\u00e1 essa a\u00e7\u00e3o, e quando um ponteiro ultrapassa os limites, ele pode sobrescrever dados de outros objetos que est\u00e3o armazenados em \u00e1reas de mem\u00f3ria adjacentes. Isso pode levar a corrup\u00e7\u00e3o de dados, falhas no programa ou vulnerabilidades de seguran\u00e7a, como a execu\u00e7\u00e3o de c\u00f3digo arbitr\u00e1rio.</p> <p>Por outro lado, a manipula\u00e7\u00e3o de ponteiros permite que os programadores escrevam c\u00f3digo altamente eficiente, pois eles podem acessar e modificar dados diretamente na mem\u00f3ria. Isso \u00e9 particularmente \u00fatil em aplica\u00e7\u00f5es que exigem alto desempenho, como jogos e sistemas embarcados. Eles permitem a cria\u00e7\u00e3o de estruturas de dados din\u00e2micas, como listas ligadas e \u00e1rvores, que podem crescer ou diminuir de tamanho conforme necess\u00e1rio.</p> <p>Especialmente em sistemas embarcados, ou quando escrevendo programas que precisam manipular diretamente o hardware da m\u00e1quina, os ponteiros s\u00e3o essenciais: eles permitem que os programadores leiam e escrevam em endere\u00e7os de mem\u00f3ria espec\u00edficos que correspondem a registradores de hardware.</p> <p>Por fim, \u00e9 s\u00f3 por causa da exist\u00eancia dos ponteiros que \u00e9 poss\u00edvel passar par\u00e2metros para fun\u00e7\u00f5es por refer\u00eancia, permitindo que a fun\u00e7\u00e3o modifique os valores originais das vari\u00e1veis.</p> <p>Uma abordagem disciplinada pode eliminar a maioria dos problemas: inicializar sempre os ponteiros, verificar se s\u00e3o nulos antes de dereferenci\u00e1-los e implementar uma estrat\u00e9gia clara de limpeza de mem\u00f3ria</p>"},{"location":"c/tiposdedados/#sinonimos-de-tipos-typedef","title":"Sin\u00f4nimos de tipos (<code>typedef</code>)","text":"<p>O comando <code>typedef</code> em C \u00e9 usado para criar sin\u00f4nimos ou \"aliases\" para tipos de dados existentes. Ele permite renomear tipos de dados, facilitando a organiza\u00e7\u00e3o e o entendimento do c\u00f3digo.</p> <p>Veja bem, preste aten\u00e7\u00e3o!</p> <p>\u00c9 importante ressaltar que o <code>typedef</code> n\u00e3o cria um novo tipo de dado, apenas permite que um tipo existente seja denominado de uma forma diferente</p> <p>A sintaxe b\u00e1sica do <code>typedef</code> \u00e9:</p> <pre><code>typedef &lt;tipo_existente&gt; &lt;novo_nome&gt;;\n</code></pre> <p>O uso de <code>typedef</code> em programa\u00e7\u00e3o oferece diversas vantagens. Em primeiro lugar, ele aprimora a legibilidade do c\u00f3digo ao simplificar declara\u00e7\u00f5es complexas, facilitando o entendimento; em segundo lugar, facilita a manuten\u00e7\u00e3o, permitindo que a altera\u00e7\u00e3o de um tipo de dado seja feita em um \u00fanico local, sem a necessidade de modificar cada inst\u00e2ncia de uso, e; por fim, ele simplifica as declara\u00e7\u00f5es de estruturas, reduzindo a necessidade de utilizar repetidamente a palavra-chave <code>struct</code>.</p> Exemplo de uso de typedef<pre><code>#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\n// Define uma struct para representar um ponto no espa\u00e7o 2D\ntypedef struct\n{\n  int x;\n  int y;\n} Ponto;\n\ntypedef unsigned long int uli_t;\n\nint main() {\n  // Cria uma vari\u00e1vel do tipo Ponto, que \u00e9 um apelido para a struct\n  // com dois inteiros definida anteriormente\n  Ponto p1;\n\n  // Mais simples que \"unsigned long int a, b;\"\n  uli_t a, b;\n\n  return 0;\n}\n</code></pre> <ol> <li> <p>O C\u00f3digo Padr\u00e3o Americano para o Interc\u00e2mbio de Informa\u00e7\u00e3o (ou, no original, American Standard Code for Information Interchange) \u00e9 um sistema de representa\u00e7\u00e3o de letras, algarismos e sinais de pontua\u00e7\u00e3o e de controle codificados em um n\u00famero bin\u00e1rio entre 0 e 127. Esses c\u00f3digos cobrem 95 sinais gr\u00e1ficos (letras do alfabeto latino, algarismos ar\u00e1bicos, sinais de pontua\u00e7\u00e3o e sinais matem\u00e1ticos) e 33 sinais de controle. Como um byte tem 8 bits, sobra um bit no c\u00f3digo ASCII que pode ser usado de diferentes formas, para representar outras caracteres n\u00e3o cobertos pela tabela ASCII original.\u00a0\u21a9</p> </li> </ol>"},{"location":"exercicios/competicao/","title":"Quest\u00f5es de competi\u00e7\u00e3o","text":"<p>Os problemas deste grupo s\u00e3o transcri\u00e7\u00f5es ou adapta\u00e7\u00f5es de problemas integrantes de competi\u00e7\u00f5es de programa\u00e7\u00e3o. Voc\u00ea pode encontrar v\u00e1rios outros exerc\u00edcios como esses no BeCrowd, Hacker Rank, CodeChef, Topcoder ou Online Judge.</p> <p>Outra excelente oportunidade de praticar e verificar seu conhecimento de programa\u00e7\u00e3o \u00e9 participar do InterIF, a Maratona de Programa\u00e7\u00e3o do IFSP.</p> O que \u00e9 o InterIF? <p>O InterIF \u00e9 uma a\u00e7\u00e3o que visa contribuir com a aprendizagem por meio de uma competi\u00e7\u00e3o de programa\u00e7\u00e3o de computadores destinada aos estudantes regularmente matriculados nos cursos do Instituto Federal de S\u00e3o Paulo, realizada anualmente em duas etapas. Durante a competi\u00e7\u00e3o, as equipes formadas por tr\u00eas estudantes trabalham em conjunto usando um \u00fanico computador para resolver o maior n\u00famero poss\u00edvel de problemas, utilizando suas habilidades em programa\u00e7\u00e3o, an\u00e1lise de algoritmos e racioc\u00ednio l\u00f3gico, dentro do tempo limite da prova. Cada equipe \u00e9, normalmente, preparada por um professor de seu respectivo campus, chamado de coach da equipe. Vence a equipe que resolver o maior n\u00famero de quest\u00f5es, tendo como crit\u00e9rios de desempate o tempo de resolu\u00e7\u00e3o e n\u00famero de submiss\u00f5es incorretas.</p> <ol> <li> <p>(URI 1437) Este ano o sargento est\u00e1 tendo mais trabalho do que de costume para treinar os recrutas. Um deles \u00e9 muito atrapalhado, e de vez em quando faz tudo errado \u2013 por exemplo, ao inv\u00e9s de virar \u00e0 direita quando comandado, vira \u00e0 esquerda, causando grande confus\u00e3o no batalh\u00e3o. O sargento tem fama de dur\u00e3o e n\u00e3o vai deixar o recruta em paz enquanto este n\u00e3o aprender a executar corretamente os comandos. No s\u00e1bado \u00e0 tarde, enquanto todos os outros recrutas est\u00e3o de folga, ele obrigou o recruta a fazer um treinamento extra. Com o recruta marchando parado no mesmo lugar, o sargento emitiu uma s\u00e9rie de comandos \"Esquerda, Volver!\" e \"Direita, Volver!\". A cada comando, o recruta deve girar sobre o mesmo ponto e dar um quarto de volta na dire\u00e7\u00e3o correspondente ao comando. Por exemplo, se o recruta est\u00e1 inicialmente com o rosto voltado para a dire\u00e7\u00e3o norte, ap\u00f3s um comando de \"esquerda volver!\" ele deve ficar com o rosto voltado para a dire\u00e7\u00e3o oeste. Se o recruta est\u00e1 inicialmente com o rosto voltado para o leste, ap\u00f3s um comando \"Direita, volver!\" ele deve ter o rosto voltado para o sul. No entanto, durante o treinamento, em que o recruta tinha inicialmente o rosto voltado para o norte, o sargento emitiu uma s\u00e9rie t\u00e3o extensa de comandos, e t\u00e3o rapidamente, que at\u00e9 ele ficou confuso, e n\u00e3o sabe mais para qual dire\u00e7\u00e3o o recruta deve ter seu rosto voltado ap\u00f3s executar todos os comandos. Voc\u00ea pode ajudar o sargento? Construa um programa que leia o n\u00famero N de comandos emitidos pelo sargento, cada um dos N comandos (0 indica esquerda, e 1 indica direita) e, depois, diga para qual lado o recruta est\u00e1 virado (come\u00e7a olhando para norte, e pode terminar olhando para norte, leste, sul ou oeste)</p> </li> <li> <p>(URI 1397) Og gosta muito de brincar com seus filhos. Seu jogo preferido \u00e9 o jogo do maior, de autoria pr\u00f3pria. Este passatempo (no tempo das cavernas se tinha muito tempo dispon\u00edvel para jogos) \u00e9 jogado em dupla, Og e um dos seus filhos. O jogo procede da seguinte forma: os dois participantes escolhem um n\u00famero de rodadas e, a cada rodada, cada participante diz um n\u00famero de 0 at\u00e9 10 em voz alta, sendo que o participante que falar o n\u00famero mais alto ganha um ponto (em caso de empate, ningu\u00e9m ganha o ponto). No final das rodadas, os pontos s\u00e3o contabilizados e o participante com o maior n\u00famero de pontos ganha. Og e seus filhos gostam muito do jogo, mas se perdem na contagem dos pontos. Voc\u00ea conseguir\u00e1 ajudar Og a verificar a pontua\u00e7\u00e3o de uma lista de jogos? Construa um programa que leia um inteiro N indicando n\u00famero de rodadas da partida, e depois leia N pares de valores, sendo que o primeiro inteiro \u00e9 o valor do jogador A, e o segundo, do jogador B e diga quantas rodadas cada jogador ganhou (valor iguais s\u00e3o considerados empate, sem vencedores)</p> </li> <li> <p>(URI 1379) A m\u00e9dia de tr\u00eas inteiros \\(A\\), \\(B\\) e \\(C\\) \u00e9 \\((A + B + C)/3\\). A mediana de tr\u00eas n\u00fameros inteiros seria ent\u00e3o aquela que estaria no meio, se forem ordenados em ordem n\u00e3o decrescente. Dados dois n\u00fameros inteiros \\(A\\) e \\(B\\), retornar o m\u00ednimo inteiro poss\u00edvel \\(C\\), tal que a m\u00e9dia e a mediana de \\(A\\), \\(B\\) e \\(C\\), sejam iguais. Fa\u00e7a um programa que leia dois inteiros, \\(A\\) e \\(B\\) e imprima o menor inteiro \\(C\\) de forma que a m\u00e9dia e a mediana entre \\(A\\), \\(B\\) e \\(C\\) sejam iguais</p> </li> <li> <p>(URI 1329) Jo\u00e3o e Maria s\u00e3o amigos desde que se conheceram na creche. Desde ent\u00e3o, eles compartilham uma rotina de brincadeiras: todas as vezes que eles se encontram, eles jogam Cara ou Coroa com uma moeda, e quem ganhar tem o privil\u00e9gio de decidir quais brincadeiras eles ir\u00e3o jogar durante o dia. Maria sempre escolhe cara, e Jo\u00e3o sempre escolhe coroa. Hoje em dia eles est\u00e3o na faculdade, mas continuam sendo bons amigos. Sempre que se encontram, eles ainda jogam Cara ou Coroa, e o vencedor decide que filme assistir, ou em que restaurante jantar, e assim por diante. Ontem Maria contou a Jo\u00e3o que ela guarda um registro de todas as vezes que eles jogaram, desde os tempos da creche. Jo\u00e3o ficou espantado. Por\u00e9m Jo\u00e3o est\u00e1 estudando Ci\u00eancia da Computa\u00e7\u00e3o e decidiu que essa era uma boa oportunidade para mostrar a Maria suas habilidades em programa\u00e7\u00e3o, escrevendo um programa que mostrasse o n\u00famero de vezes que cada um deles venceu ao longo de todos esses anos. Construa um programa que leia um inteiro N que indica o n\u00famero de partidas jogadas, e depois N inteiros que indicam se Maria (0) ou Jo\u00e3o (1) ganhou a partida. Por fim, o programa deve dizer quantas partidas Jo\u00e3o ganhou, e quantas partidas Maria ganhou.</p> </li> <li> <p>(URI 1300) Heidi tem um rel\u00f3gio anal\u00f3gico discreto com a forma de um c\u00edrculo, como o mostrado na figura ao lado. Dois ponteiros giram em torno do centro do c\u00edrculo, indicando as horas e minutos. O rel\u00f3gio tem 60 marcas colocadas em torno do seu per\u00edmetro, com a dist\u00e2ncia entre cada uma das marcas consecutivas sendo constante. O ponteiro dos minutos se move de sua marca atual para o pr\u00f3ximo exatamente uma vez a cada minuto. Por sua vez, o ponteiro das horas se move de sua marca atual para a pr\u00f3xima exatamente uma vez a cada 12 minutos, de modo que avan\u00e7a cinco marcas a cada hora. Consideramos que os dois ponteiros movem-se discretamente e instantaneamente, o que significa que eles est\u00e3o sempre posicionados exatamente sobre uma das marcas e nunca entre as marcas. \u00c0 meia-noite ambos os ponteiros alcan\u00e7am ao mesmo tempo a marca no topo, o que indica zero horas e zero minutos. Ap\u00f3s exatamente 12 horas ou 720 minutos, ambos os ponteiros alcan\u00e7am a mesma posi\u00e7\u00e3o novamente, e este processo \u00e9 repetido v\u00e1rias vezes. Note que quando o ponteiro dos minutos se move, o ponteiro das horas pode n\u00e3o se mover, no entanto, quando o ponteiro das horas se move, o ponteiro dos minutos tamb\u00e9m se move. Heidi gosta de geometria, e ela gosta de medir o \u00e2ngulo m\u00ednimo entre os dois ponteiros do rel\u00f3gio em diferentes momentos do dia. Ela tem anotado algumas medidas, mas depois de v\u00e1rios anos e uma longa lista, ela notou que alguns \u00e2ngulos se repetiam enquanto alguns outros nunca apareciam. Por exemplo, a lista de Heidi indica que tanto \u00e0s tr\u00eas horas quanto \u00e0s nove horas o \u00e2ngulo m\u00ednimo entre os dois ponteiros \u00e9 de 90 graus, enquanto um \u00e2ngulo de 65 graus n\u00e3o aparece na lista. Heidi decidiu verificar, para qualquer n\u00famero inteiro \\(\\alpha\\) entre 0 e 180, se existe pelo menos uma vez no dia um \u00e2ngulo m\u00ednimo entre os dois ponteiros do rel\u00f3gio com exatamente \\(\\alpha\\) graus. Construa um programa que leia um inteiro \\(\\alpha\\) e indique se existe pelo menos uma hora no dia na qual o \u00e2ngulo m\u00ednimo entre os ponteiros \u00e9 exatamente igual ao \u00e2ngulo \\(\\alpha\\) informado.</p> </li> <li> <p>(URI 1483) Em um pa\u00eds muito distante, as pessoas s\u00e3o viciadas em um jogo de apostas bastante simples. O jogo \u00e9 baseado em n\u00fameros e \u00e9 chamado jogo do bicho. O nome do jogo deriva do fato que os n\u00fameros s\u00e3o divididos em 25 grupos, dependendo do valor dos dois \u00faltimos d\u00edgitos (dezenas e unidades), e cada grupo recebe o nome de um animal. Cada grupo \u00e9 associado a um animal da seguinte forma: o primeiro grupo (burro) consiste nos n\u00fameros 01, 02, 03 e 04; o segundo grupo (\u00e1guia) \u00e9 composto dos n\u00fameros 05, 06, 07 e 08; e assim em diante, at\u00e9 o \u00faltimo grupo contendo os n\u00fameros 97, 98, 99 e 00. As regras do jogo s\u00e3o simples. No momento da aposta, o jogador decide o valor da aposta \\(V\\) e um n\u00famero \\(N\\) (\\(0 \\leq N \\leq 99999\\)). Todos os dias, na pra\u00e7a principal da cidade, um n\u00famero \\(M\\) \u00e9 sorteado (\\(0 \\leq M \\leq 99999\\)). O pr\u00eamio de cada apostador \u00e9 calculado da seguinte forma:</p> <ul> <li>Se \\(M\\) e \\(N\\) t\u00eam os mesmos quatro \u00faltimos d\u00edgitos (milhar, centena, dezena e unidade), o apostador recebe \\(V \\timews 3000\\) (por exemplo, \\(N = 99301\\) e \\(M = 19301\\));</li> <li>Se \\(M\\) e \\(N\\) t\u00eam os mesmos tr\u00eas \u00faltimos d\u00edgitos (centena, dezena e unidade), o apostador recebe \\(V \\times 500\\) (por exemplo, \\(N = 38944\\) e \\(M = 83944\\));</li> <li>Se \\(M\\) e \\(N\\) t\u00eam os mesmos dois \u00faltimos d\u00edgitos (dezena e unidades), o apostador recebe \\(V \\times 50\\) (por exemplo, \\(N = 111\\) e \\(M = 55211\\));</li> <li>Se \\(M\\) e \\(N\\) t\u00eam os dois \u00faltimos d\u00edgitos no mesmo grupo, correspondendo ao mesmo animal, o apostador recebe \\(V \\times 16\\) (por exemplo, \\(N = 82197\\) e \\(M = 37600\\));</li> <li>Se nenhum dos casos acima ocorrer, o apostador n\u00e3o recebe nada.</li> </ul> <p>Obviamente, o pr\u00eamio dado a cada apostador \u00e9 o m\u00e1ximo poss\u00edvel de acordo com as regras acima. No entanto, n\u00e3o \u00e9 poss\u00edvel acumular pr\u00eamios, de forma que apenas um dos crit\u00e9rios acima deve ser aplicado no c\u00e1lculo do pr\u00eamio. Se um n\u00famero \\(N\\) ou \\(M\\) com menos de quatro d\u00edgitos for apostado ou sorteado, assuma que d\u00edgitos 0 devem ser adicionados na frente do n\u00famero para que se torne de quatro d\u00edgitos; por exemplo, 17 corresponde a 0017. Construa um programa que leia o valor apostado, o n\u00famero escolhido e o n\u00famero sorteado, e diga qual o valor do pr\u00eamio devido ao apostador.</p> </li> <li> <p>(URI 1573) Uma f\u00e1brica produz barras de chocolates no formato de paralelep\u00edpedos e de cubos, com o mesmo volume. Por\u00e9m, como a m\u00e1quina que produz os chocolates em formato de cubo est\u00e1 apresentando alguns problemas. Deseja-se, dadas as dimens\u00f5es das arestas do chocolate em formato de paralelep\u00edpedo, dizer qual \u00e9 o tamanho que a aresta em formato de cubo deve ter. O seu programa deve ler tr\u00eas inteiros, \\(A\\), \\(B\\) e \\(C\\), que indicam o tamanho das arestas do paralelep\u00edpedo e imprimir um inteiro com o tamanho da aresta do chocolate em tamanho de cubo.</p> </li> </ol>"},{"location":"exercicios/exercicios/","title":"Exerc\u00edcios selecionados","text":"<p>As se\u00e7\u00f5es a seguir cont\u00e9m alguns exerc\u00edcios dos assuntos cobertos neste texto.  Tente resolv\u00ea-los e lembre-se: para aprender a programar, s\u00f3 programando.</p>"},{"location":"exercicios/operacoes/","title":"Opera\u00e7\u00f5es aritm\u00e9ticas e de atribui\u00e7\u00e3o","text":"<ol> <li> <p>Fa\u00e7a um programa que calcule a \u00e1rea (A) de um c\u00edrculo de raio r informado pelo usu\u00e1rio. Apresente a \u00e1rea com 2 casas decimais (\\(A = \\pi r^2\\))</p> </li> <li> <p>Fa\u00e7a um programa que calcule a \u00e1rea de um tri\u00e2ngulo a partir do comprimento da base e da altura. A \u00e1rea pode ser calculada como metade do produto entre a base e a altura</p> </li> <li> <p>Fa\u00e7a um programa que leia o raio r de uma esfera, calcule e imprima o seu volume. A f\u00f3rmula para o volume de uma esfera \u00e9 \\(V = \\dfrac{4}{3}\\pi r^3\\)</p> </li> <li> <p>Fa\u00e7a um programa que calcule a \u00e1rea de um ret\u00e2ngulo a partir do comprimento de duas arestas adjacentes informadas pelo usu\u00e1rio. A \u00e1rea \u00e9 o produto entre o comprimento das arestas</p> </li> <li> <p>Fa\u00e7a um programa que calcule a m\u00e9dia entre tr\u00eas n\u00fameros informados pelo usu\u00e1rio</p> </li> <li> <p>O custo final ao consumidor de um ve\u00edculo \u00e9 a soma do custo de fabrica\u00e7\u00e3o com o lucro do distribuidor e os impostos, ambos aplicados sobre o custo de fabrica\u00e7\u00e3o. Fa\u00e7a um programa que calcule o custo final ao consumidor de um ve\u00edculo a partir do custo de fabrica\u00e7\u00e3o, e considerando que o lucro do distribuidor \u00e9 de 15%, e a carga tribut\u00e1ria total \u00e9 de 48%</p> </li> <li> <p>Fa\u00e7a um programa que receba a temperatura em graus Celsius e apresente o resultado da convers\u00e3o dessa temperatura em Kelvin e graus Fahrenheit. A f\u00f3rmula para convers\u00e3o \u00e9 \\(F = 1.8 \\times C + 32\\) e \\(K = C + 273.15\\)</p> </li> <li> <p>Fa\u00e7a um programa que calcule a quantidade de litros de combust\u00edvel gastos em uma viagem. O usu\u00e1rio vai informar o consumo do ve\u00edculo, em Km/l, a velocidade m\u00e9dia no percurso e o tempo de viagem. A dist\u00e2ncia percorrida \u00e9 o resultado do produto entre a velocidade m\u00e9dia e o tempo de viagem. O consumo pode ser calculado pela raz\u00e3o entre a dist\u00e2ncia e o consumo.</p> </li> <li> <p>Construa um programa que leia a dist\u00e2ncia percorrida em Km, e o tempo necess\u00e1rio para percorr\u00ea-la em minutos, e apresente a velocidade m\u00e9dia em metros por segundo (m/s)</p> </li> <li> <p>O sistema de avalia\u00e7\u00e3o de determinada disciplina, \u00e9 composto por tr\u00eas provas. A primeira prova tem peso 2, a segunda tem peso 3 e a terceira tem peso 5. Fa\u00e7a um algoritmo para calcular a m\u00e9dia final de um aluno desta disciplina.</p> </li> <li> <p>Escreva um algoritmo que, lendo o m\u00eas e o ano de nascimento, determine o n\u00famero de dias que uma pessoa j\u00e1 viveu. Considere que um m\u00eas tenha 30 dias.</p> </li> <li> <p>Uma empresa paga aos seus funcion\u00e1rios um sal\u00e1rio que depende do total de horas trabalhadas no m\u00eas. Voc\u00ea deve fazer um programa que leia a quantidade de horas que o funcion\u00e1rio trabalhou, o valor de cada hora trabalhada e o percentual de desconto a ser aplicado no sal\u00e1rio (imposto de renda, contribui\u00e7\u00e3o social, vale transporte, essas coisas).  Calcule e imprima o sal\u00e1rio bruto, o valor do desconto e o sal\u00e1rio l\u00edquido (bruto \u2013 descontos)</p> </li> <li> <p>Uma empresa precisa calcular a capacidade de uma lata cil\u00edndrica que ser\u00e1 usada para transportar um determinado l\u00edquido. Fa\u00e7a um programa que receba as dimens\u00f5es do cilindro (raio da base e altura), calcule e imprima a capacidade da lata cil\u00edndrica em \\(cm^3\\).</p> </li> <li> <p>Fa\u00e7a um programa que leia a velocidade de um ve\u00edculo em m/s e apresente a velocidade em Km/h (1m/s = 3,6Km/h)</p> </li> <li> <p>Leia um n\u00famero com tr\u00eas algarismos (entre 0 e 999) e imprima o n\u00famero com os algarismos na ordem inversa, ou seja, o algarismo da unidade vira o da centena, e o da centena vira o da unidade. Por exemplo, \"562\" torna-se \"265\".</p> </li> <li> <p>Uma empresa produz tr\u00eas tipos de pe\u00e7as mec\u00e2nicas: parafusos, porcas e arruelas. Para cada uma delas, a empresa d\u00e1 um desconto sobre o pre\u00e7o de tabela que s\u00e3o, respectivamente, 10%, 20% e 30%. Escreva um programa que leia o pre\u00e7o de cada item, a quantidade vendida de cada um deles, e o total a ser pago.</p> </li> <li> <p>Quando temos um n\u00famero que gostar\u00edamos de proteger contra erros de anota\u00e7\u00e3o (por exemplo, RG ou n\u00famero de matr\u00edcula) utilizamos os chamados \"d\u00edgitos verificadores\". Determinada aplica\u00e7\u00e3o precisa calcular o d\u00edgito verificador de um n\u00famero com 4 algarismos (ABCD). O d\u00edgito verificador \u00e9 calculado como o resto da divis\u00e3o por 7 da soma do algarismo multiplicado pela sua posi\u00e7\u00e3o. Por exemplo, o n\u00famero 7155 tem como d\u00edgito verificador o valor 4, pois \\(7 \\times 4 + 1 \\times 3 + 5 \\times 2 + 5 \\times 1=46\\) e o resto da divis\u00e3o de 46 por 7 \u00e9 igual a 4. Construa um programa que leia um n\u00famero com at\u00e9 quatro algarismos (entre 0 e 9999), calcule e imprima o d\u00edgito verificador.</p> </li> <li> <p>Para que uma pessoa possa ser indicada para cirurgia bari\u00e1trica, entre outros fatores, ela deve ter um IMC maior ou igual a 40. O IMC \u00e9 calculado como sendo a raz\u00e3o entre o peso (Kg) e o quadrado da altura (m). Construa um programa que receba o peso e a altura de uma pessoa e imprima seu IMC.</p> </li> <li> <p>Dois cabos de energia precisam passar por dentro de um condu\u00edte circular. O condutor de cada cabo possui um raio, \\(R_1\\) e \\(R_2\\). Construa um programa que calcule o menor di\u00e2metro de condu\u00edte que deve ser comprado para que seja poss\u00edvel passar os dois cabos com uma folga de 10%</p> </li> <li> <p>Na maior parte das linguagens de programa\u00e7\u00e3o, temos dispon\u00edveis fun\u00e7\u00f5es para calcular apenas os logaritmos em base 10 e base e. Usando a propriedade que \\(\\log_x\u2061y=\\dfrac{\\log_a\u2061y}{\\log_a\u2061x}\\), fa\u00e7a um programa que leia \\(x\\) e \\(y\\) e calcule \\(\\log_x\u2061y\\).</p> </li> <li> <p>Fa\u00e7a um programa que leia dois valores inteiros em duas vari\u00e1veis distintas, troque o conte\u00fado das duas vari\u00e1veis e apresente os valores originais das vari\u00e1veis e os valores trocados.</p> </li> <li> <p>O lat\u00e3o \u00e9 uma liga composta 70% de cobre e 30% de zinco. Fa\u00e7a um programa que leia o pre\u00e7o do kg de cobre, o pre\u00e7o do kg de zinco e a quantidade de lat\u00e3o que o usu\u00e1rio deseja produzir. A partir dessas informa\u00e7\u00f5es, imprima qual a massa necess\u00e1ria de cobre, de zinco e o custo total da massa de lat\u00e3o produzida.</p> </li> <li> <p>Uma pessoa possui um terreno com forma retangular e deseja saber qual \u00e9 a maior dist\u00e2ncia que ele pode percorrer dentro do terreno em linha reta.  Fa\u00e7a um programa que leia a largura e a profundidade do terreno, calcule e imprima a maior dist\u00e2ncia que pode ser percorrida em linha reta dentro desse terreno</p> </li> <li> <p>No Brasil, os cidad\u00e3os s\u00e3o obrigados a votar. Aqueles que n\u00e3o desejam votar em nenhum dos candidatos dispon\u00edveis acabam escolhendo votar em branco ou votar nulo. Fa\u00e7a um programa que leia o total de eleitores de um munic\u00edpio, o total de votos brancos e o total de votos nulos e apresente o percentual de votos brancos e nulos registrados</p> </li> <li> <p>O peso ideal de um sujeito do sexo masculino pode ser estimado a partir da f\u00f3rmula \\((72.7 \\times h)-58\\), onde \\(h\\) \u00e9 a altura em metros. Fa\u00e7a um programa que leia a altura de um indiv\u00edduo e imprima o peso ideal estimado.</p> </li> <li> <p>O sistema tribut\u00e1rio em um determinado pa\u00eds fict\u00edcio chamado Brasilos n\u00e3o \u00e9 para amadores. H\u00e1 uma infinidade de taxas e al\u00edquotas de impostos que precisam ser calculadas em fun\u00e7\u00e3o do produto que est\u00e1 sendo vendido.  Por exemplo, um carro paga uma al\u00edquota de 45% no pre\u00e7o final, que por sua vez \u00e9 composto pela soma dos custos das diversas mat\u00e9rias primas que s\u00e3o usadas: 5% para pl\u00e1sticos biodegrad\u00e1veis, 9% para metais reciclados, 21% para pl\u00e1sticos n\u00e3o recicl\u00e1veis e 32% para metais n\u00e3o recicl\u00e1veis. Fa\u00e7a um programa que receba os custos das mat\u00e9rias primas usadas para a constru\u00e7\u00e3o de um carro e calcule o pre\u00e7o final do ve\u00edculo e com qual pre\u00e7o ele deve ser vendido para que haja um lucro de 8% para o fabricante.</p> </li> <li> <p>O ponto em que o c\u00e9u parece encontrar a terra ou o mar depende do local onde est\u00e1 o observador e da sua altura (quanto mais alta a pessoa, maior a dist\u00e2ncia). A linha do horizonte s\u00f3 pode ser vista em seu formato original, ligeiramente curvo<sup>1</sup> , em mar aberto ou numa vasta plan\u00edcie sem nenhum relevo. Grosso modo, a dist\u00e2ncia percebida do horizonte pode ser calculada a partir da f\u00f3rmula \\(d=\\sqrt{2hR+h^2}\\), onde \\(d\\) \u00e9 a dist\u00e2ncia, \\(R\\) \u00e9 o raio m\u00e9dio da Terra, e \\(h\\) \u00e9 altura da observa\u00e7\u00e3o. Considerando um raio m\u00e9dio da Terra de 6371km, construa um programa que, dada a altura de uma pessoa (em metros) calcule qual a dist\u00e2ncia percebida at\u00e9 o horizonte. Para efeito de compara\u00e7\u00e3o, uma pessoa com 1,84m enxerga o horizonte a 4842m.</p> </li> <li> <p>Toda a vez que ocorre uma transmiss\u00e3o sem fio, h\u00e1 perda de parte da energia transmitida, chamada atenua\u00e7\u00e3o. Um dessas atenua\u00e7\u00f5es \u00e9 a chamada perda no espa\u00e7o livre (FSPL), que pode ser obtida a partir da f\u00f3rmula \\(\\text{FSPL}=32.5 + 20\\times\\log d + 20 \\times \\log f\\), onde a dist\u00e2ncia \\(d\\) \u00e9 dada em km, e a frequ\u00eancia \\(f\\) \u00e9 dada em MHz.  Fa\u00e7a um programa que calcule qual \u00e9 a perda de espa\u00e7o livre para uma determinada frequ\u00eancia em determinada dist\u00e2ncia, ambos fornecidos pelo usu\u00e1rio.</p> </li> <li> <p>Na matem\u00e1tica, mais especificamente na topologia alg\u00e9brica, a Caracter\u00edstica de Euler (ou N\u00famero de Euler, ou Caracter\u00edstica de Euler-Poicar\u00e9) \u00e9 uma invariante topol\u00f3gica, ou seja, um n\u00famero que descreve a forma ou estrutura de um espa\u00e7o topol\u00f3gico independentemente de como ele \u00e9 dobrado, e geralmente \u00e9 denotado pela letra grega min\u00fascula chi<sup>2</sup> (\\(\\chi\\)). A caracter\u00edstica \\(\\chi\\) foi definida, por Euler, para as superf\u00edcies de um poliedro de acordo com a f\u00f3rmula \\(\\chi=V-E+F\\), onde \\(V\\), \\(E\\) e \\(F\\) representam, respectivamente, o n\u00famero de v\u00e9rtices, arestas e faces. Nos poliedros convexos, \\(\\chi=2\\). Por exemplo, em um tetraedro (pir\u00e2mide de base triangular), temos 4 v\u00e9rtices, 6 arestas e 4 faces, ou seja, \\(4-6+4=2\\). Construa um programa que receba o n\u00famero de faces e de arestas de um poliedro convexo e retorne o n\u00famero de v\u00e9rtices.</p> </li> <li> <p>O c\u00e1lculo da data da P\u00e1scoa, tamb\u00e9m conhecido como Computus em latim, \u00e9 fundamental no calend\u00e1rio crist\u00e3o desde os prim\u00f3rdios da cristandade. No final da antiguidade, a comunidade crist\u00e3 recebia a data da P\u00e1scoa por meio de um an\u00fancio papal, mas a partir do S\u00e9culo III, a Igreja come\u00e7ou a valorizar um sistema que permitisse ao clero determinar de forma independente e consistente a data sem depender da mensagem papal. Definiu-se, ent\u00e3o, que a P\u00e1scoa seria celebrada no primeiro domingo ap\u00f3s a primeira lua cheia que ocorre depois do equin\u00f3cio da Primavera no hemisf\u00e9rio norte (ou do outono no hemisf\u00e9rio sul), ou seja, \u00e9 equivalente \u00e0 antiga regra de que seria o primeiro Domingo ap\u00f3s o 14\u00ba dia do m\u00eas lunar de Nissan. Essa data pode ser verificada em tabelas, ou ent\u00e3o calculada. Para efetuar o c\u00e1lculo da data, h\u00e1 v\u00e1rios algoritmos, sendo que um dos mais recentes foi proposto por Jean Meesus em 1991<sup>3</sup>, e pode ser resumido pelas seguintes opera\u00e7\u00f5es (\"\\\" indica a divis\u00e3o inteira, ou seja, \\(7\\backslash3 = 2\\)):</p> Algoritmo de Jean Meesus<pre><code>a &lt;- resto da divis\u00e3o de ANO por 19\nb &lt;- dois primeiro d\u00edgitos do ANO (por exemplo, 19 para o ano de 1976)\nc &lt;- dois \u00faltimos d\u00edgitos do ANO (por exemplo, 76 para o ano de 1976)\nd &lt;- b \\ 4\ne &lt;- resto da divis\u00e3o de b por 4\nf &lt;- (b + 8) \\ 25\ng &lt;- (b - f + 1) \\ 3\nh &lt;- resto da divis\u00e3o de (19a + b - d - g + 15) por 30\ni &lt;- c \\ 4\nk &lt;- resto da divis\u00e3o de c por 4\nL &lt;- resto da divis\u00e3o de (32 + 2e + 2i - h - k) por 7\nm &lt;- (a + 11h + 22L) \\ 451\n</code></pre> <p>Por fim, o m\u00eas podia ser calculado como \\((h + L - 7m + 114) \\backslash 31\\), e o dia como o resto da divis\u00e3o de \\(1 + (h + L - 7m + 114)\\) por 31. Construa um programa que leia o ano, e indique a data da P\u00e1scoa naquele ano, no formato dd/mm/aaaa.</p> </li> <li> <p>Em eletr\u00f4nica, a regra do divisor de tens\u00e3o, ou simplesmente o divisor de tens\u00e3o, \u00e9 uma t\u00e9cnica de projeto utilizada para criar uma tens\u00e3o el\u00e9trica (\\(V_{out}\\)) que seja proporcional \u00e0 outra tens\u00e3o (\\(V_{in}\\)). Uma forma de fazer isso \u00e9 com um circuito composto por dois resistores em s\u00e9rie, tal como no diagrama unifilar ao lado. A tens\u00e3o de sa\u00edda, \\(V_{out}\\), \u00e9 dada pela equa\u00e7\u00e3o \\(V_{out}=\\dfrac{R_2}{R_1+R_2}\\times V_{in}\\). Construa um programa que receba a tens\u00e3o de entrada, \\(V_{in}\\), e a tens\u00e3o de sa\u00edda desejada, \\(V_{out}\\), e calcule a rela\u00e7\u00e3o necess\u00e1ria entre \\(R_1\\) e \\(R_2\\) para que o divisor possa ser constru\u00eddo. Por exemplo, se \\(V_{in} = 5\\text V\\), e \\(V_{out} = 2,5\\text V\\), ent\u00e3o \\(\\dfrac{R_1}{R_2} = 1\\).</p> </li> <li> <p>A lei de Ohm, descoberta e formulada por Georg Simon Ohm, relaciona as tr\u00eas grandezas el\u00e9tricas principais e demonstra como elas est\u00e3o intrinsecamente ligadas. Com ela, sabemos que a corrente que passa por um circuito \u00e9 diretamente proporcional \u00e0 tens\u00e3o, e inversamente proporcional \u00e0 resist\u00eancia, ou seja, \\(I=V/R\\). Construa um programa que receba a corrente (em amperes) e a tens\u00e3o (em volts), e calcule a resist\u00eancia do circuito (em ohms).</p> </li> <li> <p>Em algumas situa\u00e7\u00f5es, \u00e9 preciso converter um valor que esteja em uma faixa para outro. Por exemplo, um conversor anal\u00f3gico para digital pode fazer uma convers\u00e3o utilizando 1024 n\u00edveis (0 a 1023), mas precisamos que os valores estejam entre 0 e 99 para serem usados. No exemplo anterior, um resultado de 300 na convers\u00e3o de anal\u00f3gico para digital corresponde a um valor de aproximadamente 29 na escala de 0 a 99. Construa um programa que leia os limites inferior e superior da escala original, o valor lido na escala original (de entrada), os limites superior e inferior da escala de modificada (de destino), e calcule e apresente o valor originalmente lido convertido para a escala de destino.</p> </li> </ol> <ol> <li> <p>Assumindo que a Terra n\u00e3o seja plana...\u00a0\u21a9</p> </li> <li> <p>Pronuncia-se igual a \"aqui\", mas sem o \"a\"\u00a0\u21a9</p> </li> <li> <p>MEEUS, J.. Astronomical Algorithms. Richmond, Virginia: Willmann-Bell, 1991.\u00a0\u21a9</p> </li> </ol>"},{"location":"exercicios/repeticao/","title":"Estruturas de repeti\u00e7\u00e3o","text":"<ol> <li> <p>Chico tem 150 cm e cresce 2cm por ano, enquanto Z\u00e9 tem 110cm e cresce 3cm por ano. Fa\u00e7a um programa que calcule e imprima quantos anos s\u00e3o necess\u00e1rios para que Z\u00e9 fique mais alto que Chico.</p> </li> <li> <p>Fa\u00e7a um programa que leia as notas de um aluno e calcule a m\u00e9dia das notas. N\u00e3o se sabe, de antem\u00e3o, o n\u00famero de notas a serem lidas, e a leitura deve encerrar quando uma nota negativa for informada.</p> </li> <li> <p>Na matem\u00e1tica, um n\u00famero perfeito \u00e9 aquele no qual a soma dos seus divisores positivos pr\u00f3prios (excluindo-o) \u00e9 igual ao pr\u00f3prio n\u00famero. Por exemplo, 6 \u00e9 perfeito, pois \\(1 + 2 + 3 = 6\\). Escreva um programa que leia um n\u00famero inteiro positivo menor ou igual a \\(10^8\\) e indique se o n\u00famero \u00e9 perfeito ou n\u00e3o.</p> </li> <li> <p>Fa\u00e7a um programa que imprima os m\u00faltiplos positivos de 7, menores que 1000</p> </li> <li> <p>Determinado material radioativo tem meia-vida de 70 segundos (tempo necess\u00e1rio para que a massa da amostra se reduza \u00e0 metade). Fa\u00e7a um programa que leia a massa inicial e diga quanto tempo (em dias, horas, minutos e segundos) \u00e9 necess\u00e1rio para que reste menos de 0,02g do material.</p> </li> <li> <p>A sequ\u00eancia de Fibonacci \u00e9 formada pelos n\u00fameros 0, 1, 1, 2, 3, 5, 8, 13, 21... (o n\u00famero da vez \u00e9 a soma dos dois anteriores, sendo que o primeiro vale zero, e o segundo vale um). Fa\u00e7a um programa que imprima a sequ\u00eancia de Fibonacci at\u00e9 o n-\u00e9simo termo, informado pelo usu\u00e1rio.</p> </li> <li> <p>Fa\u00e7a um programa que leia o n\u00famero de andares de um pr\u00e9dio e, em seguida, para cada andar do pr\u00e9dio, leia o n\u00famero de pessoas que sa\u00edram e o n\u00famero de pessoas que entram naquele andar. Considere que o elevador est\u00e1 no t\u00e9rreo e inicialmente vazio. O elevador nunca pode ter mais de 7 pessoas simultaneamente dentro dele. Se, em algum momento, houver mais de 7 pessoas no elevador, imprima uma mensagem e deixe apenas 7 pessoas dentro dele. Imprima o n\u00famero de pessoas que chegaram ao \u00faltimo andar.</p> </li> <li> <p>Escreva um programa que receba um n\u00famero inteiro, com qualquer quantidade de d\u00edgitos, e escreva na tela os d\u00edgitos que comp\u00f5em o n\u00famero de tr\u00e1s para a frente. Por exemplo, se for digitado o valor \"4532\", o programa deve imprimir \"dois tr\u00eas cinco quatro\".</p> </li> <li> <p>Produza uma aproxima\u00e7\u00e3o do valor de \\(\\pi\\) utilizando a s\u00e9rie de Gregory-Leibniz (abaixo). O c\u00e1lculo deve parar quando a diferen\u00e7a ente \\(\\pi\\) calculado at\u00e9 o terno \\(n\\) e o calculado at\u00e9 o termo \\(n+1\\) for menor que \\(10^{-5}\\). Imprima o valor calculado de \\(\\pi\\) e o n\u00famero de termos que foram utilizados no c\u00e1lculo da s\u00e9rie. Cuidado com a altern\u00e2ncia de sinal entre os termos da s\u00e9rie.</p> \\[ \\pi \\approxeq 4 - \\dfrac{4}{3} + \\dfrac{4}{5} - \\dfrac{4}{7}  + \\dfrac{4}{9} \\ldots \\] </li> <li> <p>Outra forma de obter uma aproxima\u00e7\u00e3o do valor de \u03c0 \u00e9 por meio da s\u00e9rie de Nilakantha (abaixo). Obtenha uma aproxima\u00e7\u00e3o de \\(\\pi\\) com o uso dela. O c\u00e1lculo deve parar quando a diferen\u00e7a ente \\(\\pi\\) calculado at\u00e9 terno \\(n\\) e o calculado at\u00e9 o termo \\(n+1\\) for menor que \\(10^{-5}\\). Imprima o valor calculado de \\(\\pi\\) e o n\u00famero de termos que foram utilizados no c\u00e1lculo da s\u00e9rie. Cuidado com a altern\u00e2ncia de sinal entre os termos da s\u00e9rie.</p> \\[ \\pi \\approxeq 3 + \\dfrac{4}{2 \\times 3 \\times 4} - \\dfrac{4}{4 \\times 5 \\times 6} + \\dfrac{4}{6 \\times 7 \\times 8}  - \\dfrac{4}{8 \\times 9 \\times 10} \\ldots \\] </li> <li> <p>M\u00e9todos de Monte Carlo s\u00e3o m\u00e9todos estat\u00edsticos que sem baseiam em amostragens aleat\u00f3rias para a obten\u00e7\u00e3o de resultados num\u00e9ricos. Nesses m\u00e9todos, dada uma probabilidade \\(p\\) que determinado evento ocorra em certas condi\u00e7\u00f5es, um computador pode ser usado para gerar essas condi\u00e7\u00f5es por v\u00e1rias vezes. O n\u00famero de vezes que o evento ocorreu dividido pelo n\u00famero de vezes que a condi\u00e7\u00e3o foi gerada deve ser aproximadamente igual a \\(p\\). Por exemplo, vamos considerar um disco de raio 1 inscrito em um quadrado de lado 2. \u00c9 poss\u00edvel gerar pontos aleat\u00f3rios dentro do quadrado e contar quantos caem dentro do disco. A raz\u00e3o entre o n\u00famero de pontos dentro do c\u00edrculo e o total de pontos gerados \u00e9 uma aproxima\u00e7\u00e3o de \\(\\pi\\). Observe que, como podemos dividir o disco em quatro se\u00e7\u00f5es iguais (ou quadrantes), cada uma inscrita em um quadrado de lado 1 (ver figura abaixo<sup>1</sup> ), podemos limitar esse teste ao quadrado de lado 1 e multiplicar o n\u00famero resultante por quatro. Construa um programa que fa\u00e7a a estimativa do valor de \\(\\pi\\) utilizando este m\u00e9todo com 1.000.000 de pontos aleat\u00f3rios<sup>2</sup>.</p> <p></p> <p>Estimando o valor de \\(\\pi\\) com lan\u00e7amentos aleat\u00f3rios</p> </li> <li> <p>Determinada universidade fez uma pesquisa entre os alunos para saber o quanto eles usam o restaurante. Fa\u00e7a um programa que leia um conjunto de respostas de alunos e imprima o total absoluto e em termos percentuais, de alunos que usaram o restaurante: a) menos de 10 vezes; b) mais de 10 e menos de 25 vezes, e; c) 25 vezes ou mais durante o m\u00eas. O programa deve parar de ler respostas quando for digitado o valor -1.</p> </li> <li> <p>Construa um programa que leia a largura L e a altura A de um ret\u00e2ngulo e desenhe-o na tela. Por exemplo, se o usu\u00e1rio pedir largura 10 e altura 4, o seguinte ret\u00e2ngulo deve ser desenhado na tela</p> <pre><code>+--------+\n|        |\n|        |\n+--------+\n</code></pre> </li> <li> <p>Construa um programa que leia um n\u00famero inteiro \\(N\\), calcule e mostre o maior quadrado menor ou igual a \\(N\\). Por exemplo, se \\(N\\) for igual a 38, o maior quadrado \u00e9 36.</p> </li> <li> <p>Fa\u00e7a um programa que imprima os primeiros 20 n\u00fameros inteiros que quando divididos por 11 produzem 5 de resto.</p> </li> <li> <p>Escreva um programa que leia o n\u00famero \\(n\\) de termos de uma progress\u00e3o aritm\u00e9tica, o primeiro termo (\\(a_1\\)) da progress\u00e3o e a raz\u00e3o \\(r\\) da progress\u00e3o e escreva os \\(n\\) termos desta progress\u00e3o, bem como a soma dos elementos.</p> </li> <li> <p>A divis\u00e3o de dois n\u00fameros pode ser feita como uma sucess\u00e3o de subtra\u00e7\u00f5es do valor do divisor do valor do dividendo. O n\u00famero de divis\u00f5es que puderam ser feitas antes de o dividendo ficar menor que zero \u00e9 o quociente, e o que sobrou do dividendo \u00e9 o resto da divis\u00e3o. Fa\u00e7a um programa que leia o dividendo e o divisor e apresente o quociente e o resto utilizando o m\u00e9todo das subtra\u00e7\u00f5es sucessivas.</p> </li> <li> <p>Fa\u00e7a um programa que leia valores inteiros positivos e diga, no final, quantos n\u00fameros pares foram lidos, quantos n\u00fameros \u00edmpares foram lidos, o maior n\u00famero lido e o menor n\u00famero lido. A entrada de dados para com a digita\u00e7\u00e3o do valor -1.</p> </li> <li> <p>Fa\u00e7a um programa que imprima os primeiros 100 n\u00fameros inteiros que n\u00e3o s\u00e3o m\u00faltiplos de 7 ou que terminam em 7 (1, 2, 3, 4, 5, 6, 8, 9, 10, 11, 12, 13, 15, 16, 18, ...)</p> </li> <li> <p>O voleibol \u00e9 um esporte disputado em uma quadra dividida ao meio por uma rede, com dois times de 6 jogadores cada, onde o objetivo \u00e9 fazer a bola passar sobre a rede de modo a que a bola toque no ch\u00e3o dentro da quadra advers\u00e1ria, ao mesmo tempo que se evita que os advers\u00e1rios consigam fazer o mesmo. O jogo come\u00e7a com o saque de um dos times. Logo depois do saque, a bola deve ultrapassar a rede e seguir ao campo do advers\u00e1rio onde os jogadores tentam evitar que a bola entre no seu campo usando qualquer parte do corpo. O jogador pode rebater a bola para que ela passe para o campo advers\u00e1rio sendo permitidos dar tr\u00eas toques na bola antes que ela passe, sempre alternando os jogadores que d\u00e3o os toques. Caso a bola caia, \u00e9 ponto do time advers\u00e1rio. O jogador n\u00e3o pode encostar na rede e, caso isso ocorra, o ponto ser\u00e1 para o outro time. O mesmo jogador n\u00e3o pode dar 2 ou mais toques seguidos na bola, exce\u00e7\u00e3o no caso do toque de Bloqueio. Cada partida \u00e9 dividida em sets que terminam quando uma das duas equipes conquista 25 pontos. Deve haver tamb\u00e9m uma diferen\u00e7a de no m\u00ednimo dois pontos com rela\u00e7\u00e3o ao placar do advers\u00e1rio - caso contr\u00e1rio, a disputa prossegue at\u00e9 que tal diferen\u00e7a seja atingida. O vencedor \u00e9 a equipe que ganhar, primeiro, tr\u00eas sets. Voc\u00ea deve construir um programa que, a cada indica\u00e7\u00e3o de ponto feita (1 para o primeiro time, e 2 para o segundo time), indique o placar atual. Quando faltar um ponto para um time vencer um set, escreva \"set point\" e, quando um time vencer, escreva o n\u00famero do time que ganhou.</p> </li> <li> <p>Na bolsa de valores, um investidor normalmente faz \"pre\u00e7o m\u00e9dio\" de um papel. A ideia \u00e9 tentar entrar no papel em pre\u00e7os diferentes, exatamente para t\u00ea-lo na carteira com um pre\u00e7o que seja a m\u00e9dia do pre\u00e7o dele ao longo de determinado tempo. O pre\u00e7o m\u00e9dio \u00e9 calculado como uma m\u00e9dia ponderada dos pre\u00e7os de compra. Quando um papel \u00e9 vendido, calcula-se o LAIR (lucro antes do imposto de renda) como sendo a diferen\u00e7a entre o pre\u00e7o de venda e o pre\u00e7o m\u00e9dio de compra. Sobre o lucro da opera\u00e7\u00e3o, o investidor paga 15% de imposto de renda, mas legisla\u00e7\u00e3o permite que sejam alienados (vendidos) at\u00e9 \\(R\\$~20000.00\\) por m\u00eas sem que seja necess\u00e1rio pagar imposto de renda sobre o lucro. Por exemplo, se forem compradas 100 a\u00e7\u00f5es de determinado papel a 10.00, e 300 a\u00e7\u00f5es a 7.00, o pre\u00e7o m\u00e9dio \u00e9 de \\(\\dfrac{100\\times10+300\\times7}{100+300}=7.75\\). Se as 400 a\u00e7\u00f5es fossem vendidas a 10,00, o LAIR seria de 900,00 e n\u00e3o haveria imposto a pagar. Construa um programa que leia um inteiro N dizendo quantas compras foram feitas, N pares de valores indicando quantas a\u00e7\u00f5es foram compradas e a que pre\u00e7o, e um valor que indica o pre\u00e7o de venda (assuma que todas as a\u00e7\u00f5es compradas foram vendidas); a partir disso, calcule e imprima o LAIR e o valor do imposto a ser pago.</p> </li> </ol> <ol> <li> <p>https://www.r-bloggers.com/happy-pi-day-now-go-estimate-it/ \u21a9</p> </li> <li> <p>Apesar de m\u00e9todos de Monte Carlo serem \u00fateis para a solu\u00e7\u00e3o de v\u00e1rios problemas em matem\u00e1tica e f\u00edsica que n\u00e3o podem ser resolvidos de forma anal\u00edtica, a ado\u00e7\u00e3o deste m\u00e9todo para a estimativa do valor de \\(\\pi\\) \u00e9 bem lento. Para calcular cada d\u00edgito significativo depois da v\u00edrgula s\u00e3o necess\u00e1rias dez vezes mais pontos aleat\u00f3rios que os necess\u00e1rios para calcular o d\u00edgito anterior.\u00a0\u21a9</p> </li> </ol>"},{"location":"exercicios/selecao/","title":"Estruturas de sele\u00e7\u00e3o","text":"Lembre-se S\u00edmbolo Significado S\u00edmbolo Significado \\(\\lor\\) OR \\(\\land\\) AND \\(\\lnot\\) NOT \\(\\oplus\\) XOR <ol> <li> <p>Assumindo que os predicados \\(A\\), \\(B\\), \\(C\\) e \\(D\\) valem, respectivamente, Falso, Falso, Verdadeiro e Falso, qual o resultado da avalia\u00e7\u00e3o das express\u00f5es l\u00f3gicas a seguir?</p> <ul> <li>\\((A \\lor B) \\land \\lnot C\\)</li> <li>\\((A \\oplus B) \\lor (\\lnot C \\land D)\\)</li> <li>\\((A \\land B) \\oplus (\\lnot C \\lor D)\\)</li> <li>\\((\\lnot A \\lor B) \\land (C \\oplus D)\\)</li> </ul> </li> <li> <p>Considerando os as vari\u00e1veis inteiras p, q e r, com valores 10, 20 e 30 respectivamente, calcule o resultado das express\u00f5es l\u00f3gicas a seguir</p> <ul> <li>\\(p &gt; q\\)</li> <li>\\(q \\geq r\\)</li> <li>\\(r &gt; p\\)</li> <li>\\((p &lt; q) \\land (p &lt; r)\\)</li> <li>\\((p &gt; q) \\lor (r &gt; q)\\)</li> <li>\\(\\lnot(\\lnot(p &gt; q) \\land \\lnot(r &gt; q))\\)</li> </ul> </li> <li> <p>Construa um programa que receba um n\u00famero inteiro e informe se ele \u00e9 positivo, negativo ou nulo, e se ele \u00e9 par ou \u00edmpar.</p> </li> <li> <p>Construa um programa que leia dois n\u00fameros e indique se s\u00e3o iguais ou se s\u00e3o diferentes. Mostre o maior e o menor (nesta sequ\u00eancia).</p> </li> <li> <p>Fa\u00e7a um programa que leia o n\u00famero de um m\u00eas do primeiro semestre do ano (1 a 6) e escreva o nome correspondente. Seu programa deve avisar o usu\u00e1rio se ele digitar um valor fora da faixa poss\u00edvel.</p> </li> <li> <p>Construa um programa que leia tr\u00eas valores (A, B e C) e diga se a soma de A com B \u00e9 menor, maior ou igual a C.</p> </li> <li> <p>Determinada empresa d\u00e1 descontos para mulheres maiores de 45 anos e para jovens de qualquer sexo com menos de 18 anos. Fa\u00e7a um programa que leia o sexo e a idade de uma pessoa e diga se ela tem ou n\u00e3o direito a algum desconto</p> </li> <li> <p>Imagine um banco onde voc\u00ea tem uma conta com um determinado saldo e que aceita apenas uma opera\u00e7\u00e3o de cr\u00e9dito (dep\u00f3sito) ou d\u00e9bito (saque). Construa um programa onde o usu\u00e1rio vai informar o saldo inicial da conta e o valor da opera\u00e7\u00e3o (valores positivos s\u00e3o cr\u00e9ditos, e valores negativos s\u00e3o d\u00e9bitos) e o programa vai informar se a conta tem saldo suficiente para a opera\u00e7\u00e3o, no caso de um d\u00e9bito, ou o saldo final no caso de um cr\u00e9dito.</p> </li> <li> <p>Um hotel possui um esquema de cobran\u00e7a de di\u00e1rias onde, al\u00e9m da di\u00e1ria, a h\u00f3spede paga uma taxa por dia de hospedagem, essa taxa varia com o total de dias da estadia. Se forem at\u00e9 8 dias de hospedagem, a taxa \u00e9 de \\(\\text{R\\$}~8.00\\) por dia, e se o per\u00edodo de hospedagem for maior que 8 dias, a taxa \u00e9 de \\(\\text{R\\$}~5.00\\) por dia.  Construa um programa que receba o valor da di\u00e1ria e o n\u00famero de dias de hospedagem e apresente o valor total a ser pago pelo h\u00f3spede considerando di\u00e1rias e taxas.</p> </li> <li> <p>Uma empresa paga os seus funcion\u00e1rios por hora trabalhada (valor da hora multiplicado pelo total de horas trabalhadas no m\u00eas) depois de descontar alguns encargos trabalhistas. Se o valor bruto a receber do funcion\u00e1rio for menor que \\(\\text{R\\$}~1000.00\\) n\u00e3o h\u00e1 desconto; se o valor for maior que \\(\\text{R\\$}~5000.00\\) o desconto \u00e9 de 27%, e; se o valor estiver na faixa intermedi\u00e1ria, o desconto \u00e9 de 15% do sal\u00e1rio bruto. Em todos os casos, h\u00e1 ainda o desconto do vale transporte, que corresponde a 6% do sal\u00e1rio bruto. Construa um programa que receba o valor da hora de trabalho, o total de horas trabalhadas e escreva o sal\u00e1rio bruto, o total de descontos, e o sal\u00e1rio l\u00edquido (bruto \u2013 descontos) do funcion\u00e1rio.</p> </li> <li> <p>Uma empresa paga ao vendedor uma comiss\u00e3o calculada de acordo com o valor de suas vendas. Se o valor da venda de um corretor for de \\(\\text{R\\$}~50000.00\\) ou mais, a comiss\u00e3o ser\u00e1 de 12% do valor vendido. Se o valor da venda for maior que \\(\\text{R\\$}~30000.00\\) e menor que \\(\\text{R\\$}~50000.00\\), a comiss\u00e3o \u00e9 de 9,5%. Nos demais casos, a comiss\u00e3o \u00e9 de 7%.  Fa\u00e7a um programa que leia o total de vendas de um vendedor e imprima a comiss\u00e3o devida pela empresa a ele.</p> </li> <li> <p>Anos bissextos s\u00e3o aqueles que s\u00e3o m\u00faltiplos de 4, mas n\u00e3o de 100, exceto pelos m\u00faltiplos de 400, que tamb\u00e9m s\u00e3o bissextos. Fa\u00e7a um programa que leia um ano e indique se aquele ano \u00e9 bissexto ou n\u00e3o.</p> </li> <li> <p>O c\u00e1lculo do imposto de renda retido na fonte (IRRF) pago pelo trabalhador do mercado formal \u00e9 calculado de forma escalonada. Considerando a tabela de imposto de renda em vigor (e apresentada a seguir), fa\u00e7a um programa que leia o sal\u00e1rio bruto de um trabalhador e calcule o IRRF a ser pago.</p> <p> M\u00ednimo M\u00e1ximo Al\u00edquota Parcela a deduzir R$ 0,00 R$ 1.903,98 0,0% R$ 0,00 R$ 1.903,99 R$ 2.826,65 7,5% R$ 142,80 R$ 2.826,66 R$ 3.751,05 15,0% R$ 354,80 R$ 3.751,06 R$ 4.664,68 22,5% R$ 636,13 R$ 4.664,68 Ilimitado 27,5% R$ 869,36 <p></p> <p>Por exemplo, algu\u00e9m que ganha \\(\\text{R\\$}~5000.00\\) vai pagar \\(\\text{R\\$}~505.64\\) de imposto, pois \\(5000 \\times \\dfrac{27,5}{100}-869,36=505,64\\).</p> <li> <p>O sistema de avalia\u00e7\u00e3o de determinada disciplina, \u00e9 composto por tr\u00eas provas. A primeira prova tem peso 2, a segunda tem peso 3 e a terceira tem peso 5. Fa\u00e7a um algoritmo para calcular a m\u00e9dia final de um aluno desta disciplina e dizer se ele foi aprovado (m\u00e9dia maior ou igual a seis), se deve fazer prova final (m\u00e9dia maior que quatro e menor que 6) ou se foi reprovado (m\u00e9dia menor ou igual a 4).</p> </li> <li> <p>O ingresso em uma universidade acontece por meio de um processo seletivo com duas fases. Na primeira fase, o certame composto por tr\u00eas provas (P1, P2 e P3). A nota final do candidato \u00e9 calculada pela m\u00e9dia entre as tr\u00eas provas. Passam para a segunda fase aqueles alunos com m\u00e9dia superior a seis, desde que n\u00e3o tenha zerado nenhuma das provas. Fa\u00e7a um programa que leia as tr\u00eas notas e indique se o candidato foi aprovado ou n\u00e3o para a segunda fase.</p> </li> <li> <p>Determinado pa\u00eds possui um sistema monet\u00e1rio com c\u00e9dulas de 100, 50, 20, 10, 5, 2 e 1 dinheiros, e n\u00e3o h\u00e1 divis\u00f5es centesimais (\"centavos\"). Uma loja deseja fazer o troco utilizando a menor quantidade poss\u00edvel de c\u00e9dulas (h\u00e1 um suprimento muito grande de cada uma das c\u00e9lulas). Construa um programa que receba o valor da compra, o valor pago pelo cliente (sempre maior que o valor da compra) e calcule o troco que deve ser dado, indicando quantas c\u00e9dulas de cada valor devem ser usadas.</p> </li> <li> <p>Os sal\u00e1rios de uma empresa possuem um reajuste n\u00e3o-linear, ou seja, quem ganha menos tem um reajuste maior do que o reajuste de quem ganha mais. A regra \u00e9 a seguinte: sal\u00e1rios maiores ou iguais a \\(\\text{R\\$}~10000.00\\) recebem 3% de reajuste; sal\u00e1rios maiores ou iguais a \\(\\text{R\\$}~5000.00\\) e menores que \\(\\text{R\\$}~10000.00\\) recebem 6%, e por fim; sal\u00e1rios menores que \\(\\text{R\\$}~5000.00\\) recebem 10%.  Fa\u00e7a um programa que receba o sal\u00e1rio atual de um funcion\u00e1rio e calcule o valor do reajuste que ser\u00e1 aplicado ao sal\u00e1rio, imprimindo o sal\u00e1rio atual, o valor do reajuste, e o novo sal\u00e1rio.</p> </li> <li> <p>Fa\u00e7a um programa que leia o n\u00famero do m\u00eas e imprima quantos dias ele tem (fevereiro tem, sempre, 28 dias)</p> </li> <li> <p>Fa\u00e7a um programa para jogar papel-pedra-tesoura. O computador deve escolher um n\u00famero entre 1 (papel), 2 (pedra) ou 3 (tesoura), e o usu\u00e1rio deve digitar um n\u00famero tamb\u00e9m entre 1 e 3. Papel ganha de pedra, pedra ganha de tesoura, e tesoura ganha de papel. Imprima quem ganhou, ou se foi empate<sup>1</sup>.</p> </li> <li> <p>O card\u00e1pio de uma lanchonete est\u00e1 representado na tabela abaixo. Escreva um programa que leia o c\u00f3digo do item pedido, a quantidade e calcule o valor a ser pago por aquele lanche. Considere que a cada execu\u00e7\u00e3o somente ser\u00e1 calculado um item.</p> <p> C\u00f3digo Nome do produto Pre\u00e7o unit\u00e1rio 100 Cachorro-quente 1,10 101 Bauru simples 1,30 102 Bauru com ovo 1,50 103 Hamburger 1,10 104 Cheeseburger 1,30 105 Refrigerante 1,00 <p></p> <li> <p>Um banco resolveu oferecer um cr\u00e9dito extraordin\u00e1rio a um conjunto de clientes em fun\u00e7\u00e3o do saldo deles no pr\u00f3prio banco, de acordo com a tabela abaixo. Construa um programa que, dado o saldo do cliente, informe qual o valor do cr\u00e9dito dispon\u00edvel</p> <p> Saldo m\u00ednimo Saldo m\u00e1ximo Cr\u00e9dito R$ 0,00 R$ 200,00 Nenhum cr\u00e9dito R$ 200,01 R$ 1.000,00 20% do saldo R$ 1.000,01 R$ 2.000,00 30% do saldo R$ 2.000,01 R$ 10.000,00 50% do saldo R$ 10.000,01 Ilimitado 100% do saldo <p></p> <li> <p>O \u00edndice massa corporal (IMC) de uma pessoa \u00e9 calculado como sendo a raz\u00e3o entre o peso (Kg) e o quadrado da altura (m). Construa um programa que receba o peso e a altura de uma pessoa e imprima seu resultado  de acordo com a tabela abaixo.</p> <p> Limite inferior (incluindo) Limite superior (excluindo) Resultado 0,00 18,5 Abaixo do peso 18,5 25,0 Peso normal 25,0 30,0 Sobrepeso 30,0 35,0 Obesidade grau 1 35,0 40,0 Obesidade grau 2 40,0 Ilimitado Obesidade grau 3 <p></p> <li> <p>Construa um programa que leia um n\u00famero inteiro entre 1 e 7 e informe o dia da semana correspondente, sendo domingo o dia de n\u00famero 1. Se o n\u00famero n\u00e3o corresponder a um dia da semana, mostre uma mensagem de erro.</p> </li> <li> <p>Crie um programa que leia uma letra entre A e Z e imprima se a letra lida foi uma vogal ou uma consoante.</p> </li> <li> <p>Hoje os carros flex, que podem rodar com gasolina e/ou etanol, s\u00e3o comuns nas grandes cidades. Um problema que a maior parte dos donos de carros flex tem \u00e9 decidir se vai abastecer com gasolina ou com etanol. N\u00e3o adianta olhar, apenas, para o pre\u00e7o por litro (\\(\\text{R\\$}~6,30\\) da gasolina contra \\(\\text{R\\$}~4.00\\) do etanol por esses dias, por exemplo), porque o carro rodando com etanol gasta mais litros de combust\u00edvel por Km rodado, e esse consumo varia de carro para carro. Por exemplo, um determinado carro pode fazer 18Km/litro com gasolina e 10Km/litro com etanol, enquanto outro faz 22Km/l contra 12Km/l. Voc\u00ea deve construir um programa que receba a dist\u00e2ncia que ser\u00e1 percorrida pelo carro, o consumo em Km/l com gasolina e com etanol, os pre\u00e7os por litro da gasolina e do etanol e apresente para o usu\u00e1rio qual combust\u00edvel \u00e9 mais vantajoso (vai custar menos para fazer a viagem) e qual ser\u00e1 o custo da viagem com esse combust\u00edvel.</p> </li> <li> <p>Sobrou um dinheiro no final do m\u00eas e voc\u00ea tem diversas op\u00e7\u00f5es para investir esse dinheiro, variando as taxas (quanto ele aumenta por m\u00eas, com juros compostos ) e os prazos de investimento (quanto tempo ele vai ficar l\u00e1). Por exemplo, \\(\\text{R\\$}~100.00\\) aplicados por 12 meses em uma taxa de 0,8% ao m\u00eas produzem \\(\\text{R\\$}~110.03\\) no final do per\u00edodo. S\u00e3o tantas op\u00e7\u00f5es que o melhor a fazer \u00e9 escrever um programa que receba o valor dispon\u00edvel para investir, as taxas e os prazos de duas aplica\u00e7\u00f5es e indique qual das duas \u00e9 mais vantajosa (em qual voc\u00ea vai ter mais dinheiro no final do per\u00edodo de investimento)<sup>2</sup>.</p> </li> <li> <p>Aproveitando a alta demanda, um hotel introduziu um esquema de cobran\u00e7a de di\u00e1rias que cobra mais de quem fica por mais tempo, e faz isso por meio de uma \"taxa de servi\u00e7os\" que \u00e9 acrescentada em cada dia que o h\u00f3spede fica no hotel. Essa taxa est\u00e1 representada na tabela abaixo. Fa\u00e7a um programa que leia o valor da di\u00e1ria e o n\u00famero de dias que ele ficou hospedado e imprima o custo total da hospedagem.</p> <p> Di\u00e1rias Taxa At\u00e9 3 R$ 20,00 Entre 3 e 7 R$ 35,00 Entre 7 e 10 R$ 40,00 Acima de 10 R$ 50,00 <p></p> <li> <p>Uma operadora criou um plano de celular onde tudo \u00e9 cobrado de forma escalonada. Para simplificar o problema, vamos nos ater apenas \u00e0 conta de dados trafegados. A cobran\u00e7a segue a seguinte l\u00f3gica: o primeiro 1GiB tem um custo fixo de \\(\\text{R\\$}~19.99\\) independente do tr\u00e1fego. Os 2GiB seguintes custam \\(\\text{R\\$}~24.99\\) por 1GiB cobrado de maneira proporcional. Por fim, o tr\u00e1fego acima de 2048MiB \u00e9 cobrado \u00e0 raz\u00e3o de \\(\\text{R\\$}~29.99\\)/1GiB, tamb\u00e9m de maneira proporcional. Fa\u00e7a um programa que receba o consumo de dados em um determinado m\u00eas, em GiB, e imprima o valor da conta. Por exemplo, se o consumo foi de 3,8GiB o valor da conta ser\u00e1 de \\(\\text{R\\$}~19.99\\) pelo primeiro GiB, mais \\(\\text{R\\$}~24.99 \\times 2\\) pelos 2GiB seguintes, mais \\(\\text{R\\$}~29.99 \\times 0.8\\) pelos 0,8GiB que restaram, totalizando \\(\\text{R\\$}~79.97\\). Mostre o valor final da conta com apenas 2 decimais.</p> </li> <li> <p>Determinada institui\u00e7\u00e3o de ensino avalia seus alunos em cada disciplina com base na frequ\u00eancia e nas notas obtidas em duas provas, a partir das quais \u00e9 calculada a nota final da disciplina como sendo a m\u00e9dia aritm\u00e9tica entre as duas provas. Para que um aluno seja aprovado na disciplina. Caso o aluno tenha uma frequ\u00eancia menor que 75% nas aulas, ele est\u00e1 automaticamente reprovado, independente da m\u00e9dia que ele obteve. Se a frequ\u00eancia for igual ou superior a 75% e a m\u00e9dia for maior ou igual a 6,00, ele est\u00e1 aprovado. Se a m\u00e9dia for inferior a 4,00, ele est\u00e1 reprovado. No caso de \\(4 \\leq \\text{m\u00e9dia} &lt; 6\\), o aluno deve fazer uma nova prova. Se nessa nova prova a nota for maior ou igual a 6,00, ele est\u00e1 aprovado com a m\u00e9dia obtida nesta \u00faltima prova; no caso de uma m\u00e9dia menor que 6,00, ele est\u00e1 reprovado na disciplina tendo, como m\u00e9dia, a maior nota entre a m\u00e9dia original e a nota obtida na prova final.  Construa um programa que leia o total de aulas ministradas, o total de faltas do aluno, as notas necess\u00e1rias; a partir desses dados, indique a m\u00e9dia da disciplina (apenas nos casos em que a frequ\u00eancia \u00e9 igual ou superior a 75%, e se ele foi reprovado por frequ\u00eancia, reprovado por nota, aprovado na prova final ou reprovado na prova final.</p> </li> <ol> <li> <p>Como desafio, implemente o papel-pedra-tesoura-lagarto-Spock. Aqui voc\u00ea tem a lista de quem ganha de quem.\u00a0\u21a9</p> </li> <li> <p>Depois de \\(n\\) per\u00edodos, com taxa de juros \\(i\\) a cada per\u00edodo, \u00e9 poss\u00edvel saber o valor futuro (\\(FV\\)) a partir de um valor presente (\\(PV\\)) e vice-versa a partir da f\u00f3rmula \\(FV=PV\\times(1+i)^n\\). Por exemplo, se \\(PV=100\\), \\(n=12\\) e \\(i=1%\\), temos \\(FV=100\\times(1+1/100)^12=112.68\\) \u21a9</p> </li> </ol>"},{"location":"python/biblioteca_python/","title":"Trechos de c\u00f3digo relevantes em Python e cheat sheets","text":""},{"location":"python/biblioteca_python/#numero-aleatorios","title":"N\u00famero aleat\u00f3rios","text":"<p>Desde a vers\u00e3o 3.6, o Pyhton passou a incorporar o m\u00f3dulo <code>secrets</code>. Esse m\u00f3dulo pode ser usado, em substitui\u00e7\u00e3o do m\u00f3dulo <code>random</code>, para a gera\u00e7\u00e3o de n\u00fameros aleat\u00f3rios criptograficamente seguros. A principal diferen\u00e7a \u00e9 que esse novo m\u00f3dulo utiliza, sempre, a fonte mais segura de aleatoriza\u00e7\u00e3o dispon\u00edvel no sistema.</p> Python<pre><code>import secrets\nimport string\n\n#          A-Z, a-z             + 0-9\nalphabet = string.ascii_letters + string.digits\n\n# Seleciona um elmento da lista alphabet\npassword = ''.join(secrets.choice(alphabet) for i in range(10))\n\n# Retorna um n\u00famero inteiro, positivo, abaixo de 20\npassword = secrets.randbelow(20)\n\n# Retorna um inteiro, positivo, com 7 bits\npassword = secrets.randbits(7)\n\n# Retorna uma cadeia de bytes contendo 10 bytes\ntoken = secrets.token_bytes(10)\n\n# Retorna uma cadeia de caracteres contendo 10 bytes\n# representados em hexadecimal\ntoken2 = secrets.token_hex(10)\n</code></pre> <p>O m\u00f3dulo <code>random</code> ainda est\u00e1 dispon\u00edvel, e pode ser usado em situa\u00e7\u00f5es nas quais a robustez oferecida pelo m\u00f3dulo <code>secrets</code> n\u00e3o for necess\u00e1ria.</p> Python<pre><code>import random\nimport string\n\n#          A-Z, a-z             + 0-9\nalphabet = string.ascii_letters + string.digits\n\n# Inicializa o gerador de n\u00fameros pseudo-aleat\u00f3rios com uma semente\n# igual ao hor\u00e1rio atual\nrandom.seed()\n\n# Retorna um n\u00famero de ponto flutuante, [0.00 e 1.00[\nnumero = random.random()\n# Seleciona um elmento da lista alphabet\npassword = ''.join(random.choice(alphabet) for i in range(10))\n\n# Retorna um n\u00famero inteiro, positivo, abaixo de 20\npassword = random.randint(0, 20)\n\n# Retorna um inteiro, positivo, com 7 bits\npassword = random.getrandbits(7)\n\n# Embaralha uma lista\nmensagem = list('Mensagem')\nprint(mensagem)  # ['M', 'e', 'n', 's', 'a', 'g', 'e', 'm']\nrandom.shuffle(mensagem)\nprint(mensagem)  # ['m', 'n', 'e', 'e', 'M', 'a', 's', 'g']\n</code></pre>"},{"location":"python/biblioteca_python/#data-atual","title":"Data atual","text":"Python<pre><code>from datetime import datetime\n\nnow = datetime.now()\n\n# dd/mm/YY\nd1 = now.strftime(\"%d/%m/%Y\")\nprint(\"d1 =\", d1)       # d1 = 20/03/2022\n\n# M\u00eas textual, dia e ano\nd2 = now.strftime(\"%B %d, %Y\")\nprint(\"d2 =\", d2)       # d2 = March 20, 2022\n\n# mm/dd/y\nd3 = now.strftime(\"%m/%d/%y\")\nprint(\"d3 =\", d3)       # d3 = 03/20/22\n\n# Abrevia\u00e7\u00e3o do m\u00eas, dia e ano\nd4 = now.strftime(\"%b-%d-%Y\")\nprint(\"d4 =\", d4)       # d4 = Mar-20-2022\n\n# H:M:S\nd5 = now.strftime(\"%H:%M:%S\")\nprint(\"d5 =\", d5)       # d5 = 22:35:39\n\n# Estamos no ano de 2022, m\u00eas de 3\nprint(f\"Estamos no ano de {now.year}, m\u00eas {now.month}\")\n</code></pre>"}]}